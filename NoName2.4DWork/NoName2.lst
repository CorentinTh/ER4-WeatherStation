file C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg

file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\uLCD-32PTU.fnc

000001  000001  #platform "uLCD-32PTU"              // Setup the programming environnement (Note : nothing should be before this instruction)
000002  000001  #platform "uLCD-32PTU"              // Setup the programming environnement (Note : nothing should be before this instruction)
000003  000008  */
000004  000009      #constant ULCD_32PT_GFX
000005  000009      #constant ULCD_32PT_GFX
000006  000010        
000007  000011      #IFNOT EXISTS PICASO_FUNCTIONS
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\PicasoFunctions.fnc

000008  000012          #inherit "PicasoFunctions.fnc"          // inherit the generic functions
000009  000012          #inherit "PicasoFunctions.fnc"          // inherit the generic functions
000010  000001        
000011  000002  // Common inheritance for PicasoGFX2 platforms
000012  000003        
000013  000004  #constant PICASO_FUNCTIONS
000014  000004  #constant PICASO_FUNCTIONS
000015  000005        
000016  000006        
000017  000007  #CONST
000018  000017  #END
000019  000018        
000020  000019  #CONST
000021  000025  #END
000022  000026        
000023  000027        
000024  000028  #CONST
000025  000040  #END
000026  000041        
000027  000042        
000028  000043  #CONST
000029  000208  #END
000030  000209        
000031  000210        
000032  000211  // baud divisor rates for setbaud(n);
000033  000212  #CONST
000034  000234  #END
000035  000235        
000036  000236        
000037  000237        
000038  000238        
000039  000243  */
000040  000244        
000041  000245        
000042  000246  //==============================================//
000043  000247  // EVE bios functions                           //
000044  000248  //==============================================//
000045  000249                                                  //
000046  000250  func serin(), 1;                // read a byte from COM0
000047  000251  // Syntax: serin();
000048  000252  // Usage : char := serin();
000049  000253  // Notes : Receives a character from the Serial Port COM0. The transmission format is:
000050  000254  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000051  000255  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000052  000256  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000053  000257  //     : Returns: -1 if no character is available
000054  000258  //     : Returns: -2 if a framing error or over-run has occurred (auto cleared)
000055  000259  //     : Returns: positive value 0 to 255 for a valid character received
000056  000260        
000057  000261  func putch("char"), 0;                // write single char to current output device
000058  000262  // Syntax: putch("char");
000059  000263  // Usage : putch("A");
000060  000264  // Notes : Transmits a single byte from the Serial Port COM0. The transmission format is:
000061  000265  //     : No Parity, 1 Stop Bit, 8 Data Bits (N,8,1).
000062  000266  //     : The default Baud Rate is 115,200 bits per second or 115,200 baud. The baud rate can be
000063  000267  //     : changed under program control by using the setbaud(...) or the com_SetBaud(...) function.
000064  000268  //     : The arguments can be a variable, array element, expression or constant
000065  000269        
000066  000270  func serout("char"), 0;                // write a byte to COM0
000067  000271  // Syntax: serout1("char");
000068  000272  // Usage : serout1(ch);
000069  000273  // Notes : send character to COM1
000070  000274        
000071  000275  func setbaud("baudnum"), 0;            // set baud rate of COM0
000072  000276  // Syntax: setbaud(baud_number);
000073  000277  // Usage : setbaud(BAUD_128000);        //Set baud rate to 128000bps
000074  000278  // *Notes : argument specifies the baud rate using pre-defined constant.
000075  000279  //       : The pre-defined constant is a value of 0-19 , and internally
000076  000280  //       : this is used as a table pointer to get the baud rate divisor
000077  000281  //       : value for one of the 20 selected baud rates, control is then
000078  000282  //       : passed to com_SetBaud(COM0, baudlookup[baud_number]);
000079  000283  //       : The pre-defined constants equate to a value of 0-19.
000080  000284  //       : If a value other than 0-19 is used, a run time error (eror 25)
000081  000285  //       : will occur.
000082  000286        
000083  000287  func to("device"), 1;                // output device redirection
000084  000288  // Syntax: to(outstream);
000085  000289  // Usage : to(APPEND); putstr("TWO ");
000086  000290  // Notes : outstream: A variable or constant specifying destination for putch, putstr, putnum and print functions.
000087  000291  //     :
000088  000292  //     : to() sends the printed output to destinations other than the screen. Normally, print just
000089  000293  //     : sends its output to the display in TEXT mode which is the default, however, the output from
000090  000294  //     : print can be sent to COM0, and MDA (media) 'streams'. The to(...) function can also stream
000091  000295  //     : to a memory array . Note that once the to(...) function has taken effect, the stream reverts
000092  000296  //     : back to the default stream which is TEXT as soon as putch, putstr, putnum or print has
000093  000297  //     : completed its action. The APPEND argument is used to send the printed output to the same
000094  000298  //     : place as the previous redirection. This is most useful for building string arrays, or adding
000095  000299  //     : sequential data to a media stream.
000096  000300  //     :
000097  000301  //     : Predefined Name Constant    putch(), putstr(), putnum(), print() redirection
000098  000302  //     : APPEND         0x0000      Output is directed to the same stream that was previously assigned. Output is
000099  000303  //     :                            appended to user memory if previous redirection was to an array.
000100  000304  //     : COM0           0xFF04      Output is redirected to the COM (serial) port.
000101  000305  //     : TEXT           0xFF08      Output is directed to the screen (default).
000102  000306  //     : MDA            0xFF10      Output is directed to the SD or FLASH media.
000103  000307  //     : I2C            0xF820      Output is directed to the I2C port.
000104  000308  //     : memory pointer             Output is redirect to the memory pointer argument, eg to(myarray); print("HELLO");
000105  000309        
000106  000310        
000107  000311  func pause("milliseconds"), 0;            // blocking delay
000108  000312  // Syntax: pause(milliseconds);
000109  000313  // Usage : pause(1000);                //pause for 1 second
000110  000314  // Notes : Pause for a number of milli second.Maximum delay could be 65535 milli seconds
000111  000315        
000112  000316  func putnum("arg1","arg2"), 1;            // print number to current output device
000113  000317  // Syntax: putnum(format, value);
000114  000318  // Usage : var := putnum(HEX, val);
000115  000319  // Notes : prints a 16bit number in various formats to the current output stream, usually the display.
000116  000320  //     : Format: A constant that specifies the number format
000117  000321  //     : Value : The number to be printed
000118  000322  //     : (      DECIMAL   )    (   UNSIGNED DECIMAL )    (    HEX         )     (    BINARY          )
000119  000323  //     : DEC     DECZ     DECZB     UDEC     UDECZ     UDECZB     HEX     HEXZ     HEXZB     BIN     BINZ     BINZB
000120  000324  //     : DEC1 DEC1Z     DEC1ZB     UDEC1     UDEC1Z     UDEC1ZB HEX1     HEX1Z     HEX1ZB     BIN1     BIN1Z     BIN1ZB
000121  000325  //     : DEC2 DEC2Z     DEC2ZB     UDEC2     UDEC2Z     UDEC2ZB HEX2     HEX2Z     HEX1ZB     BIN2     BIN2Z     BIN2ZB
000122  000326  //     : DEC3 DEC3Z     DEC3ZB     UDEC3     UDEC3Z     UDEC3ZB HEX3     HEX3Z     HEX1ZB     BIN3     BIN3Z     BIN3ZB
000123  000327  //     : DEC4 DEC4Z     DEC4ZB     UDEC4     UDEC4Z     UDEC4ZB HEX4     HEX4Z     HEX1ZB     BIN4     BIN4Z     BIN4ZB
000124  000328  //     : DEC5 DEC5Z     DEC5ZB     UDEC5     UDEC5Z     UDEC5ZB             BIN5     BIN5Z     BIN5ZB
000125  000329  //     :                                     BIN6     BIN6Z     BIN6ZB
000126  000330  //     :                                     BIN7     BIN7Z     BIN7ZB
000127  000331  //     :                                     BIN8     BIN8Z     BIN8ZB
000128  000332  //     :                                     BIN9     BIN9Z     BIN9ZB
000129  000333  //     :                                     BIN10     BIN10Z     BIN10ZB
000130  000334  //     :                                     BIN11     BIN11Z     BIN11ZB
000131  000335  //     :                                     BIN12     BIN12Z     BIN12ZB
000132  000336  //     :                                     BIN13     BIN13Z     BIN13ZB
000133  000337  //     :                                     BIN14     BIN14Z     BIN14ZB
000134  000338  //     :                                     BIN15     BIN15Z     BIN15ZB
000135  000339  //     :                                     BIN16     BIN16Z     BIN16ZB
000136  000340  //     : field: Returns the the default width of the numeric field (digit count), usually ignored.
000137  000341  //     : bit 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
000138  000342  //     : | | | | \___ ___/ \__ __/ \_____ _____/
000139  000343  //     : | | | | V V V
000140  000344  //     : | | | | | | |
000141  000345  //     : | | | | | |
000142  000346  //     : | | | | (nb 0 = 16) | |____BASE (usually 2,10 or 16)
000143  000347  //     : | | | | digit count |
000144  000348  //     : | | | | |___reserved (not used on GOLDELOX)
000145  000349  //     : | | | |
000146  000350  //     : | | | |
000147  000351  //     : | | | |
000148  000352  //     : | | | |
000149  000353  //     : | | | |
000150  000354  //     : | | | |______ 1 = leading zeros included
000151  000355  //     : | | | 0 = leading zeros suppressed
000152  000356  //     : | | |
000153  000357  //     : | | |
000154  000358  //     : | | |_______ 1 = leading zero blanking
000155  000359  //     : | |
000156  000360  //     : | |_____ sign bit (0 = signed, 1 = unsigned)
000157  000361  //     : |
000158  000362  //     : |______ 1 = space before unsigned number
000159  000363        
000160  000364        
000161  000365  func translate("arg1","arg2","arg3","arg4"), 1; // list translator (internal use only, not usable)
000162  000366        
000163  000367  func putstr("string"), 1;                       // print string to current output device
000164  000368  // Syntax: putstr(pointer);
000165  000369  // Usage : putstr("HELLO\n");
000166  000370  // Notes : putstr prints a string to the current output stream, usually the display. The argument can be
000167  000371  //       : a string constant, a word aligned pointer to a string, a pointer to an array, or a pointer to
000168  000372  //       : a data statement. Note that string constants and data statement pointers are byte aligned.
000169  000373  //       : The output of putstr can be redirected to the communications port, the media, or memory
000170  000374  //       : using the to(...); function.
000171  000375  //       : A string constant is automatically terminated with a zero.
000172  000376  //       : A string in a data statement is not automatically terminated with a zero.
000173  000377  //       : All variables in 4DGL are 16bit, if an array is used for holding 8 bit characters, each array
000174  000378  //       : element packs 1 or 2 characters.
000175  000379        
000176  000380        
000177  000381  func strlen("varAddress"), 1;                   // return length of a var packed string in character units
000178  000382  // Syntax: strlen("varAddress);
000179  000383  // Usage : strlen("HELLO\n");
000180  000384  // Notes : gives the length of a string that is packed into regular var array
000181  000385  //       : Use str_Length(ptr)  for string pointer mode
000182  000386        
000183  000387        
000184  000388  //==============================================//
000185  000389  // Memory Access Function Prototypes            //
000186  000390  //==============================================//
000187  000391                                                  //
000188  000392  func peekW("address"), 1;                       // read a word from system memory
000189  000393  func pokeW("address", "wordvalue"), 0;          // write a word to system memory
000190  000394  // refer to address map of internal variables   //
000191  000395  //==============================================//
000192  000396  // Math Functions                               //
000193  000397  //==============================================//
000194  000398                                                  //
000195  000399  func ABS("value"), 1;                           // return a positive number
000196  000400  // Syntax: ABS(value);
000197  000401  // Usage : var := ABS(arg);
000198  000402  // Notes : Returns the absolute value of an argument
000199  000403        
000200  000404  func MIN("value1", "value2"), 1;                // return the smaller of 2 numbers
000201  000405  // Syntax: MIN(value1, value2);
000202  000406  // Usage : var := MIN(arg1, arg2);
000203  000407  // Notes : Returns the minimum of 2 arguments
000204  000408        
000205  000409  func MAX("value1", "value2"), 1;                // return the larger of 2 numbers
000206  000410  // Syntax: MAX(value1, value2);
000207  000411  // Usage : var := MAX(arg1, arg2);
000208  000412  // Notes : Returns the maximum of 2 arguments
000209  000413        
000210  000414  func SWAP("&var", "&var"), 0;                   // swap 2 variables, arguments must point to variables
000211  000415  // Syntax: SWAP(&var1, &var2);
000212  000416  // Usage : SWAP(&var1, &var2);
000213  000417  // Notes : Swaps the contents of 2 variables or memory locations
000214  000418        
000215  000419  func SIN("angle"), 1;                           // return SIN of angle
000216  000420  // Syntax: SIN(angle);
000217  000421  // Usage : var := SIN(arg);
000218  000422  // Notes : Returns the sine in radians of an argument in degrees
000219  000423  //       : the returned value range is from 127 to -127. The real
000220  000424  //       : cosine values vary from 1.0 to -1.0 so appropriate
000221  000425  //       : scaling must be done in user code.
000222  000426        
000223  000427  func COS("angle"), 1;                           // return COS of angle
000224  000428  // Syntax: COS(angle);
000225  000429  // Usage : var := COS(arg);
000226  000430  // Notes : Returns the cosine in radians of an argument in degrees
000227  000431  //       : the returned value range is from 127 to -127. The real
000228  000432  //       : cosine values vary from 1.0 to -1.0 so appropriate
000229  000433  //       : scaling must be done in user code.
000230  000434        
000231  000435  func RAND(), 1;                                 // return a pseudo random number
000232  000436  // Syntax: RAND();
000233  000437  // Usage : var := RAND();
000234  000438  // Notes : Returns a random number between 0 and 0xFFFF.
000235  000439  //       : The random number generator must first be seeded
000236  000440  //       : by using the SEED(number) function.
000237  000441        
000238  000442  func SEED("number"), 0;                         // re-seed the pseudo random number generator
000239  000443  // Syntax: SEED(number);
000240  000444  // Usage : SEED(arg);
000241  000445  // Notes : Seeds the random number generator.
000242  000446        
000243  000447  func OVF(), 1;                                  // returns upper 16bits of 32bit results
000244  000448  // Syntax: OVF();
000245  000449  // Usage : loWord := 0x2710 * 0x2710;           // (10000 * 10000 in hex format)
000246  000450  //       : hiWord := OVF();
000247  000451  // Notes : This function returns the high order 16 bits from certain math and shift functions..
000248  000452        
000249  000453  func SQRT("number"), 1;                         // return square root of a number
000250  000454  // Syntax: SQRT(number);
000251  000455  // Usage : SQRT(arg);
000252  000456  // Notes : Returns the integer square root of a number.
000253  000457  //------------------------------------------------------------------//
000254  000458  //          Text Related Function Prototypes
000255  000459  //------------------------------------------------------------------//
000256  000460        
000257  000461  func txt_MoveCursor("line", "column"), 0;
000258  000462  // Syntax: txt_SetCursor(line, column);
000259  000463  // Usage : txt_SetCursor(arg1, arg2);
000260  000464  // Notes : Moves the text Cursor to a new screen position set by
000261  000465  //       : line,column parameters.
000262  000466        
000263  000467  func txt_Set("mode", "value"), 0;
000264  000468  // Syntax: txt_Set(mode, value);
000265  000469  // Usage : txt_Set(arg1, arg2);
000266  000470  // Returns : Original value before the change
000267  000471  // Notes : Sets various text related parameters used by other functions
000268  000472  //       : This allows the features to be set programatically with a
000269  000473  //       : single function call.It is strongly recommended to use the
000270  000474  //       : pre-defined constants rather than the mode numbers.
000271  000475  //       : NB:- Although it is often required to be able to set text
000272  000476  //       : functions with a single function call for graphics engine
000273  000477  //       : related functions, there is a complete set of single parameter
000274  000478  //       : shortcut functions that have exactly the same function as
000275  000479  //       : each of the txt_Set modes and saves 1 parameter / uses less memory
000276  000480  //       :
000277  000481  //       : mode = TEXT_COLOUR (mode 0)
000278  000482  //       : txt_Set(TEXT_COLOUR, value);
000279  000483  //       : value = 0 to 0xFFFF, Black to White
000280  000484  //       : Sets the Text colour for the display
000281  000485  //       : Default = LIME.
000282  000486  //       :
000283  000487  //       : mode = TEXT_HIGHLIGHT (mode 1)
000284  000488  //       : txt_Set(TEXT_HIGHLIGHT, value);
000285  000489  //       : value = 0 to 0xFFFF, Black to White
000286  000490  //       : Sets the Text background colour for the display. Effective
000287  000491  //       : when text mode is Opaque.
000288  000492  //       : Default = BLACK.
000289  000493  //       :
000290  000494  //       : mode = FONT_ID (mode 2)
000291  000495  //       : txt_Set(FONT_ID, value);
000292  000496  //       : value = FONT1, FONT2 or FONT3 for internal fonts
000293  000497  //       : else this value is the name of a font included
000294  000498  //       : in a users program in a data statement.
000295  000499  //       : Default = FONT SIZE 3.
000296  000500  //       :
000297  000501  //       : mode = TEXT_WIDTH  (mode 3)
000298  000502  //       : txt_Set(TEXT_WIDTH, value);
000299  000503  //       : value = 1 to 16
000300  000504  //       : Sets the Text Width multiplier
000301  000505  //       : text will be printed magnified horizontally
000302  000506  //       : by this factor, Default = 1.
000303  000507  //       :
000304  000508  //       : mode = TEXT_HEIGHT  (mode 4)
000305  000509  //       : txt_Set(TEXT_HEIGHT, value);
000306  000510  //       : value = 1 to 16
000307  000511  //       : Sets the Text Height multiplier
000308  000512  //       : text will be printed magnified vertically
000309  000513  //       : by this factor, Default = 1.
000310  000514  //       :
000311  000515  //       : mode = TEXT_XGAP  (mode 5)
000312  000516  //       : txt_Set(TEXT_XGAP, value);
000313  000517  //       : value = 1 to 32
000314  000518  //       : Sets the horizontal gap between characters
000315  000519  //       : The gap is in pixel units, Default = 0
000316  000520  //       :
000317  000521  //       : mode = TEXT_YGAP  (mode 6)
000318  000522  //       : txt_Set(TEXT_YGAP, value);
000319  000523  //       : value = 1 to 32
000320  000524  //       : Sets the vertical gap below characters
000321  000525  //       : The gap is in pixel units, Default = 0
000322  000526  //       :
000323  000527  //       : mode = TEXT_PRINTDELAY  (mode 7) DEPRECATED
000324  000528  //       : txt_Set(TEXT_PRINTDELAY, value);
000325  000529  //       : value = 0 to 255
000326  000530  //       : Sets the delay time (in ms) during character
000327  000531  //       : printing to give a 'teletype' like effect.
000328  000532  //       : Often used to attract attention to a string
000329  000533  //       : being printed which can often be missed if
000330  000534  //       : just suddenly appearing or changing.
000331  000535  //       : Default = 0 ms.
000332  000536  //       :
000333  000537  //       : mode = TEXT_OPACITY (mode 8)
000334  000538  //       : txt_Set(TEXT_OPACITY, value);
000335  000539  //       : value = TRANSPARENT (0) = Text Trasparent
000336  000540  //       : value = OPAQUE (1) = Text Opaque
000337  000541  //       : Sets the Opacity/Transparency of the text
000338  000542  //       : Default = 0 or TRANSPARENT
000339  000543  //       :
000340  000544  //       : mode = TEXT_BOLD (mode 9)
000341  000545  //       : txt_Set(TEXT_BOLD, value);
000342  000546  //       : value = dont care
000343  000547  //       : Sets Bold Text mode for the next string or char
000344  000548  //       : The feature automatically resets after printing
000345  000549  //       : using putstr or print has completed
000346  000550  //       :
000347  000551  //       : mode = TEXT_ITALIC (mode 10)
000348  000552  //       : txt_Set(TEXT_ITALIC, value);
000349  000553  //       : value = dont care
000350  000554  //       : Sets Italic Text mode for the next string or char
000351  000555  //       : The feature automatically resets after printing
000352  000556  //       : using putstr or print has completed
000353  000557        
000354  000558  //       : mode = TEXT_INVERSE (mode 11)
000355  000559  //       : txt_Set(TEXT_INVERSE, value);
000356  000560  //       : value = dont care
000357  000561  //       : Sets Inverse Text mode for the next string or char
000358  000562  //       : The feature automatically resets after printing
000359  000563  //       : using putstr or print has completed
000360  000564  //       :
000361  000565  //       : mode = TEXT_UNDERLINED (mode 12)
000362  000566  //       : txt_Set(TEXT_UNDERLINED, value);
000363  000567  //       : value = dont care
000364  000568  //       : Sets Underlined Text mode for the next string or char
000365  000569  //       : The feature automatically resets after printing
000366  000570  //       : using putstr or print has completed
000367  000571  //       :
000368  000572  //       : mode = TEXT_ATTRIBUTES (mode 13)
000369  000573  //       : txt_Set(TEXT_ATTRIBUTES, value);
000370  000574  //       : value = bits are defined as:
000371  000575  //       :  BOLD        16          // TEXT_ATTRIBUTES bold text (auto reset)
000372  000576  //       :  ITALIC      32          // TEXT_ATTRIBUTES italic text (auto reset)
000373  000577  //       :  INVERSE     64          // TEXT_ATTRIBUTES inverse text (auto reset)
000374  000578  //       :  UNDERLINED  128         // TEXT_ATTRIBUTES underlined text (auto reset)
000375  000579  //       : Allows a combination of text attributes to be defined together
000376  000580  //       : by 'or'ing the bits together.
000377  000581  //       : Example: txt_Set(TEXT_ATTRIBUTES, BOLD | INVERSE); // bold + inverse
000378  000582  //       : The feature automatically resets after printing
000379  000583  //       : using putstr or print has completed.
000380  000584  //       : Bits 0-3 and 8-15 are reserved for future attributes.
000381  000585  //       :
000382  000586  //       : mode = TEXT_WRAP (mode 14)
000383  000587  //       : txt_Set(TEXT_WRAP , value);
000384  000588  //       : Sets the position where text wrap will occur
000385  000589  //       : The feature automatically resets when screen
000386  000590  //       : mode is changed. If the value is set to 0,
000387  000591  //       : text wrap is turned off.
000388  000592  //       : of the current screen. Default value is 0
000389  000593  // Notes : The value is in pixel units.
000390  000594  //       :
000391  000595        
000392  000596  //       : txt_Set mode 15 reserved for future use
000393  000597  //       :
000394  000598        
000395  000599        
000396  000600        
000397  000601  //=====================================================//
000398  000602  // Single parameter short-cuts                         //
000399  000603  // for the txt_Set functions                           //
000400  000604  // These functions return the existing value before    //
000401  000605  // the change is made.                                 //
000402  000606  //=====================================================//
000403  000607  func txt_FGcolour("colour"), 1;             // 0  text foreground colour
000404  000608  func txt_BGcolour("colour"), 1;             // 1  text background colour
000405  000609  func txt_FontID("id"), 1;                   // 2  text font ID (0 = system font)
000406  000610  func txt_Width("multiplier"), 1;            // 3  text width multiplier
000407  000611  func txt_Height("multiplier"), 1;           // 4  text height multiplier
000408  000612  func txt_Xgap("pixelcount"), 1;             // 5  text gap between characters
000409  000613  func txt_Ygap("pixelcount"), 1;             // 6  text gap between lines
000410  000614  func txt_Delay("millisecs"), 1;             // 7  text printing delay factor
000411  000615  func txt_Opacity("mode"), 1;                // 8  text OPAQUE or TRANSPARENT
000412  000616  func txt_Bold("mode"), 1;                   // 9  text bold ON/OFF
000413  000617  func txt_Italic("mode"), 1;                 // 10 text italic ON/OFF
000414  000618  func txt_Inverse("mode"), 1;                // 11 text inverse ON/OFF
000415  000619  func txt_Underline("mode"), 1;              // 12 text underline ON/OFF
000416  000620  func txt_Attributes("value"), 1;            // 13 text combined bold|italic|inverse|underline
000417  000621  func txt_Wrap("value"), 1;                  // 14 text set text wrap position
000418  000622  func _1F(), 0;                              // 15 text (reserved DO NOT REMOVE)
000419  000623        
000420  000624        
000421  000625  //------------------------------------------------------------------//
000422  000626  //                 Hardware Function Prototypes
000423  000627  //------------------------------------------------------------------//
000424  000628        
000425  000629  // I/O Pin reference:-
000426  000630  //
000427  000631  //    IO1_PIN           is pin 2 of J1
000428  000632  //    IO2_PIN           is pin 1 of J1
000429  000633  //    IO3_PIN           is pin 3 of J1
000430  000634  //    IO4_PIN           is pin 5 of J1 (also used for BUS_RD)
000431  000635  //    IO5_PIN           is pin 9 of J2 (also used for BUS_WR)
000432  000636  //    BUS_RD_PIN        is pin 5 of J1 (alias IO4_PIN)
000433  000637  //    BUS_WR_PIN        is pin 9 of J2 (alias IO5_PIN)
000434  000638  //    BUS_0             is pin 27 of J1
000435  000639  //    BUS_1             is pin 25 of J1
000436  000640  //    BUS_2             is pin 23 of J1
000437  000641  //    BUS_3             is pin 21 of J1
000438  000642  //    BUS_4             is pin 19 of J1
000439  000643  //    BUS_5             is pin 17 of J1
000440  000644  //    BUS_6             is pin 13 of J2
000441  000645  //    BUS_7             is pin 11 of J2
000442  000646  //    BACKLITE          is backlite control pin
000443  000647  //    AUDIO_ENABLE      is amplifier chip control pin
000444  000648        
000445  000649  func pin_Set("mode", "pin"), 1;            // set pin to required mode
000446  000650  // Syntax: pin_Set(mode, pin);
000447  000651  // Usage : pin_Set(arg1, arg2);
000448  000652  // Notes : Sets the appropriate pins to Inputs or Outputs
000449  000653  //       : returns true if the pin number is legal (usually ignored)
000450  000654  //       :
000451  000655  //       : mode = 0 : Set Pin to Output
000452  000656  //       : pin_Set(0, pin);
000453  000657  //       : pin_Set(OUTPUT, pin);
000454  000658  //       : pin = 1  : set IO1_PIN to output (pin 2 J1)
000455  000659  //       : pin = 2  : set IO2_PIN to output (pin 1 J1)
000456  000660  //       : pin = 3  : set IO3_PIN to output (pin 3 J1)
000457  000661  //       : pin = 4  : set IO4_PIN to output (pin 5 J1, also used for BUS_RD)
000458  000662  //       : pin = 5  : set IO5_PIN to output (pin 9 J2, also used for BUS_WR)
000459  000663  //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
000460  000664  //       : pin = 8  : set BUS_0   to output (pin 27 of J1)
000461  000665  //       : pin = 9  : set BUS_1   to output (pin 25 of J1)
000462  000666  //       : pin = 10 : set BUS_2   to output (pin 23 of J1)
000463  000667  //       : pin = 11 : set BUS_3   to output (pin 21 of J1)
000464  000668  //       : pin = 12 : set BUS_4   to output (pin 19 of J1)
000465  000669  //       : pin = 13 : set BUS_5   to output (pin 17 of J1)
000466  000670  //       : pin = 14 : set BUS_6   to output (pin 13 of J2)
000467  000671  //       : pin = 15 : set BUS_7   to output (pin 11 of J2)
000468  000672  //       : Sets the desired pin to be used as an Output.
000469  000673  //       :
000470  000674  //       : mode = 1 : Set Pin to Input
000471  000675  //       : pin_Set(1, pin);
000472  000676  //       : pin_Set(INPUT, pin);
000473  000677  //       : pin = 1  : set IO1_PIN to input (pin 2 J1)
000474  000678  //       : pin = 2  : set IO2_PIN to input (pin 1 J1)
000475  000679  //       : pin = 3  : set IO3_PIN to input (pin 3 J1)
000476  000680  //       : pin = 4  : set IO4_PIN to input (pin 5 J1, also used for BUS_RD)
000477  000681  //       : pin = 5  : set IO5_PIN to input (pin 9 J2, also used for BUS_WR)
000478  000682  //       : (pin 6,7 are BACKLITE and AMP control and are permanemtly outputs which can't be altered)
000479  000683  //       : pin = 8  : set BUS_0   to input (pin 27 of J1)
000480  000684  //       : pin = 9  : set BUS_1   to input (pin 25 of J1)
000481  000685  //       : pin = 10 : set BUS_2   to input (pin 23 of J1)
000482  000686  //       : pin = 11 : set BUS_3   to input (pin 21 of J1)
000483  000687  //       : pin = 12 : set BUS_4   to input (pin 19 of J1)
000484  000688  //       : pin = 13 : set BUS_5   to input (pin 17 of J1)
000485  000689  //       : pin = 14 : set BUS_6   to input (pin 13 of J2)
000486  000690  //       : pin = 15 : set BUS_7   to input (pin 11 of J2)
000487  000691  //       : Sets the desired pin to be used as an Input.
000488  000692        
000489  000693  func pin_HI("pin"), 1;                    // set pin to logic '1'
000490  000694  // Syntax: pin_HI(pin);
000491  000695  // Usage : pin_HI(arg);
000492  000696  // Notes : Outputs a logic "High" (3.3V) on the appropriate
000493  000697  //       : pin that was previously selected as an Output.
000494  000698  //       : returns true if the pin number is legal (usually ignored)
000495  000699  //       :
000496  000700  //       : pin = 1  : set IO1_PIN to "High" level (pin 2 of J1)
000497  000701  //       : pin = 2  : set IO2_PIN to "High" level (pin 1 of J1)
000498  000702  //       : pin = 3  : set IO3_PIN to "High" level (pin 3 of J1)
000499  000703  //       : pin = 4  : set IO4_PIN to "High" level (pin 5 of J1, also used for BUS_RD)
000500  000704  //       : pin = 5  : set IO5_PIN to "High" level (pin 9 of J2, also used for BUS_WR)
000501  000705  //       : pin = 6  : set DCENB pin to "High" level (BACKLITE ON)
000502  000706  //       : pin = 7  : set AUDIO_ENABL pin to "High" level (AMP OFF)
000503  000707  //       : pin = 8  : set BUS_0   to "High" level (pin 27 of J1)
000504  000708  //       : pin = 9  : set BUS_1   to "High" level (pin 25 of J1)
000505  000709  //       : pin = 10 : set BUS_2   to "High" level (pin 23 of J1)
000506  000710  //       : pin = 11 : set BUS_3   to "High" level (pin 21 of J1)
000507  000711  //       : pin = 12 : set BUS_4   to "High" level (pin 19 of J1)
000508  000712  //       : pin = 13 : set BUS_5   to "High" level (pin 17 of J1)
000509  000713  //       : pin = 14 : set BUS_6   to "High" level (pin 13 of J2)
000510  000714  //       : pin = 15 : set BUS_7   to "High" level (pin 11 of J2)
000511  000715        
000512  000716  func pin_LO("pin"), 1;                    // set pin to logic '0'
000513  000717  // Syntax: pin_LO(pin);
000514  000718  // Usage : pin_LO(arg);
000515  000719  // Notes : Outputs a logic "Low" (0V) on the appropriate
000516  000720  //       : pin that was previously selected as an Output.
000517  000721  //       : returns true if the pin number is legal (usually ignored)
000518  000722  //       :
000519  000723  //       : pin = 1 : set IO1_PIN to "Low" level (pin 2 of J1)
000520  000724  //       : pin = 2 : set IO2_PIN to "Low" level (pin 1 of J1)
000521  000725  //       : pin = 3 : set IO3_PIN to "Low" level (pin 3 of J1)
000522  000726  //       : pin = 4 : set IO4_PIN to "Low" level (pin 5 of J1, also used for BUS_RD)
000523  000727  //       : pin = 5 : set IO5_PIN to "Low" level (pin 9 of J2, also used for BUS_WR)
000524  000728  //       : pin = 6 : set DCENB pin to "Low" level (BACKLITE)
000525  000729  //       : pin = 7 : set AUDIO_ENABL pin to "Low" level (AMP ON)
000526  000730  //       : pin = 8  : set BUS_0  to "Low" level (pin 27 of J1)
000527  000731  //       : pin = 9  : set BUS_1  to "Low" level (pin 25 of J1)
000528  000732  //       : pin = 10 : set BUS_2  to "Low" level (pin 23 of J1)
000529  000733  //       : pin = 11 : set BUS_3  to "Low" level (pin 21 of J1)
000530  000734  //       : pin = 12 : set BUS_4  to "Low" level (pin 19 of J1)
000531  000735  //       : pin = 13 : set BUS_5  to "Low" level (pin 17 of J1)
000532  000736  //       : pin = 14 : set BUS_6  to "Low" level (pin 13 of J2)
000533  000737  //       : pin = 15 : set BUS_7  to "Low" level (pin 11 of J2)
000534  000738        
000535  000739  func pin_Read("pin"), 1;                // read pin, logic or analogue
000536  000740  // Syntax: pin_Read(pin);
000537  000741  // Usage : arg1 := pin_Read(arg2);
000538  000742  // Notes : Reads the logic state of the appropriate
000539  000743  //       : pin that was previously selected as an Input.
000540  000744  //       :
000541  000745  //       : pin = 1  : Read the state of IO1_PIN (pin 2 of J1)
000542  000746  //       : pin = 2  : Read the state of IO2_PIN (pin 1 of J1)
000543  000747  //       : pin = 3  : Read the state of IO3_PIN (pin 3 of J1)
000544  000748  //       : pin = 4  : Read the state of IO4_PIN (pin 5 of J1, also used for BUS_RD)
000545  000749  //       : pin = 5  : Read the state of IO5_PIN (pin 9 of J2, also used for BUS_WR)
000546  000750  //       : pin = 6  : Read the state of DCENB pin to "Low" level (BACKLITE)
000547  000751  //       : pin = 7  : Read the state of AUDIO_ENABL pin to "Low" level (AMP ON)
000548  000752  //       : pin = 8  : Read the state of BUS_0   (pin 27 of J1)
000549  000753  //       : pin = 9  : Read the state of BUS_1   (pin 25 of J1)
000550  000754  //       : pin = 10 : Read the state of BUS_2   (pin 23 of J1)
000551  000755  //       : pin = 11 : Read the state of BUS_3   (pin 21 of J1)
000552  000756  //       : pin = 12 : Read the state of BUS_4   (pin 19 of J1)
000553  000757  //       : pin = 13 : Read the state of BUS_5   (pin 17 of J1)
000554  000758  //       : pin = 14 : Read the state of BUS_6   (pin 13 of J2)
000555  000759  //       : pin = 15 : Read the state of BUS_7   (pin 11 of J2)
000556  000760  //       : Returns a 0 (logic low) or 1 (logic high).
000557  000761        
000558  000762        
000559  000763  //------------------------------------------------------------------//
000560  000764  //                 P1 module BUS I/O control
000561  000765  //------------------------------------------------------------------//
000562  000766        
000563  000767  func bus_In(), 1;
000564  000768  // Syntax: bus_In();
000565  000769  // Usage : arg1 := bus_In();
000566  000770  // Notes : Read the 8bit wide bus into the lower 8 bits of arg1.
000567  000771  //       : The upper 8 bits of arg1 are set to 0.
000568  000772  //       : the BUS_RD and BUS_WR pins are not affected.
000569  000773  //       :
000570  000774  //       : BUS_0 is pin 27 of J1
000571  000775  //       : BUS_1 is pin 25 of J1
000572  000776  //       : BUS_2 is pin 23 of J1
000573  000777  //       : BUS_3 is pin 21 of J1
000574  000778  //       : BUS_4 is pin 19 of J1
000575  000779  //       : BUS_5 is pin 17 of J1
000576  000780  //       : BUS_6 is pin 13 of J2
000577  000781  //       : BUS_7 is pin 11 of J2
000578  000782        
000579  000783  func bus_Out("var"), 0;
000580  000784  // Syntax: bus_Out(var);
000581  000785  // Usage : bus_Out(arg1);
000582  000786  // Notes : The lower 8 bits of arg1 are placed on the 8bit wide bus.
000583  000787  //       : The upper 8 bits of arg1 are ignored.
000584  000788  //       : the BUS_RD and BUS_WR pins are not affected.
000585  000789  //       : NB:- any BUS pins that are set to inputs are not affected.
000586  000790  //       :
000587  000791  //       : BUS_0 is pin 27 of J1
000588  000792  //       : BUS_1 is pin 25 of J1
000589  000793  //       : BUS_2 is pin 23 of J1
000590  000794  //       : BUS_3 is pin 21 of J1
000591  000795  //       : BUS_4 is pin 19 of J1
000592  000796  //       : BUS_5 is pin 17 of J1
000593  000797  //       : BUS_6 is pin 13 of J2
000594  000798  //       : BUS_7 is pin 11 of J2
000595  000799        
000596  000800  func bus_Set("var"), 0;
000597  000801  // Syntax: bus_Set(var);
000598  000802  // Usage : bus_Set(arg1);
000599  000803  // Notes : The lower 8 bits of arg1 are placed in the BUS direction register.
000600  000804  //       : a '1' sets a pin to be an input, a '0' sets a pin to be output.
000601  000805  //       : The upper 8 bits of arg1 are ignored.
000602  000806  //       : the BUS_RD and BUS_WR pins are not affected.
000603  000807  //       :
000604  000808  //       : BUS_0 is pin 27 of J1
000605  000809  //       : BUS_1 is pin 25 of J1
000606  000810  //       : BUS_2 is pin 23 of J1
000607  000811  //       : BUS_3 is pin 21 of J1
000608  000812  //       : BUS_4 is pin 19 of J1
000609  000813  //       : BUS_5 is pin 17 of J1
000610  000814  //       : BUS_6 is pin 13 of J2
000611  000815  //       : BUS_7 is pin 11 of J2
000612  000816        
000613  000817  func bus_Write("var"), 0;
000614  000818  // Syntax: bus_Write(var);
000615  000819  // Usage : bus_Write(arg1);
000616  000820  // Notes : The lower 8 bits of arg1 are placed on the BUS, then, after
000617  000821  //       : a settling delay of approx 50nsec, the BUS_WR pin is strobed
000618  000822  //       : LO for approx 50nsec then set back HI.
000619  000823  //       : The upper 8 bits of arg1 are ignored.
000620  000824  //       : NB:- the BUS_WR pin is automatically pre-set to an output to
000621  000825  //       : ensure BUS write integrity.
000622  000826  //       :
000623  000827  //       : BUS_0 is pin 27 of J1
000624  000828  //       : BUS_1 is pin 25 of J1
000625  000829  //       : BUS_2 is pin 23 of J1
000626  000830  //       : BUS_3 is pin 21 of J1
000627  000831  //       : BUS_4 is pin 19 of J1
000628  000832  //       : BUS_5 is pin 17 of J1
000629  000833  //       : BUS_6 is pin 13 of J2
000630  000834  //       : BUS_7 is pin 11 of J2
000631  000835        
000632  000836  func bus_Read(), 1;
000633  000837  // Syntax: bus_Read();
000634  000838  // Usage : arg1 := bus_Read();
000635  000839  // Notes : The BUS_RD pin set to LO, then, after a settling delay
000636  000840  //       : of approx 50nsec, the BUS is read into the lower 8 bits of arg
000637  000841  //       : (the upper 8 bits being set to 0)
000638  000842  //       : the BUS_RD pin is then set back to a HI level.
000639  000843  //       : NB:- the BUS_RD pin is automatically pre-set to an output to
000640  000844  //       : ensure BUS write integrity.
000641  000845  //       :
000642  000846  //       : BUS_0 is pin 27 of J1
000643  000847  //       : BUS_1 is pin 25 of J1
000644  000848  //       : BUS_2 is pin 23 of J1
000645  000849  //       : BUS_3 is pin 21 of J1
000646  000850  //       : BUS_4 is pin 19 of J1
000647  000851  //       : BUS_5 is pin 17 of J1
000648  000852  //       : BUS_6 is pin 13 of J2
000649  000853  //       : BUS_7 is pin 11 of J2
000650  000854        
000651  000855        
000652  000856  //------------------------------------------------------------------//
000653  000857  //   Graphics Functions
000654  000858  //------------------------------------------------------------------//
000655  000859  func gfx_Set("mode", "value"), 0;            // set various graphics functions
000656  000860  // Syntax: gfx_Set(mode, value);
000657  000861  // Usage : gfx_Set(arg1, arg2);
000658  000862  // Notes : Sets various graphics parameters used by other functions
000659  000863  //       : This allows the features to be set programatically with a
000660  000864  //       : single function call.It is strongly recommended to use the
000661  000865  //       : pre-defined constants rather than the mode numbers.
000662  000866  //       : NB:- Although it is often required to be able to set graphics
000663  000867  //       : functions with a single function call for graphics engine
000664  000868  //       : related functions, there is a complete set of single parameter
000665  000869  //       : shortcut functions that have exactly the same function as
000666  000870  //       : each of the gfx_Set modes and saves 1 parameter / uses less memory
000667  000871  //       :
000668  000872  //       : mode = PEN_SIZE (mode 16)
000669  000873  //       : gfx_Set(PEN_SIZE, value);
000670  000874  //       : value = SOLID (value 0) rectangle and circle objects are solid
000671  000875  //       : value = OUTLINE (value 1) rectangle and circle objects are outlines
000672  000876  //       : Sets the mode of the Pen used by most graphics objects
000673  000877  //       :
000674  000878  //       : mode = BACKGROUND_COLOUR (mode 17)
000675  000879  //       : gfx_Set(BACKGROUND_COLOUR, value);
000676  000880  //       : value = 0 to 0xFFFF, Black to White
000677  000881  //       : Sets the Background colour of the screen
000678  000882  //       :
000679  000883  //       : mode = OBJECT_COLOUR (mode 18)
000680  000884  //       : gfx_Set(OBJECT_COLOUR, value);
000681  000885  //       : value = 0 to 0xFFFF, Black to White
000682  000886  //       : Sets the Object colour used in various functions
000683  000887  //       : LineTo(,,); LineRel(,,); BoxTo(,,); Dot(); etc.
000684  000888  //       :
000685  000889  //       : mode = CLIPPING (mode 19)
000686  000890  //       : gfx_Set(CLIPPING, value);
000687  000891  //       : value = OFF (value 0) Clipping disabled
000688  000892  //       : value = ON (value 1) Clipping enabled
000689  000893  //       : Enables/Disables the Clipping feature
000690  000894  //       :
000691  000895  //       : mode = TRANSPARENT_COLOUR (mode 20) : Image or Animation Transparency Colour.
000692  000896  //       : gfx_Set(TRANSPARENT_COLOUR, value);
000693  000897  //       : value = 0 to 0xFFFF Black to White
000694  000898  //       : Sets Bitmap, Image or Animation Transparency Colour.
000695  000899  //       : NB not implemented
000696  000900  //       :
000697  000901  //       : mode = TRANSPARENCY (mode 21) : Bitmap/Image/Animation Transparency
000698  000902  //       : gfx_Set(5, value);
000699  000903  //       : value = OFF (value 0) Transparency disabled
000700  000904  //       : value = ON (value 1) Transparency enabled
000701  000905  //       : Enables/Disables the Transparency feature
000702  000906  //       : NB not implemented
000703  000907  //       :
000704  000908  //       : mode = FRAME_DELAY (mode 22) : Inter-Frame Delay
000705  000909  //       : gfx_Set(FRAME_DELAY, value);
000706  000910  //       : value = 0 to 65535 ms
000707  000911  //       : Sets the Video/Animation clip inter-frame delay. This setting will
000708  000912  //       : over-ride the embedded frame delay of the clip. After the event,
000709  000913  //       : the setting will auto disable and if further inter-frame delays need
000710  000914  //       : overriding the setting must be re-issued.
000711  000915  //       :
000712  000916  //       : mode = SCREEN_MODE (mode 23) : Set required screen behaviour
000713  000917  //       : gfx_Set(SCREEN_MODE, value);
000714  000918  //       : value = LANDSCAPE   (value 0)
000715  000919  //       : value = LANDSCAPE_R (value 1)
000716  000920  //       : value = PORTRAIT    (value 2)
000717  000921  //       : value = PORTRAIT_R  (value 3)
000718  000922  //       :
000719  000923  //       : mode = OUTLINE_COLOUR (mode 24) : Outline Colour
000720  000924  //       : gfx_Set(OUTLINE_COLOUR, value);
000721  000925  //       : value = 1 to 0xFFFF, if 0, featre is OFF
000722  000926  //       : Sets the filled Rectangle or Circle objects outline colour
000723  000927  //       : If outline colour, is 0, OUTLINE_COLOUR feature is disabled
000724  000928  //       : gfx_Set(OUTLINE_COLOUR, OFF); may be used for this
000725  000929  //       :
000726  000930  //       : Only supports variable contrast for uOLED Modules
000727  000931  //       : mode = CONTRAST (mode 25) : Contrast
000728  000932  //       : gfx_Set(CONTRAST, value);
000729  000933  //       : value = 0 to 9, 0=off, 1=lowest, 8=highest contrast
000730  000934  //       : when contrast=0, display is placed in low power mode.
000731  000935  //       : This function should be called with contrast=0 when
000732  000936  //       : powering down the module.
000733  000937  //       :
000734  000938  //       : mode = LINE_PATTERN (mode 26) : Line Pattern
000735  000939  //       : gfx_Set(LINE_PATTERN, value);
000736  000940  //       : gfx_Set(LINE_PATTERN, 0b1111000011110000); // draw dotted line
000737  000941  //       : gfx_Set(LINE_PATTERN, OFF); // line patterning OFF
000738  000942  //       : a value of 0 turns the feature off
000739  000943  //       :
000740  000944  //       : mode = COLOUR_MODE (mode 27) : 8/16 bit colour mode
000741  000945  //       : gfx_Set(COLOUR_MODE , COLOUR16);   // set 16bit colour mode
000742  000946  //       : gfx_Set(COLOUR_MODE , COLOUR8);   // set 8bit colour mode
000743  000947  //       : NB not implemented, default is COLOUR16
000744  000948  //       :
000745  000949  //       : mode = BEVEL_WIDTH (mode 28) : set button and slider bevel width
000746  000950  //       : gfx_Set(BEVEL_WIDTH , 5);   // set bevel lines to 5 pixels wide
000747  000951  //       : sets the button and slider objects bevel width
000748  000952  //       :
000749  000953  //       : mode = BEVEL_SHADOW (mode 29) : set bevel shadowing depth for buttons and sliders
000750  000954  //       : gfx_Set(BEVEL_SHADOW , 5);
000751  000955  //       : sets the button and slider objects darken and lighten depth for the bevel colour
000752  000956  //       :
000753  000957  //       : mode = X_ORIGIN (mode 29) : set x offset for screen
000754  000958  //       : gfx_Set(X_ORIGIN , 25);  // object are offset 25 pixels from LHS
000755  000959  //       : sets the origin of drawn objects to a position other than 0,0
000756  000960  //       :
000757  000961  //       : mode = Y_ORIGIN (mode 29) : set y offset for screen
000758  000962  //       : gfx_Set(Y_ORIGIN , 30);  // object are offset 30 pixels from TOP
000759  000963  //       : sets the origin of drawn objects to a position other than 0,0
000760  000964        
000761  000965        
000762  000966  func gfx_Cls(), 0;                    // clear the screen
000763  000967  // Syntax: gfx_Cls();
000764  000968  // Usage : gfx_Cls();
000765  000969  // Notes : Clears the screen with current background colour
000766  000970        
000767  000971  func gfx_MoveTo("x", "y"), 0;                // set glb_X1 and glb_Y1 to required co-ordinate
000768  000972  // Syntax: gfx_MoveTo(x, y);
000769  000973  // Usage : gfx_MoveTo(arg1, arg2);
000770  000974  // Notes : Moves the origin to a new x,y position
000771  000975        
000772  000976  func gfx_MoveRel("x", "y"), 0;                // set glb_X1 and glb_Y1 to new relative offset
000773  000977  // Syntax: gfx_MoveRel(x, y);
000774  000978  // Usage : gfx_MoveRel(arg1, arg2);
000775  000979  // Notes : Moves the origin to a new x,y position
000776  000980  //       : relative to the current origing
000777  000981        
000778  000982  func gfx_LineTo("x1", "y1"), 0;                     // draw line from current origin to new point
000779  000983  // Syntax: gfx_LineTo(x1, y1);
000780  000984  // Usage : gfx_LineTo(arg1, arg2);
000781  000985  // Notes : Draws a Line from the origin x,y to x1,y1.
000782  000986  //       : The new origin is then set to x1, y1. Line colour needs
000783  000987  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000784  000988        
000785  000989  func gfx_LineRel("x1", "y1"), 0;                    // draw line from current origin to new relative offset
000786  000990  // Syntax: gfx_LineRel(x1, y1);
000787  000991  // Usage : gfx_LineRel(arg1, arg2);
000788  000992  // Notes : Draws a Line from the origin x,y to x1,y1.
000789  000993  //       : Unlike gfx_MoveTo() the origin is not updated with x1, y1. Line colour needs
000790  000994  //       : to be preset with "Set Object colour" using gfx_Set(OBJECT_COLOUR, colour);
000791  000995        
000792  000996  func gfx_Line("x1", "y1", "x2", "y2", "colr"), 0;   // draw line, can be patterned
000793  000997  // Syntax: gfx_Line(x1, x2, y2, colr);
000794  000998  // Usage : gfx_Line(arg1, arg2, arg3, arg4, arg5);
000795  000999  // Notes : Plots a coloured Line from x1,y1 to x2,y2 on the screen
000796  001000        
000797  001001  func gfx_Hline("y", "x1", "x2", "colr"), 1;         // draw Hline, can be patterned
000798  001002  // Syntax: gfx_Line(x1, x2, y, colr);
000799  001003  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000800  001004  // Notes : Plots a coloured Horizontal line from x1,y to x2,y on the screen
000801  001005        
000802  001006  func gfx_Vline("x", "y1", "y2", "colr"), 1;         // draw Vline, can be patterned
000803  001007  // Syntax: gfx_Line(y1, y2, x, colr);
000804  001008  // Usage : gfx_Line(arg1, arg2, arg3, arg4);
000805  001009  // Notes : Plots a coloured Vertical line from x,y1 to x,y2 on the screen
000806  001010        
000807  001011  func gfx_Rectangle("x1" ,"y1", "x2", "y2", "colr"), 0;    // draw open rectangle,line can be patterned
000808  001012  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colr);
000809  001013  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000810  001014  // Notes : Plots a coloured Outline Rectangle from top corner (x1,y1) to
000811  001015  //       : bottom corner (x2,y2) on the screen.
000812  001016        
000813  001017  func gfx_RectangleFilled("x1","y1","x2","y2","colr"), 0;    // draw filled rectangle
000814  001018  // Syntax: gfx_Rectangle(x1, y1, x2, y2, colour);
000815  001019  // Usage : gfx_Rectangle(arg1, arg2, arg3, arg4, arg5);
000816  001020  // Notes : Plots a coloured Solid Rectangle from top corner (x1,y1) to
000817  001021  //       : bottom corner (x2,y2) on the screen.
000818  001022        
000819  001023  func gfx_Circle("x", "y", "rad", "colr"), 0;        // draw open circle
000820  001024  // Syntax: gfx_Circle(x, y, rad, colr);
000821  001025  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000822  001026  // Notes : Plots a coloured outline Circle on the screen at centre x,y with radius = rad
000823  001027        
000824  001028  func gfx_CircleFilled("x", "y", "rad", "colr"), 0;    // draw filled circle
000825  001029  // Syntax: gfx_Circle(x, y, rad, colr);
000826  001030  // Usage : gfx_Circle(arg1, arg2, arg3, arg4);
000827  001031  // Notes : Plots a coloured Solid Circle on the screen at centre x,y with radius = rad
000828  001032        
000829  001033  func gfx_PutPixel("x", "y", "colr"), 0;            // set point at x y
000830  001034  // Syntax: gfx_PutPixel(x, y, colr);
000831  001035  // Usage : gfx_PutPixel(arg1, arg2, arg3);
000832  001036  // Notes : Plots a coloured pixel on the screen at x,y location
000833  001037        
000834  001038  func gfx_GetPixel("x", "y"), 1;                // read colour at point x y
000835  001039  // Syntax: gfx_GetPixel(x, y);
000836  001040  // Usage : var := gfx_GetPixel(arg1, arg2);
000837  001041  // Notes : Reads and returns the colour value of a pixel at location x,y
000838  001042        
000839  001043  func gfx_Triangle("x1","y1","x2","y2","x3","y3","colr"), 0; // draw an open triangle
000840  001044  // Syntax: gfx_Triangle(x1, y1, x2, y2, x3, y3, colr);
000841  001045  // Usage : gfx_Triangle(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000842  001046  // Notes : Plots a coloured outline Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000843  001047  //       : Vertices must be specified in an anti-clockwise fashion
000844  001048        
000845  001049  func gfx_OrbitInit("&x_orb", "&y_orb"), 0;        // set result holders for orbit command
000846  001050  // Syntax: gfx_OrbitInit(&x_orb, &y_orb);
000847  001051  // Usage : gfx_OrbitInit(&arg1, &arg2);
000848  001052  // Notes : Sets up the Orbit function parameters.
000849  001053  //       : &x_orb, &y_orb: calcualted Orbit coordiantes. These are pointers to local
000850  001054  //       : variables that get updated after calling gfx_Orbit(,,) function.
000851  001055  //       : The coordiantaes are calculated relative to the origin
000852  001056  //       : obtained by using the gfx_MoveTo(x, y) function.
000853  001057        
000854  001058  func gfx_Orbit("angle", "distance"), 0;            // calculate point at angle, distance
000855  001059  // Syntax: gfx_Orbit(angle, distance);
000856  001060  // Usage : gfx_Orbit(arg1, arg2);
000857  001061  // Notes : The Orbit function calcualtes the x, y coordinates of a distant point whose
000858  001062  //       : only known parameters are the angle and the distance from the current origin.
000859  001063        
000860  001064  func gfx_Polyline("n", "&vx", "&vy", "colr"), 0;    // draw a polyline from a table of vertices
000861  001065  // Syntax: gfx_Polyline(numbVertices, &vertices_x, &vertices_y, colour);
000862  001066  // Usage : gfx_Polyline(arg1, x[array], y[array], arg2);
000863  001067  // Notes : This function is very similar to the Ploygon function
000864  001068  //       : with the exception of the 1st and the last vertices not joined.
000865  001069        
000866  001070  func gfx_Polygon("n", "&vx", "&vy", "colr"), 0;        // draw a polygon from a table of vertices
000867  001071  // Syntax: gfx_Polygon(numbVertices, &vx, &y, colour);
000868  001072  // Usage : gfx_Polygon(arg1, x[array], y[array], arg2);
000869  001073  // Notes : Plots a coloured outline Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
000870  001074  //       : Vertices must be minimum of 3 and can be specified in any fashion
000871  001075        
000872  001076  func gfx_Dot(), 0;                    // set point at glb_X glb_Y, default colour
000873  001077  // Syntax: gfx_Dot();
000874  001078  // Usage : gfx_Dot();
000875  001079  // Notes : Places a coloured dot at the origin
000876  001080        
000877  001081        
000878  001082  func gfx_Bullet("r"), 0;                // draw circle at glb_X glb_Y, default colour
000879  001083  // Syntax: gfx_Bullet();
000880  001084  // Usage : gfx_Bullet();
000881  001085  // Notes : Places a coloured circle at the origin
000882  001086  //       : filled or unfilled state is controlled by PenSize
000883  001087        
000884  001088  func gfx_IncX(), 1;                    // increment global origin glb_X, returning new value
000885  001089  // Syntax: gfx_IncX();
000886  001090  // Usage : var := gfx_IncX();
000887  001091  // Notes : Increments the x coordinate of the origin
000888  001092        
000889  001093  func gfx_IncY(), 1;                    // increment global origin glb_Y, returning new value
000890  001094  // Syntax: gfx_IncY();
000891  001095  // Usage : var := gfx_IncY();
000892  001096  // Notes : Increments the y coordinate of the origin
000893  001097        
000894  001098  func gfx_BoxTo("x1", "y1"), 0;                // draw rectangle from current origin to x1 y1
000895  001099  // Syntax: gfx_BoxTo(x1, y1);
000896  001100  // Usage : gfx_BoxTo(arg1, arg2);
000897  001101  // Notes : Draws a Rectangle from the origin x,y to x1,y1.
000898  001102  //       : The new origin is then set to x1,y1. Rectangle colour needs
000899  001103  //       : to be preset with "Set Object colour" using gfx_Set(mode=2, colour);
000900  001104  //       : and the PenSize setting determines if Box is solid or outline.
000901  001105        
000902  001106  func gfx_ClipWindow("x1" ,"y1", "x2", "y2"), 0;         // set the cipping area
000903  001107  // Syntax: gfx_ClipWindow(x1, y1, x2, y2);
000904  001108  // Usage : gfx_ClipWindow(arg1, arg2, arg3, arg4);
000905  001109  // Notes : Specifies a clipping window region on the screen such that any objects
000906  001110  //       : and text placed onto the screen will be clipped and displayed only
000907  001111  //       : within that region. For the clipping window to take effect, "Clipping"
000908  001112  //       : must be enabled seperately using the gfx_Set(CLIPPING, ON) command.
000909  001113        
000910  001114        
000911  001115  func gfx_ChangeColour("oldcolr", "newcolr"), 0;         // change pixel colour in clipping area
000912  001116  // Syntax: gfx_ChangeColour(oldcolr, newcolr);
000913  001117  // Usage : gfx_ChangeColour(0xFF00, 0XFFFF);
000914  001118  // *Notes:
000915  001119        
000916  001120  func gfx_SetClipRegion(), 0;                            // set clipping area to the most recent extents
000917  001121  // Syntax: gfx_SetClipRegion();
000918  001122  // Usage : var := gfx_SetClipRegion();
000919  001123  // *Notes:
000920  001124        
000921  001125  func gfx_Ellipse("x", "y", "xrad", "yrad", "colour"), 0;
000922  001126  // Syntax: gfx_Ellipse(x, y, xrad, yrad, colour);
000923  001127  // Usage : gfx_Ellipse(arg1, arg2, arg3, arg4, arg5);
000924  001128  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000925  001129  //       : with xradius = xrad and yradius = yrad.
000926  001130  //       : if PenSize = 0 Ellipse is Solid
000927  001131  //       : if PenSize = 1 Ellipse is Outline
000928  001132        
000929  001133        
000930  001134  func gfx_EllipseFilled("x", "y", "xrad", "yrad", "colour"), 0;
000931  001135  // Syntax: gfx_EllipseFilled(x, y, xrad, yrad, colour);
000932  001136  // Usage : gfx_EllipseFilled(arg1, arg2, arg3, arg4, arg5);
000933  001137  // Notes : Plots a coloured Ellipse on the screen at centre x,y
000934  001138  //       : with xradius = xrad and yradius = yrad.
000935  001139        
000936  001140  func gfx_Button("state", "x", "y", "buttonColour", "textColour", "font", "textWidth", "textHeight", "text"), 0;
000937  001141  // Syntax: gfx_Button(mode, x, y, buttonColour, textColour, font, textWidth, textHeight, text);
000938  001142  // Usage : gfx_Button(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
000939  001143  // Notes : Draws a 3 dimensional Text Button at screen location defined by
000940  001144  //       : x,y arguments (top left corner). The size of the button depends on
000941  001145  //       : the font, width, height and length of the text.
000942  001146  //       : The button appearance will depend on the state parameter setting:
000943  001147  //       :         state = 0 : Button Pressed
000944  001148  //       :         state = 1 : Button Raised
000945  001149        
000946  001150  func gfx_Panel("state", "x", "y", "width", "height", "colour"), 0;
000947  001151  // Syntax: gfx_Panel("style", "x", "y", "width", "height", "colour"), 0;
000948  001152  // Usage : gfx_Panel(PANEL_RAISED, x, y, w, h, GRAY);
000949  001153  // Notes : Draws a panel (groupbox) at screen location defined by
000950  001154  //       : x, y, width and height with colour "colour".
000951  001155  //       :         state = 0 : recessed
000952  001156  //       :         state = 1 : raised
000953  001157        
000954  001158  func gfx_Slider("mode", "x1", "y1", "x2", "y2", "colour", "scale", "value"), 1;
000955  001159  // Syntax: gfx_Slider(mode, x1, y1, x2, y2, colour, scale, value);
000956  001160  // Usage : gfx_Slider(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
000957  001161  // Notes : Draws a 3 dimensional Slider Bar on the screen.
000958  001162  //       : Slider parameters are as follows:
000959  001163  //       :         mode = 0 : Slider recessed
000960  001164  //       :         mode = 1 : Slider raised
000961  001165  //       :         x1, y1 = top left corner
000962  001166  //       :         x2, y2 = bottom right corner
000963  001167  //       :         scale = n : sets the full scale range from 0 to n
000964  001168  //       :         value = m : sets the relative position of the thumb 0 <= m <= n
000965  001169  //       : returns:-
000966  001170        
000967  001171        
000968  001172  func gfx_ScreenCopyPaste("xs", "ys", "xd", "yd", "width", "height"), 0;
000969  001173  // Syntax: gfx_ScreenCopyPaste(xs, ys, xd, yd, width, height);
000970  001174  // Usage : gfx_ScreenCopyPaste(arg1, arg2, arg3, arg4, arg5, arg6);
000971  001175  // Notes : Copies an area of a screen from xs,ys of size given by width and height
000972  001176  //       : and pastes it to another location determined by xd, yd.
000973  001177        
000974  001178  func gfx_RGBto565("RED", "GREEN", "BLUE"), 1;
000975  001179  // Syntax: gfx_RGBto565(red, green, blue);
000976  001180  // Usage : gfx_RGBto565(arg1, arg2, arg3);
000977  001181  // Notes : Returns the 16bit (565 format) colour value of a 24bit (R,G,B format) colour
000978  001182        
000979  001183  func gfx_332to565("COLOUR8BIT"), 1;
000980  001184  // Syntax: gfx_332to565(colour);
000981  001185  // Usage : gfx_332to565(arg);
000982  001186  // Notes : Returns the 16bit (565 format) colour value of an 8 bit (332 format) colour
000983  001187        
000984  001188  func gfx_Selection("index", "backcolor", "textcolor"), 0;
000985  001189  // Syntax: gfx_Selection("index", "backcolor", "textcolor"), 0;
000986  001190  // Usage : gfx_Selection(1, RED, YELLOW);
000987  001191  // Notes : Called prior to drawing a button, this function
000988  001192  //       : hilites the required text line on a multiline button.
000989  001193        
000990  001194  func gfx_TriangleFilled("x1","y1","x2","y2","x3","y3","colr"), 0; // draw a filled triangle
000991  001195  // Syntax: gfx_TriangleFilled(x1, y1, x2, y2, x3, y3, colr);
000992  001196  // Usage : gfx_TriangleFilled(arg1, arg2, arg3, arg4, arg5, arg6, arg7);
000993  001197  // Notes : Plots a coloured Solid Triangle from between 3 vertices: x1,y1 x2,y2 x3,y3
000994  001198  //       : Vertices must be specified in an anti-clockwise fashion
000995  001199        
000996  001200        
000997  001201  func gfx_PolygonFilled("n", "&vx", "&vy", "colr"), 0;        // draw a filled polygon from a table of vertices
000998  001202  // Syntax: gfx_PolygonFilled(numbVertices, &vx, &y, colour);
000999  001203  // Usage : gfx_PolygonFilled(arg1, x[array], y[array], arg2);
001000  001204  // Notes : Plots a solid Polygon between specified vertices: x1,y1 x2,y2 .. xn,yn
001001  001205  //       : Vertices must be minimum of 3 and can be specified in any fashion
001002  001206        
001003  001207        
001004  001208  func gfx_Origin("x", "y"), 0;            // set relative screen offset for graphics objects
001005  001209  // Syntax: gfx_Offset(x, y);
001006  001210  // Usage : gfx_Offset(arg1, arg2);
001007  001211  // Notes : Set the screen offset
001008  001212        
001009  001213        
001010  001214        
001011  001215  func gfx_Get("mode"), 1;
001012  001216  // Syntax: gfx_Get(mode);
001013  001217  // Usage : arg1 := gfx_Get(arg);
001014  001218  // Notes : Returns various parameters to caller
001015  001219  //       :
001016  001220  //       : mode = X_MAX (mode 0) : current orientations maximum X value
001017  001221  //       : var := gfx_Get(X_MAX);
001018  001222  //       : Returns the maximum horizontal value of the display
001019  001223  //       :
001020  001224  //       : mode = Y_MAX (mode 1) : Vcurrent orientations maximum Y value
001021  001225  //       : var := gfx_Get(Y_MAX);
001022  001226  //       : Returns the maximum vertical value of the display
001023  001227  //       :
001024  001228  //       : mode = LEFT_POS (mode 2) : Left location of last Object
001025  001229  //       : var := gfx_Get(LEFT_POS);
001026  001230  //       : Returns the left location of the last drawn object
001027  001231  //       : such as a slider or button or an image/video
001028  001232  //       :
001029  001233  //       : mode = TOP_POS (mode 3) : Top location of Object
001030  001234  //       : var := gfx_Get(TOP_POS);
001031  001235  //       : Returns the top location of the last drawn object
001032  001236  //       : such as a slider or button or an image/video
001033  001237  //       :
001034  001238  //       : mode = RIGHT_POS (mode 4) : Right location of last Object
001035  001239  //       : var := gfx_Get(RIGHT_POS);
001036  001240  //       : Returns the right location of the last drawn object
001037  001241  //       : such as a slider or button or an image/video
001038  001242  //       :
001039  001243  //       : mode = BOTTOM_POS  (mode 5) : Bottom location of Object
001040  001244  //       : var := gfx_Get(BOTTOM_POS );
001041  001245  //       : Returns the bottom location of the last drawn object
001042  001246  //       : such as a slider or button or an image/video
001043  001247  //       :
001044  001248        
001045  001249        
001046  001250  //==================================================//
001047  001251  // Single parameter short-cuts                      //
001048  001252  // for the gfx_Set functions                        //
001049  001253  // These functions return the existing value before //
001050  001254  // the change is made.                              //
001051  001255  //==================================================//
001052  001256  func gfx_PenSize("mode"), 1;                        // 0  graphics pen size, SOLD or OUTLINE
001053  001257  func gfx_BGcolour("colour"), 1;                     // 1  graphics background colour
001054  001258  func gfx_ObjectColour("colour"), 1;                 // 2  graphics object colour
001055  001259  func gfx_Clipping("mode"), 0;                       // 3  graphics clipping ON/OFF
001056  001260  func gfx_TransparentColour("colour"), 1;            // 4  graphics image transparent mask colour
001057  001261  func gfx_Transparency("mode"), 1;                   // 5  graphics image transparent mode ON/OFF
001058  001262  func gfx_FrameDelay("milliseconds"), 1;             // 6  graphics animation frame delay
001059  001263  func gfx_ScreenMode("mode"), 1;                     // 7  graphics orientation LANDSCAPE, LANDSCAPE_R, PORTRAIT, PORTRAIT_R
001060  001264  func gfx_OutlineColour("colour"), 1;                // 8  graphics rectangle/circle outline colour
001061  001265  func gfx_Contrast("value"), 1;                      // 9  graphics hardware value 0 to 9, 0=off, 1=lowest, 8=highest (only for AMOLED devices)
001062  001266  func gfx_LinePattern("value"), 1;                   // 10 graphics line draw tesselation pattern (16 linear bits, 1=pixel off)
001063  001267  func gfx_ColourMode("mode"), 1;                     // 11 graphics colour mode COLOUR8 or COLOUR16 (default colour 16)
001064  001268  func gfx_BevelWidth("mode"), 1;                     // 12 graphics button bevel width
001065  001269  func gfx_BevelShadow("value"), 1;                   // 13 graphics button bevel shadow depth
001066  001270  func gfx_Xorigin("offset"), 1;                      // 14 graphics  X origin
001067  001271  func gfx_Yorigin("offset"), 1;                      // 15 graphics  Y origin
001068  001272        
001069  001273        
001070  001274  //==================================================//
001071  001275  // uSD/FLASH Function Prototypes                    //
001072  001276  //==================================================//
001073  001277  func media_Video("x", "y"), 0;                      // display movie at position x y
001074  001278  // Syntax: media_Video(x, y);
001075  001279  // Usage : media_Video(arg1, arg2);
001076  001280  // Notes : Play a Video/Animation clip from the uSD card at screen location
001077  001281  //       : specified by x,y (top left corner). The location of the clip in the
001078  001282  //       : uSD card must be specified by media_setSector(Video_Sector_Add) function.
001079  001283        
001080  001284  func media_VideoFrame("x", "y","framenumber"), 0;   // display required frame from a movie at x y
001081  001285  // Syntax: media_VideoFrame(Frame_number);
001082  001286  // Usage : arg1 := media_VideoFrame();
001083  001287  // Notes : After a pointer to a valid video has been set with media_SetSector,
001084  001288  //       : calling this function shows each fram sequentially, returning
001085  001289  //       : the number of frames remaining. The position of the image is
001086  001290  //     : at the current origin as set with gfx_MoveTo(...);
001087  001291        
001088  001292  func media_SetAdd("HiWord", "LoWord"), 0;           // set stream byte address
001089  001293  // Syntax: media_SetAdd(AddHiWord, AddLoWord);
001090  001294  // Usage : media_SetAdd(arg1, arg2);
001091  001295  // Notes : Set uSD internal Address pointer for bytewise access
001092  001296        
001093  001297  func media_SetSector("HiWord", "LoWord"), 0;        // set stream sector address
001094  001298  // Syntax: media_SetSector(SectHiWord, SectLoWord);
001095  001299  // Usage : media_SetSector(arg1, arg2);
001096  001300  // Notes : Set uSD internal Sector pointer for sector block access
001097  001301        
001098  001302  func media_RdSector("*destination"), 1;
001099  001303  // Syntax: media_RdSector(*destination);
001100  001304  // Usage : media_RdSector(rdblock);
001101  001305  // Notes : Reads and Returns 512 bytes (256 words) into a destination
001102  001306  //       : block (eg rdblock[256]) pointed to by the internal Sector pointer.
001103  001307  //       : After the read the Sector pointer is automatically incremented by 1.
001104  001308  //       : Returns TRUE if uSD response was TRUE
001105  001309        
001106  001310  func media_WrSector("*source"), 1;
001107  001311  // Syntax: media_WrSector(*source);
001108  001312  // Usage : media_WrSector(wrblock);
001109  001313  // Notes : Writes 512 bytes (256 words) from a source memory block
001110  001314  //       : (eg wrblock[256]) into the uSD card. After the write the Sector
001111  001315  //       : pointer is automatically incremented by 1.
001112  001316  //       : Returns TRUE if uSD response was TRUE
001113  001317        
001114  001318  func media_ReadByte(), 1;                // read a byte at the current stream position
001115  001319  // Syntax: media_RdByte();
001116  001320  // Usage : var := media_RdByte();
001117  001321  // Notes : Reads and Returns a single byte of data from the
001118  001322  //       : uSD card pointed to by the internal Address pointer.
001119  001323  //       : After the read the Address pointer is automatically
001120  001324  //       : incremented by 1.
001121  001325        
001122  001326  func media_ReadWord(), 1;                // read a word at the current stream position
001123  001327  // Syntax: media_ReadWord();
001124  001328  // Usage : var := media_ReadWord();
001125  001329  // *Notes : Reads and Returns a single word of data from the
001126  001330  //       : uSD card pointed to by the internal Address pointer.
001127  001331  //       : After the read the Address pointer is automatically
001128  001332  //       : incremented by 2.
001129  001333        
001130  001334  func media_WriteByte("byte"), 1;              // write a byte to the current stream position
001131  001335  // Syntax: media_WriteByte(arg1);
001132  001336  // Usage : var := media_WriteByte(arg1);
001133  001337  // *Notes : Writes and Returns xxxxx
001134  001338  //       : After the write the Address pointer is automatically
001135  001339  //       : incremented by 1.
001136  001340        
001137  001341  func media_WriteWord("word"), 1;            // write a word to the current stream position
001138  001342  // Syntax: media_WriteWord(arg1);
001139  001343  // Usage : var := media_WriteWord(arg1);
001140  001344  // *Notes : Writes and Returns xxxxx
001141  001345  //       : After the write the Address pointer is automatically
001142  001346  //       : incremented by 2.
001143  001347        
001144  001348  func media_Image("x", "y"), 0;            // display image at position x y
001145  001349  // Syntax: media_Image(x, y);
001146  001350  // Usage : media_Image(arg1, arg2);
001147  001351  // Notes : Display an image from the uSD card at screen location
001148  001352  //       : specified by x,y (top left corner). The location of the
001149  001353  //       : Image in the uSD card must be specified by
001150  001354  //       : media_setSector(Image_Sector_Add) function.
001151  001355        
001152  001356  func media_Flush(), 1;                    // after writing to media, flush the sector and write
001153  001357  // Syntax: media_Flush();
001154  001358  // Usage : var := media_Flush();
001155  001359  // *Notes : After writing any data to a sector, media_Flush() should be called to ensure that the current sector that
001156  001360  //       : is being written is correctly stored back to the media else write operations may be unpredictable.
001157  001361        
001158  001362  func media_Init(), 1;                    // initialize uSD card
001159  001363  // Usage : media_Init();
001160  001364  // Notes : Initialise uSD CARD
001161  001365  //       : Response: 0 = No Card
001162  001366  //       :           1 = Card Initialised
001163  001367        
001164  001368        
001165  001369  //==============================================//
001166  001370  // Communications Function Prototypes           //
001167  001371  //==============================================//
001168  001372  func com_Init("buf","bufsize","qualifier"), 0;  // set up a interrupt driven ring buffer for comms
001169  001373  // Syntax: com_Init(buffer, bufsize, qualifier);
001170  001374  // Usage1: com_Init(mybuf, 20, 0);
001171  001375  // Usage2: com_Init(mybuf, 20, ':');
001172  001376  // Notes : initialize a serial capture buffer for the comms input
001173  001377  //       : The program must declare a var array as a circular buffer.
001174  001378  //       : Usage1 declares a circular buffer which will continually
001175  001379  //       : buffer characters.
001176  001380  //       : Usage2 must receive ':' before any characters will
001177  001381  //       : accumulate in the buffer.
001178  001382        
001179  001383  func com_Reset(), 0;                 // reset the comms receiver
001180  001384  // Syntax: com_Reset();
001181  001385  // Usage : com_Reset();
001182  001386  // Notes : reset comms to default polled mode
001183  001387        
001184  001388  func com_Count(), 1;                // return count of characters in receive buffer
001185  001389  // Syntax: com_Count();
001186  001390  // Usage : arg := com_Count();
001187  001391  // Notes : return count of buffered characters in buffer attachment
001188  001392        
001189  001393  func com_Full(), 1;                // return TRUE if receiver buffer filled to capcity
001190  001394  // Syntax: com_Full();
001191  001395  // Usage : if (com_Full() ,,,, go read buffer;
001192  001396  // Notes : return true if buffer full (not necessarily an error if
001193  001397  //       : buffer is sized to a packet size)
001194  001398        
001195  001399  func com_Error(), 1;                // return comms errors comms error occurred
001196  001400  // Syntax: com_Error();
001197  001401  // Usage : if (com_Error() ) ...... take recovery action;
001198  001402  // Notes : return non zero if any errors low level comms errors occured
001199  001403  // returns :
001200  001404  // bit0 = Receiver Overflow Error
001201  001405  // bit1 = Receiver Framing Error
001202  001406  // bit2 = Transmit Buffer Overflow
001203  001407        
001204  001408  func com_Sync(), 1;                // returns TRUE if qualifier has been received
001205  001409  // Syntax: com_Sync();
001206  001410  // Usage : com_Sync();
001207  001411  // return true if sync character has been received in com_Init("...") mode
001208  001412        
001209  001413        
001210  001414  func com_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001211  001415  // Syntax: com_TXbuffer("buf", "bufsize", "pin");
001212  001416  // Usage : com_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001213  001417  // Usage : com_TXbuffer(0, 0, 0);              // revert to non buffered service
001214  001418  // Notes : initialize a serial buffer for the COM0 output.
001215  001419  //       : The program must declare a var array as a circular buffer.
001216  001420  //       : When a TX buffer is declared for comms, the transmission
001217  001421  //       : of characters becomes non blocking. The only time
001218  001422  //       : blocking will occur is if the buffer has insufficient space
001219  001423  //       : to accept the next character, in which case the function
001220  001424  //       : will wait for buffer space to become available. If the
001221  001425  //       : TX buffer is no longer required, just set the buffer pointer
001222  001426  //       : to zero, the size in this case doesnt matter and is ignored.
001223  001427  //       : The function can resize or reallocated to another buffer at
001224  001428  //       : any time. The buffer is flushed before any changes are made.
001225  001429  //       : "pin" designates an IO pin to control a bi-directional 
001226  001430  //       : control device for half duplex mode. "pin" will go HI at the
001227  001431  //       : start of a transmission, and will return low after the final
001228  001432  //       : byte is transmitted. If not required, just set "pin" to zero.
001229  001433        
001230  001434        
001231  001435  func com_TXcount(), 1;                // return count of characters in COM0 TX buffer
001232  001436  // Syntax: com_TXcount();
001233  001437  // Usage : arg := com_Count();
001234  001438  // Notes : return count of characters remaining in COM0 transmit buffer
001235  001439  //       : that was previously allocated with com_TXbuffer(...);
001236  001440        
001237  001441        
001238  001442  func com_TXemptyEvent("function"), 1;  // sets a function to be called when COM0 TX buffer empty
001239  001443  // Syntax: com_TXemptyEvent(function);
001240  001444  // Usage : arg := com_TXemptyEvent();
001241  001445  // Notes : If a comms TX buffer that was previously allocated with
001242  001446  //       : com_TXbuffer(...);, this function can be used to set up
001243  001447  //       : a function to be called when the COM0 TX buffer is empty.
001244  001448  //       : This is useful for either reloading the TX buffer, setting
001245  001449  //       : or clearing a pin to change the direction of eg a RS485
001246  001450  //       : line driver, or any other form of traffic control.
001247  001451  //       : The event function must not have any parameters.
001248  001452  //       : To disable the event, simply call com_TXemptyEvent(0).
001249  001453  //       : com_TXbuffer(...); also resets any active event.
001250  001454  //       : com_TXemptyEvent returns any previous event function
001251  001455  //       : address, or zero if there was no previous function.
001252  001456        
001253  001457        
001254  001458  func com_TXbufferHold("state"), 1; // hold or release a com_TXbuffer
001255  001459  // Usage : arg := com_TXbufferHold(ON);  // hold the buffer while we fill it
001256  001460  // Usage : arg := com_TXbufferHold(OFF);  // start sending the buffer
001257  001461  // Notes : Expecting that a comms TX buffer that was previously allocated with
001258  001462  //       : com_TXbuffer(...);, com_TXbufferHold(ON) can be used to stop
001259  001463  //       : the buffer being sent wile it is being loaded. Mormally, when
001260  001464  //       : using buffered comms, the transmit process will begin
001261  001465  //       : immediately. This is often undesirable for 2 reasons,
001262  001466  //       : 1] you may wish to build a packet then send it later
001263  001467  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001264  001468  //       : as the FIFO buffer is constantly trying to empty while
001265  001469  //       : you are busy tring to fill it.
001266  001470  // return -1 if function is called illegally when TX comms is not buffered.
001267  001471  // return buffer count when called with argument of 1, eg com_TXbufferHold(ON)
001268  001472  // return 0 when argument is zero, eg com_TXbufferHold(OFF)
001269  001473        
001270  001474        
001271  001475  //=============================================================//
001272  001476  // Auxilliary Communications Function Prototypes
001273  001477  //=============================================================//
001274  001478  func com1_Init("buffer", "bufsize", "qualifier"), 0;
001275  001479  // Syntax: com_Init(buffer, bufsize, qualifier);
001276  001480  // Usage1: com_Init(mybuf, 20, 0);
001277  001481  // Usage2: com_Init(mybuf, 20, ':');
001278  001482  // Notes : initialize a serial capture buffer for the comms input
001279  001483  //       : The program must declare a var array as a circular buffer.
001280  001484  //       : Usage1 declares a circular buffer which will continually
001281  001485  //       : buffer characters.
001282  001486  //       : Usage2 must receive ':' before any characters will
001283  001487  //       : accumulate in the buffer.
001284  001488        
001285  001489  func com1_Reset(), 0;
001286  001490  // Syntax: com_Reset();
001287  001491  // Usage : com_Reset();
001288  001492  // Notes : reset comms receiver to default polled mode
001289  001493        
001290  001494  func com1_Count(), 1;
001291  001495  // Syntax: com_Count();
001292  001496  // Usage : arg := com_Count();
001293  001497  // Notes : return count of characters in receive buffer
001294  001498        
001295  001499  func com1_Full(), 1;
001296  001500  // Syntax: com_Full();
001297  001501  // Usage : if (com_Full() ,,,, go read buffer;
001298  001502  // Notes : return true if receive buffer full
001299  001503        
001300  001504  func com1_Error(), 1;
001301  001505  // Syntax: com_Error();
001302  001506  // Usage : if (com_Error() ) ...... take recovery action;
001303  001507  // Notes : return non zero if any level comms errors occured
001304  001508  // returns :
001305  001509  // bit0 = Receiver Overflow Error
001306  001510  // bit1 = Receiver Framing Error
001307  001511  // bit2 = Transmit Buffer Overflow
001308  001512        
001309  001513  func com1_Sync(), 1;
001310  001514  // Syntax: com_Sync();
001311  001515  // Usage : com_Sync();
001312  001516  // Notes : return true if sync character has been received in com_Init("...") mode
001313  001517        
001314  001518        
001315  001519  func com1_TXbuffer("buf", "bufsize", "pin"), 0;    // sets the buffer location for buffered transmission
001316  001520  // Syntax: com1_TXbuffer("buf", "bufsize", "pin");
001317  001521  // Usage : com1_TXbuffer(mybuf, 1024, IO1_PIN);    // set the TX buffer, usin IO1_PIN for turnaround
001318  001522  // Usage : com1_TXbuffer(0, 0, 0);              // revert to non buffered service
001319  001523  // Notes : initialize a serial buffer for the COM1 output.
001320  001524  //       : The program must declare a var array as a circular buffer.
001321  001525  //       : When a TX buffer is declared for comms, the transmission
001322  001526  //       : of characters becomes non blocking. The only time
001323  001527  //       : blocking will occur is if the buffer has insufficient space
001324  001528  //       : to accept the next character, in which case the function
001325  001529  //       : will wait for buffer space to become available. If the
001326  001530  //       : TX buffer is no longer required, just set the buffer pointer
001327  001531  //       : to zero, the size in this case doesnt matter and is ignored.
001328  001532  //       : The function can resize or reallocated to another buffer at
001329  001533  //       : any time. The buffer is flushed before any changes are made.
001330  001534  //       : "pin" designates an IO pin to control a bi-directional 
001331  001535  //       : control device for half duplex mode. "pin" will go HI at the
001332  001536  //       : start of a transmission, and will return low after the final
001333  001537  //       : byte is transmitted. If not required, just set "pin" to zero.
001334  001538        
001335  001539        
001336  001540  func com1_TXcount(), 1;                // return count of characters in COM1 TX buffer
001337  001541  // Syntax: com1_TXcount();
001338  001542  // Usage : arg := com1_Count();
001339  001543  // Notes : return count of characters remaining in COM1 transmit buffer
001340  001544  //       : that was previously allocated with com1_TXbuffer(...);
001341  001545        
001342  001546        
001343  001547  func com1_TXemptyEvent("function"), 1;  // sets a function to be called when COM1 TX buffer empty
001344  001548  // Syntax: com1_TXemptyEvent(function);
001345  001549  // Usage : arg := com1_TXemptyEvent();
001346  001550  // Notes : If a comms TX buffer that was previously allocated with
001347  001551  //       : com1_TXbuffer(...);, this function can be used to set up
001348  001552  //       : a function to be called when the COM1 TX buffer is empty.
001349  001553  //       : This is useful for either reloading the TX buffer, setting
001350  001554  //       : or clearing a pin to change the direction of eg a RS485
001351  001555  //       : line driver, or any other form of traffic control.
001352  001556  //       : The event function must not have any parameters.
001353  001557  //       : To disable the event, simply call com1_TXemptyEvent(0).
001354  001558  //       : com1_TXbuffer(...); also resets any active event.
001355  001559  //       : com1_TXemptyEvent returns any previous event function
001356  001560  //       : address, or zero if there was no previous function.
001357  001561        
001358  001562        
001359  001563  func com1_TXbufferHold("state"), 1; // hold or release a com1_TXbuffer
001360  001564  // Usage : arg := com1_TXbufferHold(ON);  // hold the buffer while we fill it
001361  001565  // Usage : arg := com1_TXbufferHold(OFF);  // start sending the buffer
001362  001566  // Notes : Expecting that a comms TX buffer that was previously allocated with
001363  001567  //       : com1_TXbuffer(...);, com1_TXbufferHold(ON) can be used to stop
001364  001568  //       : the buffer being sent wile it is being loaded. Mormally, when
001365  001569  //       : using buffered comms, the transmit process will begin
001366  001570  //       : immediately. This is often undesirable for 2 reasons,
001367  001571  //       : 1] you may wish to build a packet then send it later
001368  001572  //       : 2] when using com_TXemptyEvent erroneous empty events will occur
001369  001573  //       : as the FIFO buffer is constantly trying to empty while
001370  001574  //       : you are busy tring to fill it.
001371  001575  // return -1 if function is called illegally when TX comms is not buffered.
001372  001576  // return buffer count when called with argument of 1, eg com1_TXbufferHold(ON)
001373  001577  // return 0 when argument is zero, eg com1_TXbufferHold(OFF)
001374  001578        
001375  001579  func serin1(), 1;
001376  001580  // Syntax: serin1();
001377  001581  // Usage : char := serin1();
001378  001582  // Notes : return the next available character from COM1
001379  001583        
001380  001584  func serout1("char"), 0;
001381  001585  // Syntax: serout1("char");
001382  001586  // Usage : serout1(ch);
001383  001587  // Notes : send character to COM1
001384  001588        
001385  001589  func com_SetBaud("comport","baudrate/10"), 1;
001386  001590  // Syntax: com_SetBaud("comport","baudrate/10");
001387  001591  // Usage : com_SetBaud(COM1, 960);   // set COM1 to 9600 baud
001388  001592  // Notes : sets to any viable baud rate from 160 to 655350
001389  001593  // return true if baud rate was acceptable
001390  001594        
001391  001595        
001392  001596        
001393  001597  //==============================================//
001394  001598  // Display Access                               //
001395  001599  //==============================================//
001396  001600  func disp_Init(), 0;                            // initialize display with required tables
001397  001601  // Syntax: disp_Init();
001398  001602  // Usage : disp_Init();
001399  001603  // Notes : Initialises or reinitialises the display.
001400  001604  //       : Normally used after restoration of peripheral power
001401  001605  //       : and after DeepSleep.
001402  001606        
001403  001607  func disp_SetReg("register", "data"), 0;
001404  001608  // Syntax: display_SetReg(register, data);
001405  001609  // Usage : display_SetReg(arg1, arg2);
001406  001610  // Notes : Sets uLCD specific display driver registers. Refer
001407  001611  //       : to appropriate display driver data sheet.
001408  001612        
001409  001613  func disp_setGRAM("x1","y1","x2","y2"), 0;    // set GRAM window
001410  001614  // Syntax: disp_setGRAM(x1, y1, x2, y2);
001411  001615  // Usage : disp_setGRAM(arg1, arg2, arg3, arg4);
001412  001616  // Notes : Prepares the GRAM area for user access.
001413  001617  //       : Data can now be written with disp_GRAM.
001414  001618  //       : GRAM will be set accordingly for the correct screen mode.
001415  001619  //       : the LO word of the 32 bit pixel count is returned. This is
001416  001620  //       : usually all that is needed unlse GRAM area exceeds 256^2
001417  001621  //       : A copy of the 32bit value can be found in
001418  001622  //       : GRAM_PIXEL_COUNT_LO and GRAM_PIXEL_COUNT_HI
001419  001623        
001420  001624  func disp_WrGRAM("colour"), 0;
001421  001625  // Syntax: display_WrGRAM(colour);
001422  001626  // Usage : display_WrGRAM(arg);
001423  001627  // Notes : Data can be written to the GRAM consecutively using
001424  001628  //       : this function once the GRAM access window has been setup.
001425  001629        
001426  001630  func disp_WriteControl("value"), 0;             // write a control byte to the display
001427  001631  func disp_WriteWord("value"), 0;                // write a word to the display
001428  001632        
001429  001633        
001430  001634  func disp_ReadWord(), 1;                        // read a word from the display
001431  001635  // Syntax: disp_ReadWord();
001432  001636  // Usage : x:=disp_ReadWord();
001433  001637  // Notes : Read a word from the controller
001434  001638  // Eg:   : disp_WriteControl(0);         // select Ilitek ID register
001435  001639  //       : print(disp_ReadWord());        // print ID
001436  001640  //       : (Many displays are write only)
001437  001641        
001438  001642                                                  //
001439  001643  //==============================================//
001440  001644  // unadorned SPI functions                      //
001441  001645  //==============================================//
001442  001646  func spi_Init("speed","ip_mode","op_mode"), 0;  // set the SPI port, not used if uSD active
001443  001647  func spi_Read(), 1;                             // read a raw byte from SPI (lowers CS)
001444  001648  func spi_Write("byte"), 0;                      // write a raw byte to SPI (lowers CS)
001445  001649  func spi_Disable(), 0;                          // disable SPI reading or writing (raise CS)
001446  001650                                                  //
001447  001651  //==============================================//
001448  001652  // flash device specific functions              //
001449  001653  //==============================================//
001450  001654  func flash_SIG(), 1;                            // read Jedecsignature from SPI Flash device
001451  001655  func flash_ID(), 1;                             // read ID code from FLASH device
001452  001656  func flash_BulkErase(), 0;                      // erase the entire FLASH device
001453  001657  func flash_BlockErase("block"), 1;              // erase the required 64k flash block
001454  001658                                                  //
001455  001659                                                  //
001456  001660  //==============================================//
001457  001661  // string and character size function           //
001458  001662  //==============================================//
001459  001663  func charwidth("char"), 1;                      // return width of a character in pixel units
001460  001664  func charheight("char"), 1;                     // return height of a character in pixel units
001461  001665  func strwidth("pointer"), 1;                    // return width of a string in pixel units
001462  001666  func strheight(), 1;                            // return height of a string in pixel units
001463  001667        
001464  001668        
001465  001669  //------------------------------------------------------------------//
001466  001670  //        I2C Function Prototypes
001467  001671  //------------------------------------------------------------------//
001468  001672  func I2C_Open("speed"), 0;
001469  001673  // Syntax: I2C_Open(speed),
001470  001674  // Usage : I2C_Open(I2C_MED);
001471  001675  // Notes : configures the I2C module
001472  001676  //       : speed can be I2C_SLOW, I2C_MED, I2C_FAST (100khz, 400khz, 1mhz)
001473  001677        
001474  001678  func I2C_Close(), 0;
001475  001679  // Syntax: I2C_Close();
001476  001680  // Usage : I2C_Close();
001477  001681  // Notes : disables the I2C1 module.
001478  001682        
001479  001683  func I2C_Start(), 1;
001480  001684  // Syntax: I2C_Start();
001481  001685  // Usage : I2C_Start();
001482  001686  // Notes : generates a Start condition.
001483  001687  //       : returns true if successful (usually ignored)
001484  001688        
001485  001689  func I2C_Stop(), 1;
001486  001690  // Syntax: I2C_Stop();
001487  001691  // Usage : I2C_Stop();
001488  001692  // Notes : generates a Stop condition.
001489  001693  //       : returns true if successful (usually ignored)
001490  001694        
001491  001695  func I2C_Restart(), 1;
001492  001696  // Syntax: I2C_Restart();
001493  001697  // Usage : I2C_Restart();
001494  001698  // Notes : generates a Restart condition.
001495  001699  //       : returns true if successful (usually ignored)
001496  001700        
001497  001701  func I2C_Read(), 1;
001498  001702  // Syntax: I2C_Read();
001499  001703  // Usage : ch := I2C_Read();
001500  001704  // Notes : reads a single byte from the I2C Bus.
001501  001705        
001502  001706  func I2C_Write("byte"), 1;
001503  001707  // Syntax: I2C_Write(byte);
001504  001708  // Usage : r := I2C_Write(ch);
001505  001709  // Notes : is used to write a byte to the I2C bus.
001506  001710  //       : Returns 0 if failed, 1 if no ack, 2 if ack
001507  001711        
001508  001712  func I2C_Ack(), 0;
001509  001713  // Syntax: I2C_Ack();
001510  001714  // Usage : I2C_Ack();
001511  001715  // Notes : generates the acknowledge condition.
001512  001716        
001513  001717  func I2C_Nack(), 0;
001514  001718  // Syntax: I2C_Nack();
001515  001719  // Usage : I2C_Nack();
001516  001720  // Notes : generates the negative acknowledge condition.
001517  001721        
001518  001722  func I2C_AckStatus(), 0;
001519  001723  // Syntax: I2C_AckStatus();
001520  001724  // Usage : r := I2C_AckStatus();
001521  001725  // Notes : returns the ACK status from the device.
001522  001726        
001523  001727  func I2C_AckPoll("control"), 1;
001524  001728  // Syntax: I2C_AckPoll();
001525  001729  // Usage : r := I2C_AckPoll(0xA0);
001526  001730  // Notes : waits for a device to return from ACK polling.
001527  001731        
001528  001732  func I2C_Idle(), 0;
001529  001733  // Syntax: I2C_Idle();
001530  001734  // Usage : I2C_Idle();
001531  001735  // Notes : waits until the I2C Bus is Inactive.
001532  001736        
001533  001737  func I2C_Gets("buffer", "size"), 1;
001534  001738  // Syntax: I2C_Gets("buffer", "size");
001535  001739  // Usage : r := I2C_Gets(mybuf, 16);
001536  001740  // Notes : only reads up to "size" characters into "buffer"
001537  001741  //       : Reads up to asciiz terminator including terminator
001538  001742        
001539  001743  func I2C_Getn("buffer", "size"), 1;
001540  001744  // Syntax: I2C_Gets("buffer", "size");
001541  001745  // Usage : r := I2C_Gets(mybuf, 16);
001542  001746  // Notes : reads "size" bytes into "buffer"
001543  001747  //       :
001544  001748        
001545  001749  func I2C_Puts("buffer"), 1;
001546  001750  // Syntax: I2C_Puts("buffer");
001547  001751  // Usage : r := I2C_Puts(mybuf);
001548  001752  // Notes : writes an asciiz string to the I2C device
001549  001753  //       : returns count of characters written
001550  001754        
001551  001755  func I2C_Putn("buffer", "count"), 1;
001552  001756  // Syntax: I2C_Putn("buffer","count");
001553  001757  // Usage : r := I2C_Puts(mybuf,10);
001554  001758  // Notes : writes up to "size" bytes to the I2C device
001555  001759  //       : returns number of bytes written
001556  001760        
001557  001761        
001558  001762  //------------------------------------------------------------------//
001559  001763  //        Image Control Function Prototypes
001560  001764  //------------------------------------------------------------------//
001561  001765  func img_SetPosition("handle", "index", "xpos", "ypos"), 1;
001562  001766  // Syntax: img_SetPosition(handle, index, xpos, ypos);
001563  001767  // Usage : r := img_SetPosition(hImageList, imagenum, x, y);
001564  001768  // Notes : set the position where the image will be displayed
001565  001769  //       : returns true if index was ok and function was successful.
001566  001770  //       : you may turn off an image so when img_Refresh is called,
001567  001771  //       : the image will not be shown
001568  001772        
001569  001773  func img_Enable("handle", "index"), 1;
001570  001774  // Syntax: img_Enable(handle, index);
001571  001775  // Usage : r := img_Enable(hImageList, imagenum);
001572  001776  // Notes : enable image in a image list
001573  001777  //       : returns true if index was ok and function was successful.
001574  001778  //       : this is the default state so when img_Refresh is called,
001575  001779  //       : all the images in the list will be shown
001576  001780  //       : if index is set to -1, all of the images are enabled
001577  001781        
001578  001782  func img_Disable("handle", "index"), 1;
001579  001783  // Syntax: img_Disable(handle, index);
001580  001784  // Usage : r := img_Disable(hImageList, imagenum);
001581  001785  // Notes : disable image in a image list
001582  001786  //       : returns true if index was ok and function was successful.
001583  001787  //       : you must turn off an image so when img_Refresh is called,
001584  001788  //       : the image will not be shown.
001585  001789  //       : if index is set to -1, all of the images are disabled
001586  001790        
001587  001791        
001588  001792  func img_Darken("handle", "index"), 1;
001589  001793  // Syntax: img_Darken(handle, index);
001590  001794  // Usage : r := img_Darken(hImageList, imagenum);
001591  001795  // Notes : darken image in a image list
001592  001796  //       : returns true if index was ok and function was successful.
001593  001797  //       : if index is set to -1, all of the images are darkened
001594  001798  //       : NB:- this feature will only work for the next refresh, then
001595  001799  //       : the image reverts back to normal when displayed again.
001596  001800        
001597  001801        
001598  001802  func img_Lighten("handle", "index"), 1;
001599  001803  // Syntax: img_Lighten(handle, index);
001600  001804  // Usage : r := img_Lighten(hImageList, imagenum);
001601  001805  // Notes : lighten image in a image list
001602  001806  //       : returns true if index was ok and function was successful.
001603  001807  //       : if index is set to -1, all of the images are lightened
001604  001808  //       : NB:- this feature will only work for the next refresh, then
001605  001809  //       : the image reverts back to normal when displayed again.
001606  001810        
001607  001811  func img_SetWord("handle", "index", "offset", "word"), 1;
001608  001812  // Syntax: img_SetWord(handle, index, offset, word);
001609  001813  // Usage : img_SetWord(hndl, 5, IMAGE_XPOS, 10);
001610  001814  // Notes : set specified word (0-7) in a image entry
001611  001815  //       : returns TRUE if successful, return value usually ignored.
001612  001816        
001613  001817  func img_GetWord("handle", "index", "offset"), 1;
001614  001818  // Syntax: myvar := img_GetWord("handle", "index", "offset");
001615  001819  // Usage : myvar := img_GetWord(hndl, 5, IMAGE_YPOS);
001616  001820  // Notes : returns specified word (0-14) from an image entry
001617  001821  //       : refer to image control entry offsets.
001618  001822        
001619  001823  func img_Show("handle", "index"), 1;
001620  001824  // Syntax: img_Show(handle, index);
001621  001825  // Usage : display image entry (regardless of enable/disable)
001622  001826  //       : returns TRUE if successful, return value usually ignored.
001623  001827        
001624  001828  func img_SetAttributes("handle", "index","value"), 1;
001625  001829  // Syntax: img_SetAttributes("handle", "index","offset");
001626  001830  // Usage : img_SetAttributes(hndl, 5, I_TOPMOST);
001627  001831  // Notes : This function SETS one or more bits in the IMAGE_FLAGS field
001628  001832  //       : of an image control entry. "value" refers to various bits in
001629  001833  //       : the image control entry (see image attribute flags).
001630  001834  //       : A '1' bit in the "value" field SETS the respective bit
001631  001835  //       : in the IMAGE_FLAGS field of the image control entry.
001632  001836  //       : returns TRUE if successful, return value usually ignored.
001633  001837        
001634  001838  func img_ClearAttributes("handle", "index","value"), 1;
001635  001839  // Syntax: img_ClearAttributes("handle", "index","offset");
001636  001840  // Usage : img_ClearAttributes(hndl, 5, I_TOPMOST);
001637  001841  // Notes : This function CLEARS one or more bits in the IMAGE_FLAGS field
001638  001842  //       : of an image control entry. "value" refers to various bits in
001639  001843  //       : the image control entry (see image attribute flags)
001640  001844  //       : a '1' bit in the "value" field CLEARS the respective bit
001641  001845  //       : in the IMAGE_FLAGS field of the image control entry.
001642  001846  //       : returns TRUE if successful, return value usually ignored.
001643  001847        
001644  001848  func img_Touched("handle", "index"), 1;
001645  001849  // Syntax: r := img_Touched(handle, index);
001646  001850  // Usage : img_Touched(hndl, 17);
001647  001851  //       : returns -1 if image not touched, or returns index
001648  001852  // Notes : if index is passed as -1, function tests all images,
001649  001853  //       : and returns -1 if image not touched, or returns index.
001650  001854        
001651  001855        
001652  001856        
001653  001857        
001654  001858  //------------------------------------------------------------------//
001655  001859  //        Timer Function Prototypes
001656  001860  //------------------------------------------------------------------//
001657  001861  func sys_T(), 1;
001658  001862  // Syntax: sys_T();
001659  001863  // Usage : t := sys_T();
001660  001864  // Notes : return the current value of the rolling system timer (1msec) LO word
001661  001865        
001662  001866  func sys_T_HI(), 1;
001663  001867  // Syntax: sys_T_HI();
001664  001868  // Usage : t := sys_T_HI();
001665  001869  // Notes : return the current value of the rolling system timer (1msec) HI word
001666  001870        
001667  001871  func sys_SetTimer("timernum","value"), 0;
001668  001872  // Syntax: sys_SetTimer("timernum", "value");
001669  001873  // Usage : sys_SetTimer(TIMER5, 10000);
001670  001874  // Notes : set a countdown on the selected timer, or 'top up' if required.
001671  001875  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001672  001876  //       : Maximum timeout period is 65.535 seconds
001673  001877  //       : A timer can be read with the sys_GetTimer("timernum") function
001674  001878        
001675  001879  func sys_GetTimer("timernum"), 1;
001676  001880  // Syntax: t := sys_GetTimer("timernum");
001677  001881  // Usage : t := sys_GetTimer(TIMER3);
001678  001882  // Notes : returns 0 if timer has expired, or the current countdown value.
001679  001883  //       : There ar 8 timers TIMER0 to TIMER7 which stop at the count of 0
001680  001884  //       : Maximum timeout period is 65.535 seconds
001681  001885  //       : A timer must be set with the sys_SetTimer("timernum","value") function
001682  001886        
001683  001887  func sys_SetTimerEvent("timernum","function"), 1;
001684  001888  // Syntax: sys_SetTimerFunction("timernum", "function");
001685  001889  // Usage : sys_SetTimer(TIMER5, myfunc);
001686  001890  // Notes : set a function to be called for selected timer.
001687  001891  //       : When the timer reaches zero, the function is called.
001688  001892  //       : The called function must not have any parameters
001689  001893  //       : sys_SetTimerEvent returns any previous event function
001690  001894  //       : address, or zero if there was no previous function.
001691  001895        
001692  001896  func sys_EventQueue(), 1;
001693  001897  // Syntax: sys_EventQueue();
001694  001898  // Usage : tasks := sys_EventQueue();
001695  001899  // Notes : returns the max number of events that were pending
001696  001900  //       : in the timer queue since the last call to this function.
001697  001901  //       : This can be used to assess timer event overhead burden,
001698  001902  //       : especially after or during a sys_EventsPostpone action.
001699  001903        
001700  001904  func sys_EventsPostpone(), 0;
001701  001905  // Syntax: sys_EventPostpone();
001702  001906  // Usage : sys_EventPostpone();   // postpone the event queue
001703  001907  // Notes : postpone any events until the sys_EventResume function is executed
001704  001908  //       : The timer event queue will continue to queue events, but no action
001705  001909  //       : will take place untill a sys_EventResume function is encountered.
001706  001910  //       : The queue will continue to receive up to 32 events before discarding
001707  001911  //       : any further events. This function is required to allow a sequence of
001708  001912  //       : instructions or functions to occur that would otherwise be corrupted
001709  001913  //       : by an event occuring during the sequence of instructions or functions.
001710  001914  //       : A good example of this is when you set a position to print, if there
001711  001915  //       : was no way of locking the current sequence, an event may occur which
001712  001916  //       : does a similar thing, and a contention would occur - printing to
001713  001917  //       : the wrong position. This function should be used wisely, if any action
001714  001918  //       : that is required would take considerable time, it is better to disable
001715  001919  //       : any conflicting event functions with a bypass flag, then restart the
001716  001920  //       : conflicting event by re-issuing a timer value.
001717  001921        
001718  001922  func sys_EventsResume(), 0;
001719  001923  // Syntax: sys_EventsResume();
001720  001924  // Usage : sys_EventsResume();   // resume the event queue
001721  001925  // Notes : resume any postponed events. The queue will try to execute any timer
001722  001926  //       : events that were incurred during the postponed period.
001723  001927        
001724  001928        
001725  001929  func sys_Sleep("units"), 1;
001726  001930  // Syntax: t := sys_Sleep("units");
001727  001931  // Usage : t := sys_Sleep(10);
001728  001932  // Notes : sets the display into low power mode for a period of time.
001729  001933  //       : Touching the touch screen will also wake from sleep.
001730  001934  //       : Returns remaining sleep units.
001731  001935        
001732  001936  func iterator("offset"), 0;
001733  001937  // Syntax: t :=  iterator("offset");
001734  001938  // Usage : t :=  iterator(10);
001735  001939  // Notes : set the iterator size for ++/--
001736  001940  //       : The next postinc,postdec,preinc of predec will alter
001737  001941  //       : by the specified value.
001738  001942  //       : The offset will return to 1 after the next operation.
001739  001943        
001740  001944        
001741  001945        
001742  001946        
001743  001947  //------------------------------------------------------------------//
001744  001948  //         Touch Screen Function Prototypes
001745  001949  //------------------------------------------------------------------//
001746  001950        
001747  001951  func touch_DetectRegion("x1" ,"y1", "x2", "y2"), 0;
001748  001952  // Syntax: touch_DetectRegion(x1, y1, x2, y2);
001749  001953  // Usage : touch_DetectRegion(arg1, arg2, arg3, arg4);
001750  001954  // Notes : Specifies a new touch detect region on the screen
001751  001955  //       : such that only touch activity in that region will
001752  001956  //       : be reported by the status poll touch_Get(TOUCH_STATUS);
001753  001957        
001754  001958  func touch_Set("mode"), 0;
001755  001959  // Syntax: touch_Set(mode);
001756  001960  // Usage : touch_Set(arg);
001757  001961  // Notes : Sets various Touch Screen related parameters
001758  001962  //       :
001759  001963  //       : mode = TOUCH_ENABLE (mode 0)  Enable Touch Screen
001760  001964  //       : touch_Set(TOUCH_ENABLE);
001761  001965  //       : Enables and initialises Touch Screen hardware
001762  001966  //       :
001763  001967  //       : mode = TOUCH_DISABLE (mode 1)  Disable Touch Screen
001764  001968  //       : touch_Set(TOUCH_DISABLE );
001765  001969  //       : Disables the Touch Screen
001766  001970  //       : Note: Touch Screen runs in the background and disabling
001767  001971  //       : it when not in use will free up extra resources
001768  001972  //       : such as 4DVM CPU cycles.
001769  001973  //       :
001770  001974  //       : mode = TOUCH_REGIONDEFAULT (mode 2)  Default Touch Region
001771  001975  //       : touch_Set(TOUCH_REGIONDEFAULT);
001772  001976  //       : This will reset the current active region to default
001773  001977  //       : to the full screen without the application having to
001774  001978  //       : set a new active region for the full screen.
001775  001979  //       : (NB for 'no touch' devices - like uVGAII or OLED's/LCD's
001776  001980  //       : that requre to be interfaced with an external pointing
001777  001981  //       : device, values that are poked into TOUCH_DRIVE will be
001778  001982  //       : read with the touch_Get() function)
001779  001983        
001780  001984        
001781  001985  func touch_Get("mode"), 1;
001782  001986  // Syntax: touch_Get(mode);
001783  001987  // Usage : arg1 := touch_Get(arg);
001784  001988  // Notes : Returns various Touch Screen parameters to caller
001785  001989  //       :
001786  001990  //       : mode = TOUCH_STATUS  (mode 0)
001787  001991  //       : var := touch_Get(TOUCH_STATUS);
001788  001992  //       : Returns the various states of the touch screen
001789  001993  //       : 0 = NOTOUCH
001790  001994  //       : 1 = TOUCH_PRESSED
001791  001995  //       : 2 = TOUCH_RELEASED
001792  001996  //       : 3 = TOUCH_MOVING
001793  001997  //       :
001794  001998  //       : mode = TOUCH_GETX   (mode 1)
001795  001999  //       : var := touch_Get(TOUCH_GETX);
001796  002000  //       : Returns the X coordinates of the touch
001797  002001  //       :
001798  002002  //       : mode = TOUCH_GETY   (mode 2)
001799  002003  //       : var := touch_Get(TOUCH_GETY);
001800  002004  //       : Returns the Y coordinates of the touch
001801  002005        
001802  002006  //------------------------------------------------------------------//
001803  002007  //        CTYPE Function Prototypes
001804  002008  //------------------------------------------------------------------//
001805  002009        
001806  002010  func isdigit("char"), 1;    //Returns a 1 if the character is an ascii digit else returns a 0
001807  002011  // Syntax: isdigit("char");
001808  002012  // Usage : Var := isdigit(ch);
001809  002013  // Notes : char specifies the ascii character for the test
001810  002014  //     : 0 : char is not an ascii digit.
001811  002015  //     : 1 : char is an ascii digit..
001812  002016  //     : Valid range is "0123456789"
001813  002017        
001814  002018  func isxdigit("char"), 1;    //Returns a 1 if the character is an ascii hexadecimal digit else returns a 0
001815  002019  // Syntax: isxdigit("char");
001816  002020  // Usage : Var := isxdigit(ch);
001817  002021  // Notes : char specifies the ascii character for the test
001818  002022  //     : 0 : char is not an ascii hexadecimal digit.
001819  002023  //     : 1 : char is an ascii hexadecimal digit..
001820  002024  //     : Valid range is "0123456789ABCDEF"
001821  002025        
001822  002026  func isupper("char"), 1;    //Returns a 1 if the character is an ascii upper case letter else returns a 0
001823  002027  // Syntax: isupper("char");
001824  002028  // Usage : Var := isupper(ch);
001825  002029  // Notes : char specifies the ascii character for the test
001826  002030  //     : 0 : char is not an ascii upper-case letter.
001827  002031  //     : 1 : char is an ascii upper-case letter.
001828  002032  //     : Valid range is "ABCD....WXYZ"
001829  002033        
001830  002034  func islower("char"), 1;    //Returns a 1 if the character is an ascii lower case letter else returns a 0
001831  002035  // Syntax: islower("char");
001832  002036  // Usage : Var := islower(ch);
001833  002037  // Notes : char specifies the ascii character for the test
001834  002038  //     : 0 : char is not an ascii lower-case letter.
001835  002039  //     : 1 : char is an ascii lower-case letter.
001836  002040  //     : Valid range is "abcd....wxyz"
001837  002041        
001838  002042  func isalpha("char"), 1;    //Returns a 1 if the character is an ascii lower or upper case letter else returns a 0
001839  002043  // Syntax: isalpha("char");
001840  002044  // Usage : Var := isalpha(ch);
001841  002045  // Notes : char specifies the ascii character for the test
001842  002046  //     : 0 : char is not an ascii lower or upper case letter.
001843  002047  //     : 1 : char is an ascii lower or upper case letter.
001844  002048  //     : Valid range is "ABCD...XYZ", "abcd....wxyz"
001845  002049        
001846  002050  func isalnum("char"), 1;    //Returns a 1 if the character is an ascii alpha numeric else returns a 0
001847  002051  // Syntax: isalnum("char");
001848  002052  // Usage : Var := isalnum(ch);
001849  002053  // Notes : char specifies the ascii character for the test
001850  002054  //     : 0 : char is not an ascii alphanumeric character.
001851  002055  //     : 1 : char is an ascii alphanumeric character.
001852  002056  //     : Valid range is "ABCD...XYZ", "abcd....wxyz", "0123456789"
001853  002057        
001854  002058  func isprint("char"), 1;    //Returns a 1 if the character is a printible ascii char else returns a 0
001855  002059  // Syntax: isprint("char");
001856  002060  // Usage : Var := isprint(ch);
001857  002061  // Notes : char specifies the ascii character for the test
001858  002062  //     : 0 : char is not a printable ascii character.
001859  002063  //     : 1 : char is a printable ascii character.
001860  002064  //     : Valid range is "0x20...0x7F"
001861  002065        
001862  002066  func isspace("char"), 1;    //Returns a 1 if the character is any one of the space type chars else returns a 0
001863  002067  // Syntax: isspace("char");
001864  002068  // Usage : Var := isspace(ch);
001865  002069  // Notes : char specifies the ascii character for the test
001866  002070  //     : 0 : char is not a space type character.
001867  002071  //     : 1 : char is a space type character.
001868  002072  //     : Valid range is space, formfeed, newline, carriage return, tab, vertical tab
001869  002073        
001870  002074  //unformatted
001871  002075  func iswhite("char"), 1;    //
001872  002076  // Syntax: iswhite("char");
001873  002077  // Usage : Var := iswhite(ch);
001874  002078  // Notes : char specifies the ascii character for the test
001875  002079  //     : 0 : char is not a space or tab character.
001876  002080  //     : 1 : char is not a space or tab character.
001877  002081  //     : Valid range is space or tab
001878  002082        
001879  002083  func toupper("char"), 1; //if character is lower case it returns the upper case equivalent else returns the passed char
001880  002084  // Syntax: toupper("char");
001881  002085  // Usage : Var := toupper(ch);
001882  002086  // Notes : char specifies the ascii character for the test
001883  002087  //     : "ABCD....XYZ" : if character is a lower case letter.
001884  002088  //     : char : if character is not a lower case letter.
001885  002089  //     : Valid range is "abcd....wxyz"
001886  002090        
001887  002091  func tolower("char"), 1; //if character is upper case it returns the lower case equivalent else returns the passed char
001888  002092  // Syntax: tolower("char");
001889  002093  // Usage : Var := tolower(ch);
001890  002094  // Notes : char specifies the ascii character for the test
001891  002095  //     : "abcd....xyz" : if character is an upper case letter.
001892  002096  //     : char : if character is not an upper case letter.
001893  002097  //     : Valid range is "ABCD....WXYZ"
001894  002098        
001895  002099  func LObyte("var"), 1;        //Returns the lower byte (lower 8 bits) of a 16 bit variable.
001896  002100  // Syntax: LObyte(var);
001897  002101  // Usage : myVar := LObyte(myvar2);
001898  002102  // Notes : var specifies the user variable
001899  002103  //     : Returns the lower byte (lower 8 bits) of a 16 bit variable
001900  002104        
001901  002105  func HIbyte("var"), 1;        //Returns the High byte (upper 8 bits) of a 16 bit variable.
001902  002106  // Syntax: HIbyte(var);
001903  002107  // Usage : myVar := HIbyte(myvar2);
001904  002108  // Notes : var specifies the user variable
001905  002109  //     : Returns the high byte (upper 8 bits) of a 16 bit variable
001906  002110        
001907  002111        
001908  002112  func ByteSwap("var"), 1;    //Returns the swapped upper and lower bytes of a 16 bit variable.
001909  002113  // Syntax: ByteSwap(var);
001910  002114  // Usage : myVar := ByteSwap(myvar2);
001911  002115  // Notes : var specifies the user variable
001912  002116  //     : Returns the endian swapped value of a 16 bit variable
001913  002117        
001914  002118        
001915  002119  //------------------------------------------------------------------//
001916  002120  //        Memory Allocation Function Prototypes
001917  002121  //------------------------------------------------------------------//
001918  002122        
001919  002123  func mem_Alloc("size"), 1;
001920  002124  // Syntax: mem_Alloc(bytesize);
001921  002125  // Usage : myvar := mem_Alloc(100);
001922  002126  // Notes : Allocate a block of memory to pointer myvar
001923  002127  //       : The allocated memory contains garbage but is a fast allocation.
001924  002128  //       : The block must later be released with mem_Free();
001925  002129  //       : returns 0 if function fails
001926  002130        
001927  002131  func mem_AllocV("size"), 1;
001928  002132  // Syntax: mem_AllocV(bytesize);
001929  002133  // Usage : myvar := mem_AllocV(100);
001930  002134  // Notes : Allocate a block of memory to pointer myvar
001931  002135  //       : The block of memory is filled with signature values
001932  002136  //       : the block starts with A5,5A then fills with incrementing
001933  002137  //       : number eg:- A5,5A,00,01,02,03...FF,00,11....
001934  002138  //       : This can be helpful when debugging
001935  002139  //       : The block must later be released with mem_Free();
001936  002140  //       : returns 0 if function fails
001937  002141        
001938  002142  func mem_AllocZ("size"), 1;
001939  002143  // Syntax: mem_AllocZ(bytesize);
001940  002144  // Usage : myvar := mem_AllocC(100);
001941  002145  // Notes : Allocate a zeroed block of memory to pointer myvar
001942  002146  //       : The block of memory is filled with zeroes
001943  002147  //       : The block must later be released with mem_Free();
001944  002148  //       : returns 0 if function fails
001945  002149        
001946  002150  func mem_Realloc("ptr", "size"), 1;
001947  002151  // Syntax: myvar := mem_Realloc("ptr", "size");
001948  002152  // Usage : myvar := mem_Realloc(ptr, size);
001949  002153  // Notes : The function may move the memory block to a new location,
001950  002154  //       : in which case the new location is returned.
001951  002155  //       : The content of the memory block is preserved up to the lesser
001952  002156  //       : of the new and old sizes, even if the block is moved.
001953  002157  //       : If the new size is larger, the value of the newly allocated
001954  002158  //       : portion is indeterminate. In case that ptr is NULL,
001955  002159  //       : the function behaves exactly as mem_Alloc, assigning a new block
001956  002160  //       : of size bytes and returning a pointer to the beginning of it.
001957  002161  //       : In case that the size is 0, the memory previously allocated in
001958  002162  //       : ptr is deallocated as if a call to mem_Free()was made, and a NULL
001959  002163  //       : pointer is returned.
001960  002164        
001961  002165  func mem_Free("allocation"), 1;
001962  002166  // Syntax: myvar := mem_Free(allocation);
001963  002167  // Usage : myvar := mem_Free(myvar);
001964  002168  // Notes : De-allocate a block of memory previously created with
001965  002169  //       : mem_Alloc(...), mem_AllocV(...); or mem_AllocZ(...);
001966  002170  //       : returns 0 if function fails
001967  002171        
001968  002172  func mem_Heap(), 1;
001969  002173  // Syntax: myvar := mem_Heap();
001970  002174  // Usage : myvar := mem_Heap();
001971  002175  // Notes : returns bytecount available in heap
001972  002176  //       :
001973  002177        
001974  002178  func mem_Set("ptr","char","size"), 1;
001975  002179  // Syntax: mem_Set(ptr,char,bytesize);
001976  002180  // Usage : mem_Set(p, 'A', 100);
001977  002181  // Notes : fill a block of memory with a byte value
001978  002182  //       : returns ptr
001979  002183        
001980  002184  func mem_Copy("src", "dest", "bytecount"), 1;
001981  002185  // Syntax: myvar := mem_Copy(src, dest, bytesize);
001982  002186  // Usage : myvar := mem_Copy(p1, p2, 100);
001983  002187  // Notes : copy a word aligned block of memory from src to dest
001984  002188  //       : Note that count is a byte count, this facilitates
001985  002189  //       : copying word aligned byte arrays when using word
001986  002190  //       : aliggned packed strings.
001987  002191  //       : returns src
001988  002192        
001989  002193  func mem_Compare("ptr1","ptr2","count"), 1;
001990  002194  // Syntax: myvar := mem_Compare(ptr1,ptr2,bytesize);
001991  002195  // Usage : myvar := mem_Compare(p1, p2, 100);
001992  002196  // Notes : compare blocks of memory at src, dest
001993  002197  //       : returns 0 if we have a match
001994  002198        
001995  002199  //------------------------------------------------------------------//
001996  002200  //        FAT16 Function Prototypes
001997  002201  //------------------------------------------------------------------//
001998  002202        
001999  002203  func file_Error(), 1;
002000  002204  // Syntax: myvar := file_Error();
002001  002205  // Usage : e := file_Error();
002002  002206  // Notes : return the most recent file error.
002003  002207  //       :
002004  002208        
002005  002209  func file_Count("filename"), 1;
002006  002210  // Syntax: count := file_Count("filename");
002007  002211  // Usage : count := file_Count("*.4dg");
002008  002212  // Notes : returns number of files found that match the criteria
002009  002213        
002010  002214  func file_Dir("filename"), 1;
002011  002215  // Syntax: count := file_Dir("filename");
002012  002216  // Usage : count := file_Dir("*.4dg");
002013  002217  // Notes : streams a string of filenames that agree with the search key
002014  002218  //       : returns number of files found that match the criteria
002015  002219        
002016  002220  func file_FindFirst("fname"), 1;
002017  002221  // Syntax: res := file_FindFirst("fname");
002018  002222  // Usage : if (file_FindFirst("*.4xe") ....
002019  002223  // Notes : returns true if at least 1 file exists
002020  002224  //       : that satisfies the file argument.
002021  002225  //       : Wildcards are usually used so if
002022  002226  //       : file_FindFirst returns true, further
002023  002227  //       : tests can be made using file_FindNext();
002024  002228  //       : to find all the files that match the
002025  002229  //       : wildcard class. Note that the stream behaviour
002026  002230  //       : is the same as file_Dir.
002027  002231  //       :
002028  002232        
002029  002233  func file_FindNext(), 1;
002030  002234  // Syntax: res := file_FindNext();
002031  002235  // Usage : while ((file_FindNext()) ....
002032  002236  // Notes : returns true if more file exists
002033  002237  //       : that satisfies the file argument
002034  002238  //       : that was given for  file_FindFirst.
002035  002239  //       : Wildcards must be used for
002036  002240  //       : file_FindFirst, else this function will
002037  002241  //       : always return zero as the only occurence
002038  002242  //       : will have already been found.
002039  002243  //       : Note that the stream behaviour
002040  002244  //       : is the same as file_Dir.
002041  002245  //       :
002042  002246        
002043  002247  func file_Exists("fname"), 1;
002044  002248  // Syntax: res := file_Exists("fname"),
002045  002249  // Usage : if(file_Exists("myfile") ....
002046  002250  // Notes : returns true if file exists
002047  002251  //       :
002048  002252        
002049  002253  func file_Open("fname", "mode"), 1;
002050  002254  // Syntax: handle := file_Open("fname","mode"),
002051  002255  // Usage : handle := file_Open("myfile.txt", 'r');
002052  002256  // Notes : returns handle if file exists
002053  002257  //       :
002054  002258        
002055  002259  func file_Close("handle"), 1;
002056  002260  // Syntax: res := file_Close("handle");
002057  002261  // Usage : res := file_Close(hnd1);
002058  002262  // Notes : returns true if file closed ok
002059  002263  //       :
002060  002264        
002061  002265  func file_Read("*dest", "size", "handle"), 1;
002062  002266  // Syntax: res := file_Read("*dest", "size", "handle"),
002063  002267  // Usage : res := file_Read(memblock,20,hnd1);
002064  002268  // Notes : returns number of characters read
002065  002269  //       : if "dest" is zero, data is read direct to GRAM window
002066  002270  //       :
002067  002271        
002068  002272        
002069  002273  func file_Seek("handle", "HiWord", "LoWord"), 1;
002070  002274  // Syntax: res := file_Seek("handle", "HiWord", "LoWord")
002071  002275  // Usage : res := file_Seek(hSource, 0, 0x1234);
002072  002276  // Notes : set file position to 0x00001234 (byte position 4660)
002073  002277  //       : for the file handle so subsequent data may be read
002074  002278  //       : from that position onwards with file_GetC(...),
002075  002279  //       : file_GetW(...) or file_GetS(...), or an image
002076  002280  //       : can be displayed with file_Image(...)
002077  002281  // Notes : returns true if ok, usually ignored
002078  002282        
002079  002283  func file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
002080  002284  // Syntax: file_Index("handle", "HiSize", "LoSize","recordnum"), 1;
002081  002285  // Usage : res := file_Index(hsource, 0, 1000, 123), 1;
002082  002286  // Notes : set file seek position to 123000
002083  002287  //       : for the file handle so subsequent data may be read
002084  002288  //       : from that record position onwards with file_GetC(...),
002085  002289  //       : file_GetW(...) or file_GetS(...), or an image
002086  002290  //       : can be displayed with file_Image(...)
002087  002291  // Notes : returns true if ok, usually ignored
002088  002292        
002089  002293  func file_Tell("handle", "&HiWord", "&LoWord"), 1;
002090  002294  // Syntax: file_Tell("handle", &HiWord, &LoWord);
002091  002295  // Usage : file_Tell(fhndl, &SizeHi, &SizeLo);
002092  002296  // Notes : Reads the 32 bit file pointer and stores it into 2 variables.
002093  002297  //       : returns true if function succeeded
002094  002298        
002095  002299  func file_Write("*source", "size", "handle"), 1;
002096  002300  // Syntax: res := fwrite("*source", "size", "handle"),
002097  002301  // Usage : res := fwrite(memblock, 20, hnd1);
002098  002302  // Notes : returns number of bytes written
002099  002303  //       :
002100  002304        
002101  002305  func file_Size("handle", "&HiWord", "&LoWord"), 1;
002102  002306  // Syntax: file_Size("handle", &HiWord, &LoWord);
002103  002307  // Usage : file_Size(fhndl, &SizeHi, &SizeLo);
002104  002308  // Notes : Reads the 32 bit file size and stores it into 2 variables.
002105  002309  //       : returns true if function succeeded
002106  002310        
002107  002311  func file_Image("x", "y", "handle"), 1;
002108  002312  // Syntax: file_Image(x, y, handle);
002109  002313  // Usage : file_Image(10, 10, hnd1);
002110  002314  // Notes : Display an image from a file at the current file position.
002111  002315  //       : The image is displayed at x,y (with respect to top left corner).
002112  002316  //       : If there is more than 1 image in the file, it can be
002113  002317  //       : accessed with file_Seek(...)
002114  002318        
002115  002319  func file_ScreenCapture("x", "y", "width", "height", "handle"), 1;
002116  002320  // Syntax: file_ScreenCapture(x, y, w, h, handle);
002117  002321  // Usage : file_ScreenCapture(10, 10, 50,50, hnd1);
002118  002322  // Notes : Save a image from screen to file at the current file position.
002119  002323  //       : The image can later be displayed with file_Image(...);
002120  002324  //       : The file may be opened in append mode to accumulate multiple
002121  002325  //       : images. Later, the images can be accessed with file_Seek(...);
002122  002326  //       : Note that the image will be sector aligned.
002123  002327  //       : All image headers must start on a sector boundary.
002124  002328  //       : The image is saved from x, y (with respect to top left corner)
002125  002329  //       : and the capture area is determined by "width" and "height".
002126  002330  //       : returns 0 if function succeeded
002127  002331        
002128  002332  func file_PutC("char","handle"), 1;
002129  002333  // Syntax: file_PutC("char", "handle");
002130  002334  // Usage : file_PutC('x', hndl);
002131  002335  // Notes : returns true if function succeeded
002132  002336        
002133  002337  func file_GetC("handle"), 1;
002134  002338  // Syntax: file_GetC("handle");
002135  002339  // Usage : mychar := fgetC("handle");
002136  002340  // Notes : returns next char from file
002137  002341        
002138  002342  func file_PutW("word","handle"), 1;
002139  002343  // Syntax: file_PutW("word","handle");
002140  002344  // Usage : file_PutW(0x1234, hndl);
002141  002345  // Notes : returns true if function succeeded
002142  002346        
002143  002347  func file_GetW("handle"), 1;
002144  002348  // Syntax: file_GetW("handle");
002145  002349  // Usage : myword := fgetW("handle");
002146  002350  // Notes : returns next word in file
002147  002351        
002148  002352  func file_PutS("*source", "handle"), 1;
002149  002353  // Syntax: res := file_Puts("*source", "handle"),
002150  002354  // Usage : res := file_Puts(mystring, hnd1);
002151  002355  // Notes : returns number of characters written
002152  002356  //       :
002153  002357        
002154  002358  func file_GetS("*string", "size", "handle"), 1;
002155  002359  // Syntax: res := file_Gets("*string", "size", "handle");
002156  002360  // Usage : res := file_Gets(mystr , 81, hnd1); // read up to 80 chars
002157  002361  // Notes : get a string from a file
002158  002362  //       : returns pointer to string or null if failed.
002159  002363  //       : file_GetS(...) automatically appends a null-terminator to the data read.
002160  002364  //       : NB:- only reads up to "size-1" characters into "string"
002161  002365  //       : file_GetS(...) will stop reading when any of the following conditions are true:
002162  002366  //       : A] It has read n-1 bytes (one character is reserved for the null-terminator)
002163  002367  //       : B] It encounters a newline character (a line-feed in the compilers tested here), or
002164  002368  //       : C] It reaches the end of file
002165  002369  //       : D] A read error occurs.
002166  002370        
002167  002371        
002168  002372  func file_Erase("fname"), 1;
002169  002373  // Syntax: res := file_Erase("fname");
002170  002374  // Usage : res := file_Erase("myfile.txt");
002171  002375  // Notes : returns true if successful
002172  002376  //       :
002173  002377        
002174  002378  func file_Rewind("handle"), 1;
002175  002379  // Syntax: res := file_Rewind("handle");
002176  002380  // Usage : res := file_Rewind(hnd1);
002177  002381  // Notes : returns true if file rewound ok (usually ignored)
002178  002382  //       : resets the file pointer the the beginning of the open file.
002179  002383        
002180  002384  func file_LoadFunction("fname.4xe"), 1;
002181  002385  // Syntax: res := file_LoadFunction("fname.4fn");
002182  002386  // Usage : myfunc := file_LoadFunction(myfuncname);
002183  002387  // Notes : Load a function or program from disk and
002184  002388  //       : return a function pointer to the allocation.
002185  002389  //       : The function can then be invoked just like any other
002186  002390  //       : function would be called via a function pointer.
002187  002391  //       : Parameters may be passed to it in a conventional way.
002188  002392  //       : The function may be discarded at any time when no
002189  002393  //       : longer required, thus freeing its memory resources.
002190  002394  //       : The loaded function can be discarded with mem_Free(..)
002191  002395  //       : eg:
002192  002396  //       : popupWindow := file_LoadFunction("popupWindow1.4fn");
002193  002397  //       : if(!popupWindow) goto LoadFunctionFailed; // could not load the function !!!
002194  002398  //       : then elsewhere in your program:-
002195  002399  //       : res := popupWindow(MYMODE,"My Title","My Popup Text");
002196  002400  //       : if(res == QUIT_APPLICATION) goto exitApp;
002197  002401  //       : Later in your program, when popupWindow is no longer
002198  002402  //       : required for the application:-
002199  002403  //       : res := mem_Free(popupWindow);
002200  002404  //       : if(!res) goto FreeFunctionFailed; // should never happen if memory not corrupted
002201  002405  //       : The callers stack is shared by the loaded function,
002202  002406  //       : however any global variables in the loaded function
002203  002407  //       : are private to that function.
002204  002408  //
002205  002409        
002206  002410  func file_Run("fname.4xe", "arglistptr"), 1;
002207  002411  // Syntax: res := file_Run("fname.4xe","arglistptr");
002208  002412  // Usage : res := file_Run(fname, argptr);
002209  002413  // Notes : current program releases any allocated memory but
002210  002414  //       : retains the stack and global memory.
002211  002415  //       : If arglistptr is 0, no arguments are passed, else
002212  002416  //       : arglist points to an array, the first element being
002213  002417  //       : the number of elements in the array.
002214  002418  //       : func 'main' in the called program accepts
002215  002419  //       : the arguments, if any. THe arguments can only
002216  002420  //       : be passed by value, no pointers or references can be
002217  002421  //       : used as all memory is cleared before the file
002218  002422  //       : is loaded. Refer to file_Exec and file_LoadFunction
002219  002423  //       : for functions that can pass by reference.
002220  002424        
002221  002425  func file_Exec("fname.4xe", "arglistptr"), 1;
002222  002426  // Syntax: res := file_Exec("fname.4xe","arglistptr");
002223  002427  // Usage : res := file_Exec("fname.4xe","arglistptr");
002224  002428  // Notes : returns like a function, current program
002225  002429  //       : calling program is kept active and control returns to it.
002226  002430  //       : If arglistptr is 0, no arguments are passed, else
002227  002431  //       : arglist points to an array, the first element being
002228  002432  //       : the number of elements in the array.
002229  002433  //       : func 'main' in the called program accepts the arguments.
002230  002434  //       : This function is similar to file_LoadFunction(...), however,
002231  002435  //       : the function argument list is passed by pointer, and
002232  002436  //       : the memory consumed by the function is released as
002233  002437  //       : soon as the function completes.
002234  002438        
002235  002439  func file_LoadImageControl("fname1", "fname2", "mode"), 1;
002236  002440  // Syntax: hImagelist := file_LoadImageControl ("controlfile", "imagefile", "mode"),
002237  002441  // Usage : hImagelist := file_LoadImageControl ("resource.dat", "resource.gci", 0);
002238  002442  // Notes : Reads a control file to create an image list.
002239  002443  //       : Returns NULL if function fails.
002240  002444  //       : Returns a handle (pointer to the memory allocation) to the
002241  002445  //       : image control list that has been created.
002242  002446  //       : "fname1" is the control list filename "*.dat"
002243  002447  //       : "fname2" is the image filename "*.gci"
002244  002448        
002245  002449  // Notes : This function Calculates the size of a chunk of memory required for
002246  002450  //       : a image list and populates it from the image control file ("*.dat")
002247  002451  //       : therefore, when imagelist is no longer required, you must de-allocate
002248  002452  //       : the image list memory by using eg:- mem_Free(hImagelist);
002249  002453  //       : to restore the heap.
002250  002454  //       :
002251  002455  //       : mode 0:- it is assumed that there is a graphics file with the
002252  002456  //       : file extension "fname2.gci". In this case, the images have been stored
002253  002457  //       : in a FAT16 file concurrently, and the offsets that ar derived from the
002254  002458  //       : "fname1.dat" file are saved in the image control so that the image control
002255  002459  //       : can open the file (*.gci) and us file_Seek to get to the position of the
002256  002460  //       : image which can then automatically be displayed using file_Image(xpos, ypos, hSource);
002257  002461  //       : mode 0 builds the image control quickly as it only scans the *.dat file
002258  002462  //       : for the file offsets and save them in the relevant entries in the image control.
002259  002463  //       : The penalty is that images take longer to find when displayed due to file_Seek
002260  002464  //       : overheads.
002261  002465  //
002262  002466  //       : mode 1:- it is assumed that there is a graphics file with the
002263  002467  //       : file extension "fname2.gci". In this case, the images have been stored
002264  002468  //       : in a FAT16 file concurrently, and the offset of the images are saved
002265  002469  //       : in the image control so that image file (*.gci) can be mapped to directly.
002266  002470  //       : The absolute cluster/sector is mapped so file seek does not need to be called
002267  002471  //       : internally. This means that there is no seek time penalty, however, the
002268  002472  //       : image list takes a lot longer to build, as all the seeking is done at control
002269  002473  //       : build time.
002270  002474        
002271  002475  //       : mode 2:- the graphics file with the is placed in a partitioned area
002272  002476  //       : In this case, the images have been stored in a in a known raw area of the FAT16
002273  002477  //       : disk, and the absolute address of the images are saved in the DAT file
002274  002478  //       : This is the fastest operation of the image control as there is no seeking
002275  002479  //       : or other disk activity taking place.
002276  002480        
002277  002481  func file_Mount(), 1;
002278  002482  // Syntax: r := file_Mount();
002279  002483  // Usage : r := file_Mount();
002280  002484  // Notes : Create a control block for FAT16 and mount the File System
002281  002485        
002282  002486  func file_Unmount(), 0;
002283  002487  // Syntax: file_Unmount();
002284  002488  // Usage : file_Unmount();
002285  002489  // Notes : release any control block and buffers for FAT16
002286  002490  //       : and unmount the File System
002287  002491        
002288  002492  func file_PlayWAV("fname1"), 1;
002289  002493  // Syntax: file_PlayWAV("fname1");
002290  002494  // Usage : file_PlayWAV("ding.wav");
002291  002495  // Notes : Play a wave file with filename "fname1"
002292  002496  //       : This function automatically grabs a chunk
002293  002497  //       : of memory for a file buffer, and a wave
002294  002498  //       : buffer. The minimum memory requirement is
002295  002499  //       : about 580 bytes for the disk io service and
002296  002500  //       : a minimum wave buffer size of 1024. The siz
002297  002501  //       : of the wave buffer allocation
002298  002502  //       : can be increased by the snd_BufSize function.
002299  002503  //       : The default size 1024 bytes.
002300  002504  //       : NB the memory is only required during the
002301  002505  //       : duration of play, and is automatically
002302  002506  //       : released while not in use.
002303  002507  //       : See the Sound Class services for other associated controls.
002304  002508  //       : If there are no errors, returns number of blocks to play (1 to 32767)
002305  002509  //       : If errors occured, the folling is returned
002306  002510  //       : -7  : Insufficient memory available for WAV buffer and file
002307  002511  //       : -6  : cant play this rate
002308  002512  //       : -5  : no data chunk found in first rsector
002309  002513  //       : -4  : no format data
002310  002514  //       : -3  : no wave chunk signature
002311  002515  //       : -2  : bad wave file format
002312  002516  //       : -1  : file not found
002313  002517        
002314  002518        
002315  002519        
002316  002520  //------------------------------------------------------------------//
002317  002521  //        Sound Class Services
002318  002522  //------------------------------------------------------------------//
002319  002523        
002320  002524  func snd_Volume("var"), 0;
002321  002525  // Syntax: snd_Volume("var");
002322  002526  // Usage : snd_Volume(30);
002323  002527  // Notes : set sound playback volume.  Var must
002324  002528  //       : be in the range from 8 (min volume)
002325  002529  //       : to 127 (max volume). If var is less
002326  002530  //       : than 8 volume is set to 8, and if
002327  002531  //       : var > 127 it is set to 127.
002328  002532        
002329  002533  func snd_Pitch("pitch"), 1;
002330  002534  // func snd_Pitch("freq"), 1;
002331  002535  // func snd_Pitch(7000), 1; // play the wave file with a sample frequency of 7khz
002332  002536  // Notes : sets the samples playback rate to a different frequency
002333  002537  //       : The minimum value is 4khz
002334  002538  //       : Setting the pitch to zero restores the original sample rate
002335  002539  //       : Return value is the samples original sample rate.
002336  002540        
002337  002541  func snd_BufSize("var"), 0;
002338  002542  // Syntax: snd_BufSize("var");
002339  002543  // Usage : snd_BufSize(2);
002340  002544  // Notes : specify the a memory chunk size for the wavefile buffer.
002341  002545  //       : default size 1024 bytes.
002342  002546  //       : 0 = 1024 bytes (default)
002343  002547  //       : 1 = 2048 bytes
002344  002548  //       : 2 = 4096 bytes
002345  002549  //       : 3 = 8192 bytes
002346  002550        
002347  002551  func snd_Stop(), 0;
002348  002552  // Syntax: snd_Stop();
002349  002553  // Usage : snd_Stop();
002350  002554  // Notes : stop any sound that is playing, releasing
002351  002555  //       : buffers and closes any open wav file.
002352  002556        
002353  002557  func snd_Pause(), 0;
002354  002558  // Syntax: snd_Pause();
002355  002559  // Usage : snd_Pause();
002356  002560  // Notes : pauses any sound that is playing, does nothing
002357  002561  //       : until sound is resumed with snd_Continue().
002358  002562  //       : The sample cam be terminated with snd_Stop.
002359  002563  //       : buffers and closes any open wav file.
002360  002564        
002361  002565  func snd_Continue(), 0;
002362  002566  // Syntax: snd_Continue();
002363  002567  // Usage : snd_Continue();
002364  002568  // Notes : resume any sound that is paused by snd_Pause.
002365  002569        
002366  002570  func snd_Playing(), 1;
002367  002571  // Syntax: snd_Playing();
002368  002572  // Usage : r := snd_Playing();
002369  002573  // Notes : returns 0 if sound has finished playing,
002370  002574  //       : else return number of 512 byte blocks to go.
002371  002575        
002372  002576        
002373  002577        
002374  002578  //------------------------------------------------------------------//
002375  002579  //        String Class Services
002376  002580  //------------------------------------------------------------------//
002377  002581        
002378  002582  func str_Ptr("&var"), 1;
002379  002583  // Syntax: str_Ptr(&var);
002380  002584  // Usage : p := str_Ptr(&var);
002381  002585  // Notes : return a byte pointer to a word region
002382  002586        
002383  002587  func str_GetD("&ptr", "&var"), 1;
002384  002588  // Syntax: str_GetD(&ptr, &var);
002385  002589  // Usage : ok := str_GetD(&ptr, &var);
002386  002590  // Notes : convert number in a string to DWORD ( myvar[2] )
002387  002591  //       : returns true if function succeeds, advancing ptr
002388  002592        
002389  002593  func str_GetW("&ptr", "&var"), 1;
002390  002594  // Syntax: str_GetW(&ptr, &var);
002391  002595  // Usage : ok := str_GetW(&ptr, &var);
002392  002596  // Notes : convert number in a string to WORD ( myvar )
002393  002597  //       : returns true if function succeeds, advancing ptr
002394  002598        
002395  002599  func str_GetHexW("&ptr", "&var"), 1;
002396  002600  // Syntax: str_GetHexW(&ptr, &var);
002397  002601  // Usage : ok := str_GetHexW(&ptr, &var);
002398  002602  // Notes : convert HEX number in a string to WORD ( myvar )
002399  002603  //       : returns true if function succeeds, advancing ptr
002400  002604        
002401  002605  func str_GetC("&ptr", "&var"), 1;
002402  002606  // Syntax: str_GetC(&ptr, &var);
002403  002607  // Usage : ok := str_GetC(&ptr, &var);
002404  002608  // Notes : get a valid ascii char in a string to WORD ( myvar )
002405  002609  //       : returns true if function succeeds, advancing ptr
002406  002610        
002407  002611  func str_GetByte("ptr"), 1;
002408  002612  // Syntax: str_GetByte(ptr);
002409  002613  // Usage : myvar := str_GetByte(ptr);
002410  002614  // Notes : get a byte to myvar
002411  002615  //       : returns value
002412  002616        
002413  002617  func str_GetWord("ptr"), 1;
002414  002618  // Syntax: GetWord(ptr);
002415  002619  // Usage : GetWord(ptr);
002416  002620  // Notes : get a word to myvar
002417  002621  //       : returns value
002418  002622        
002419  002623  func str_PutByte("ptr","val"), 0;
002420  002624  // Syntax: str_PutByte(ptr);
002421  002625  // Usage : myvar := str_PutByte(ptr);
002422  002626  // Notes : put a byte at ptr
002423  002627  //       : returns value
002424  002628        
002425  002629  func str_PutWord("ptr","val"), 0;
002426  002630  // Syntax: str_PutWord("ptr","val");
002427  002631  // Usage : str_PutWord(p,100);
002428  002632  // Notes : put word 100 at current pointer location
002429  002633  //       : returns value
002430  002634        
002431  002635  func str_Match("&ptr", "*str"), 1;
002432  002636  // Syntax: str_Match(&ptr, *str);
002433  002637  // Usage : r := str_Match(&p, "hello");
002434  002638  // Notes : Case sensitive match
002435  002639  //       : returns true if function succeded, andvancing pointer to position past
002436  002640  //       : the matched item. Note that any whitespace characters are skipped
002437  002641  //       : in the source string prior to the test.
002438  002642        
002439  002643  func str_MatchI("&ptr", "*str"), 1;
002440  002644  // Syntax: str_MatchI(&ptr, *str);
002441  002645  // Usage : r := str_MatchI(&p, "hello");
002442  002646  // Notes : Case insensitive match
002443  002647  //       : returns true if function succeded, andvancing pointer to position past
002444  002648  //       : the matched item. Note that any whitespace characters are skipped
002445  002649  //       : in the source string prior to the test.
002446  002650        
002447  002651  func str_Find("&ptr", "*str"), 1;
002448  002652  // Syntax: str_Find(&ptr, *str);
002449  002653  // Usage : n := str_Find(&p, "hello");
002450  002654  // Notes : given the address of a pointer to a source string as the
002451  002655  //       : first argument, and a pointer to a test string as the second
002452  002656  //       : argument, attempt to find the position of the matching string
002453  002657  //       : in the source string. The test is performed with case sensitivity.
002454  002658  //       : return 0 if not found, else returns the address of the first
002455  002659  //       : character of the match. NB:- The source pointer is not altered.
002456  002660        
002457  002661  func str_FindI("&ptr", "*str"), 1;
002458  002662  // Syntax: str_Find(&ptr, *str);
002459  002663  // Usage : n := str_Find(&p, "hello");
002460  002664  // Notes : given the address of a pointer to a source string as the
002461  002665  //       : first argument, and a pointer to a test string as the second
002462  002666  //       : argument, attempt to find the position of the matching string
002463  002667  //       : in the source string. The test is performed with no case
002464  002668  //       : sensitivity, eg upper and lower case chars are accepted.
002465  002669  //       : return 0 if not found, else returns the address of the first
002466  002670  //       : character of the match. NB:- The source pointer is not altered.
002467  002671        
002468  002672  func str_Length("ptr"), 1;
002469  002673  // Syntax: str_Length(ptr);
002470  002674  // Usage : len := str_Ptr(mystring);
002471  002675  // Notes : return the length of a byte aligned string excluding terminator
002472  002676        
002473  002677  func str_Printf("&ptr", "*format"), 1;
002474  002678  // Syntax: str_Printf("&ptr", "*format");
002475  002679  // Usage : r := str_Printf(&p, "hello");
002476  002680  // Notes : refer to documentation
002477  002681  //       :
002478  002682        
002479  002683  func str_Cat("dest","src"), 1;
002480  002684  // Syntax: str_Append("&dest","&src");
002481  002685  // Usage : str_Append(&buf,"Hello");
002482  002686  // Notes : Appends a copy of the source string to the destination string.
002483  002687  //       : The terminating null character in destination is overwritten by
002484  002688  //       : the first character of source, and a new null-character is appended
002485  002689  //       : at the end of the new string formed by the concatenation of both in destination.
002486  002690  //       : returns destination.
002487  002691        
002488  002692  func str_CatN("dest","src","count"), 1;
002489  002693  // Syntax: str_Append("&dest","&src","count");
002490  002694  // Usage : str_Append(&buf,"Monday",3);
002491  002695  // Notes : Appends a copy of the source string to the destination string.
002492  002696  //       : The number of characters copied is limited by "count".
002493  002697  //       : The terminating null character in destination is overwritten by
002494  002698  //       : the first character of source, and a new null-character is appended
002495  002699  //       : at the end of the new string formed by the concatenation of both in destination.
002496  002700  //       : returns destination.
002497  002701        
002498  002702        
002499  002703  func sys_StoreTouchCalibration(), 1;
002500  002704  // Syntax: sys_StoreTouchCalibration();
002501  002705  // Usage : r := sys_StoreTouchCalibration();
002502  002706  // Notes : Store the touch calibration values in non-volatile memory.
002503  002707  //       : Returns true if the values have been accepted and stored,
002504  002708  //       : else returns false if write could not be performed, or
002505  002709  //       : touch calibration values are improbable.
002506  002710  //       : The values that are stored are obtained from:-
002507  002711  //     : TOUCH_XMINCAL             78  // touch calibration value
002508  002712  //     : TOUCH_YMINCAL             79  // touch calibration value
002509  002713  //       : TOUCH_XMAXCAL             80  // touch calibration value
002510  002714  //       : TOUCH_YMAXCAL             81  // touch calibration value
002511  002715  //       : refer to the 4DGL example touchCalibrate.4DG for further information.
002512  002716  //       : This function is not supported on uVGA, Capicitive touch
002513  002717  //       : and 4.3" resistive touch modules.
002514  002718        
002515  002719        
002516  002720  func unicode_page("charbeg","charend","charoffset"), 1;
002517  002721  // Syntax: unicode_page("charbeg","charend","charoffset");
002518  002722  // Usage : eg:  F_Traditional_0x20_0xFF
002519  002723  // Notes : After selecting a unicode image control with txt_FontID,
002520  002724  //       : this function is called to set the required font within the
002521  002725  //       : unicode set. The file "Unicode.inc" contains wrappers for
002522  002726  //       : this function, and it is not normally called directly.
002523  002727  //       : Returns count of characters in the set.
002524  002728  //       : Refer to "Unicode.inc" for further information.
002525  002729        
002526  002730        
002527  002731  func EVE_SP(), 1;
002528  002732  // Syntax: EVE_SP();
002529  002733  // Usage : eg:  print(EVE_SP());
002530  002734  // Notes : Used for debugging to assess the current stack level,
002531  002735  //       : mainly for checking stack leaks
002532  002736        
002533  002737  func EVE_SSIZE(), 1;
002534  002738  // Syntax: EVE_SSIZE();
002535  002739  // Usage : eg:  print(EVE_SSIZE());
002536  002740  // Notes : Used to get the stack size,
002537  002741  //       : mainly for debugging purposes
002538  002742        
002539  002743        
002540  002744  // uVGAII extended functions
002541  002745  func disp_Sync("line"), 0;                      //  (uVGA only)  wait till scanline reaches "line"
002542  002746  // Syntax: disp_Sync(line);
002543  002747  // Usage : disp_Sync(480);
002544  002748  // Notes : Waits till the hardware gets to a certain line.
002545  002749  //       : Allows the program to synchronise writing to the hardware for flicker free operation.
002546  002750  //       : Some experimentation may be needed to find an optimum line for disp_Sync
002547  002751  //       : depending on the graphics operation. The higher the value, the slower
002548  002752  //       : the throughput. A cetain point will be reached (number of scanlines + blanking lines
002549  002753  //       : within the vertical retrace period) where it will just 'hang up' stopping the
002550  002754  //       : entire process. Eg, in 640x480 mode, if the 'lines' value is 507, operation will
002551  002755  //       : be slowest (as its actually right at the end of the blanking period) and 508
002552  002756  //       : will cause a hangup situation as it is above the highes scanline value.
002553  002757  //       : Currently, this function is only supported on displays with SSD1963 driver.
002554  002758        
002555  002759        
002556  002760  // New functions added to PmmC v2.8
002557  002761  //================================================================
002558  002762  func CY(), 1;
002559  002763  // Syntax: CY();
002560  002764  // Usage : myvar := 0xFFF8 + 9;                 // result = 1
002561  002765  //       : print(myvar," "CY(),"\n");           // carry = 1
002562  002766  // Notes : This function returns the carry status of an
002563  002767  // unsigned overflow from any 16 or 32bit additions or sutractions.
002564  002768  //================================================================
002565  002769        
002566  002770        
002567  002771  //================================================================
002568  002772  func str_ByteMove("src", "dest", "count"), 1;
002569  002773  // func str_ByteMove("src", "dest", "count"), 1;
002570  002774  // Syntax   : str_ByteMove(src, dest, bytecount);
002571  002775  // Input    : STR *source points to byte aligned source.
002572  002776  //          : STR *dest   points to byte aligned destination.
002573  002777  //          : VAR count   number of bytes to transfer.
002574  002778  // Usage    : nextpos := str_ByteMove(s, d, 100);
002575  002779  // Notes    : copy bytes from "src" to "dest", stopping only
002576  002780  //          : when "count" is exhausted.
002577  002781  //          : No terminator is appended, it is purely a
002578  002782  //          : byte copy, and any zeroes encountered will
002579  002783  //          : also be copied.
002580  002784  // Returns  : returns a pointer to the end of the destination
002581  002785  //          : (which is "dest" + "count")
002582  002786  //================================================================
002583  002787        
002584  002788        
002585  002789  //================================================================
002586  002790  func str_Copy("dest", "src"), 1;
002587  002791  // Syntax   : str_Copy(dest, src);
002588  002792  // Input    : STR *dest   points to byte aligned destination.
002589  002793  //          : STR *source points to byte aligned source.
002590  002794  // Usage    : nextplace := str_Copy(d, s);
002591  002795  // Notes    : copy a string from "src" to "dest", stopping only
002592  002796  //          : when the end of source string "src" is encountered
002593  002797  //          : (0x00 terminator).
002594  002798  //          : The terminator is always appended, even if "src" is
002595  002799  //          : an empty string.
002596  002800  // Returns  : returns a pointer to the 0x00 string terminator at
002597  002801  //          : end of "dest" (which is "dest" + str_Length(src); )
002598  002802  //================================================================
002599  002803        
002600  002804  //================================================================
002601  002805  func str_CopyN("dest", "src", "count"), 1;
002602  002806  // Syntax   : str_CopyN(dest, src, bytecount);
002603  002807  // Input    : STR *dest   points to byte aligned destination.
002604  002808  //          : STR *source points to byte aligned source.
002605  002809  //          : VAR count   max number of chars to copy.
002606  002810  // Usage    : nextplace := str_CopyN(d, s, 100);
002607  002811  // Notes    : copy a string from "src" to "dest", stopping only
002608  002812  //          : when "count" is exhausted, or end of source
002609  002813  //          : string "str" is encountered (0x00 string terminator).
002610  002814  //          : The terminator is always appended, even if
002611  002815  //          : "count" is zero, or "src" is a null string.
002612  002816  // Returns  : returns a pointer to the 0x00 string terminator
002613  002817  //          : (which is "dest" + whatever was copied)
002614  002818  //================================================================
002615  002819        
002616  002820  //================================================================
002617  002821  func umul_1616("&res32", "val1", "val2"), 1;
002618  002822  // Syntax   : umul_1616(&res32, varA, varB);
002619  002823  // Input    : DWORD *result   points to 32bit result register.
002620  002824  //          : VAR   val1  16bit register or constant
002621  002825  //          : VAR   val2  16bit register or constant
002622  002826  // Usage    : var res32[2];
002623  002827  //          : umul_1616(&res32, myvar, 50000);
002624  002828  // Notes    : performs an unsigned multiply of 2 x 16bit values
002625  002829  //          : placing the 32bit result in a 2 word array.
002626  002830  // Returns  : the pointer to the 32bit result.
002627  002831  //          : carry and overflow are not affected.
002628  002832  //================================================================
002629  002833        
002630  002834  //================================================================
002631  002835  func uadd_3232("&res32", "&val1", "&val2"), 1;
002632  002836  // Syntax   : cmp_3232(&res32, &varA, &varB);
002633  002837  // Input    : DWORD *res32 points to optional result (or zero for compare)
002634  002838  //          : DWORD *val1 points to 32bit augend
002635  002839  //          : DWORD *val2 points to 32bit addend
002636  002840  // Usage    : var res32[2];
002637  002841  //          : res := cmp_3232(res32, val1, val2);
002638  002842  // Notes    : performs an unsigned addition of 2 x 32bit values
002639  002843  //          : placing the 32bit result in a 2 word array.
002640  002844  // Returns  : returns 1 on 32bit unsigned overflow (carry).
002641  002845  //          ; carry flag is also set on 32bit unsigned overflow
002642  002846  //          ; and can be read with the CY() function.
002643  002847  //================================================================
002644  002848        
002645  002849  //================================================================
002646  002850  func usub_3232("&res32", "&val1", "&val2"), 1;
002647  002851  // Syntax   : cmp_3232(&res32, &varA, &varB);
002648  002852  // Input    : DWORD *res32 points to optional result (or zero for compare)
002649  002853  //          : DWORD *val1 points to first 32bit minuend
002650  002854  //          : DWORD *val2 points to 32bit subtrahend
002651  002855  // Usage    : var res32[2];
002652  002856  //          : res := cmp_3232(res32, val1, val2);
002653  002857  // Notes    : performs an unsigned subtraction of 2 x 32bit values
002654  002858  //          : placing the 32bit result in a 2 word array.
002655  002859  // Returns  : returns 1 on 32bit unsigned overflow (borrow).
002656  002860  //          ; carry flag is also set on 32bit unsigned underflow
002657  002861  //          ; and can be read with the CY() function.
002658  002862  //================================================================
002659  002863        
002660  002864  //================================================================
002661  002865  func ucmp_3232("&val1", "&val2"), 1;
002662  002866  // Syntax   : cmp_3232(&varA, &varB);
002663  002867  // Input    : DWORD *val1 points to 32bit minuend
002664  002868  //          : DWORD *val2 points to 32bit sutrahend
002665  002869  // Usage    : res := cmp_3232(val1, val2);
002666  002870  // Notes    : performs an unsigned comparison of 2 x 32bit values.
002667  002871  //          : The result of the subtraction is returned.
002668  002872  // Returns  : 0  if equal
002669  002873  //          : 1  if val1 > val2
002670  002874  //          : -1 if val1 < val2
002671  002875  //          : This function does not affect the carry flag.
002672  002876  //================================================================
002673  002877        
002674  002878  func disp_Disconnect(), 0;                     // Disconnect display to ensure reduced power after disabling peripheral power. New in v3.8
002675  002879  // Syntax: disp_Disconnect();                  New in v3.8
002676  002880  // Usage : disp_Disconnect();
002677  002881  // Notes : Disconnects the display driver pins and/or reconfigures it to achieve
002678  002882  //       : its lowest possible power consumption. Use after disabling peripheral power
002679  002883  //       : to ensure the minimal power usage by the display.
002680  002884  //       : disp_Init() should be used to reinitialise the display.
002681  002885        
002682  002886  func reserved(), 0;                            
002683  002887        
002684  002888  func sys_DeepSleep("units"), 1;
002685  002889  // Syntax: t := sys_DeepSleep("units");       New in v3.8
002686  002890  // Usage : t := sys_DeepSleep(10);
002687  002891  // Notes : sets the display and processor into lowest power mode for a period of time.
002688  002892  //       : When returning from DeepSleep the display should be reinitialised
002689  002893  //       : with disp_Init().
002690  002894  //       : Touching the touch screen will also wake from sleep.
002691  002895  //       : Returns remaining sleep units.
002692  002896        
002693  002897  //------------------------------------------------------------------//
002694  002898  // CONSTANTS
002695  002899  //------------------------------------------------------------------//
002696  002900        
002697  002901  // generic constants
002698  002902  #CONST
002699  002911  #END
002700  002912        
002701  002913  //------------------------------------------------------------------------------
002702  002914  // Pin related constants
002703  002915  //------------------------------------------------------------------------------
002704  002916  #CONST
002705  002934  #END
002706  002935        
002707  002936  //------------------------------------------------------------------------------
002708  002937  //gfx_Set() related constants
002709  002938  //------------------------------------------------------------------------------
002710  002939  #CONST
002711  002956  #END
002712  002957        
002713  002958        
002714  002959  //gfx_Get() related constants
002715  002960  #CONST
002716  002969  #END
002717  002970        
002718  002971        
002719  002972        
002720  002973        
002721  002974  #CONST
002722  002987  #END
002723  002988        
002724  002989        
002725  002990  #CONST
002726  003013  #END
002727  003014        
002728  003015  //------------------------------------------------------------------------------
002729  003016  //txt_Set() related constants
002730  003017  //------------------------------------------------------------------------------
002731  003018  #CONST
002732  003037  #END
002733  003038        
002734  003039        
002735  003040        
002736  003041  //------------------------------------------------------------------------------
002737  003042  //txt_Set() related arguments
002738  003043  // NB:- FONT4 must be inherited if required,
002739  003044  // eg #inherit "FONT4.fnt"
002740  003045  //------------------------------------------------------------------------------
002741  003046  #CONST
002742  003058  #END
002743  003059        
002744  003060        
002745  003061        
002746  003062  //touch_Set() related constants
002747  003063  #CONST
002748  003067  #END
002749  003068        
002750  003069  //touch_Get() related constants
002751  003070  #CONST
002752  003078  #END
002753  003079        
002754  003080  // image control offset related constants
002755  003081  #CONST
002756  003088  #END
002757  003089        
002758  003090  // image attribute flags
002759  003091  // for img_SetAttributes(...) and img_ClearAttributes(...)
002760  003092  #CONST
002761  003106  #END
002762  003107        
002763  003108        
002764  003109  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
002765  003109  #constant ALL 0xFFFF // argument for img_xxx functions to update all images
002766  003110        
002767  003111  // image control entry offsets
002768  003112  #CONST
002769  003127  #END
002770  003128        
002771  003129  #CONST
002772  003147  #END
002773  003148        
002774  003149        
002775  003150        
002776  003151        
002777  003152  #CONST
002778  003172  #END
002779  003173        
002780  003174        
002781  003175        
002782  003176  // timer control  related constants
002783  003177  #CONST
002784  003186  #END
002785  003187        
002786  003188  // I2C timing related constants
002787  003189  #CONST
002788  003193  #END
002789  003194        
002790  003195        
002791  003196  // spi_Init(...)  mode arguments
002792  003197  #CONST
002793  003207  #END
002794  003208        
002795  003209  //------------------------------------------------------------------------------
002796  003210  // system WORD variables accesible with peekW and pokeW or pointer access
002797  003211  // Note that the txt_Set variables (0-15) and gfx_set variables (16-31)
002798  003212  // can also be accessed with peekW and pokeW
002799  003213  //------------------------------------------------------------------------------
002800  003214        
002801  003215  #CONST
002802  003309  #END
002803  003310        
002804  003311  //------------------------------------------------------------------------------
002805  003312  // FILEIO Error Code Constants
002806  003313  //------------------------------------------------------------------------------
002807  003314  #CONST
002808  003340  #END
002809  003341        
002810  003342  //==================================================================================================
002811  003343        
002812  003344        
002813  003345        
002814  000013      #ENDIF
002815  000014        
002816  000015        
002817  000016      #CONST
002818  000072      #END
002819  000073        
002820  000074        
002821  000075  //===========================================================================================
002822  000076        
002823  000077        
002824  000002        
002825  000003  #MODE RUNFLASH
002826  000004        
002827  000013  */
002828  000014        
002829  000015        
file C:\Program Files (x86)\4D Labs\4D Workshop 4 IDE\include\4DGL_16bitColours.fnc

002830  000016  #inherit "4DGL_16bitColours.fnc"    // A list of constants for colors
002831  000016  #inherit "4DGL_16bitColours.fnc"    // A list of constants for colors
002832  000004  */
002833  000005        
002834  000006        
002835  000007        
002836  000008  #CONST
002837  000149  #END
002838  000150        
002839  000017        
file C:\Users\Corentin THOMASSET\Documents\Application\myConstants.fnc

002840  000018  #inherit "myConstants.fnc"          // Contains all needed constants
002841  000018  #inherit "myConstants.fnc"          // Contains all needed constants
002842  000001        
002843  000010  */
002844  000011        
002845  000012        
002846  000013  // Discomment/comment to allow/disallow debug
002847  000014  //#constant DEBUG_ON
002848  000015        
002849  000016  // Constants for the state graph
002850  000017   #CONST
002851  000023  #END
002852  000024        
002853  000025  // Constants to know the index of special characters for the digit picture
002854  000026  #CONST
002855  000035  #END
002856  000036        
002857  000037  // Constants to know the index of pictures in the handler
002858  000038  #CONST
002859  000058  #END
002860  000059        
002861  000060  // Constantes for RTC date format
002862  000061  #CONST
002863  000074  #END
002864  000075        
002865  000076  // Divers constantes
002866  000077  #CONST
002867  000085  #END
002868  000086        
002869  000087  // Defining a word in order to have custom error messages related to file managing
002870  000116  #END
2871  023E
2872  023F
2873  0240
2874  0241
2875  0242
2876  0243
2877  0244
2878  0245
2879  0246
2880  0247
2881  0248
2882  0249
2883  024A
2884  024B
2885  024C
2886  024D
2887  024E
2888  024F
2889  0250
2890  0251
2891  0252
2892  0253
2893  0254
2894  0255
2895  0256
2896  0257
2897  0258
2898  0259
2899  025A
2900  025B
2901  025C
2902  025D
2903  025E
2904  025F
2905  0260
2906  0261
2907  0262
2908  0263
2909  0264
2910  0265
2911  0266
2912  0267
2913  0268
2914  0269
2915  026A
2916  026B
2917  026C
2918  026D
2919  026E
2920  026F
2921  0270
2922  0271
2923  0272
2924  0273
2925  0274
2926  0275
2927  0276
2928  0277
2929  0278
2930  0279
2931  027A
2932  027B
2933  027C
2934  027D
2935  027E
2936  027F
2937  0280
2938  0281
2939  0282
2940  0283
2941  0284
2942  0285
2943  0286
2944  0287
2945  0288
2946  0289
2947  028A
2948  028B
2949  028C
2950  028D
2951  028E
2952  028F
2953  0290
2954  0291
2955  0292
2956  0293
2957  0294
2958  0295
2959  0296
2960  0297
2961  0298
2962  0299
2963  029A
2964  029B
2965  029C
2966  029D
2967  029E
2968  029F
2969  02A0
2970  02A1
2971  02A2
2972  02A3
2973  02A4
2974  02A5
2975  02A6
2976  02A7
2977  02A8
2978  02A9
2979  02AA
2980  02AB
2981  02AC
2982  02AD
2983  02AE
2984  02AF
2985  02B0
2986  02B1
2987  02B2
2988  02B3
2989  02B4
2990  02B5
2991  02B6
2992  02B7
2993  02B8
2994  02B9
2995  02BA
2996  02BB
2997  02BC
2998  02BD
2999  02BE
3000  02BF
3001  02C0
3002  02C1
3003  02C2
3004  02C3
3005  02C4
3006  02C5
3007  02C6
3008  02C7
3009  02C8
3010  02C9
3011  02CA
3012  02CB
3013  02CC
3014  02CD
3015  02CE
3016  02CF
3017  02D0
3018  02D1
3019  02D2
3020  02D3
3021  02D4
3022  02D5
3023  02D6
3024  02D7
3025  02D8
3026  02D9
3027  02DA
3028  02DB
3029  02DC
3030  02DD
3031  02DE
3032  02DF
3033  02E0
3034  02E1
3035  02E2
3036  02E3
3037  02E4
3038  02E5
3039  02E6
3040  02E7
3041  02E8
3042  02E9
3043  02EA
3044  02EB
3045  02EC
3046  02ED
3047  02EE
3048  02EF
3049  02F0
3050  02F1
3051  02F2
3052  02F3
3053  02F4
3054  02F5
3055  02F6
3056  02F7
3057  02F8
3058  02F9
3059  02FA
3060  02FB
3061  02FC
3062  02FD
3063  02FE
3064  02FF
3065  0300
3066  0301
3067  0302
3068  0303
3069  0304
3070  0305
3071  0306
3072  0307
3073  0308
3074  0309
3075  030A
3076  030B
3077  030C
3078  030D
3079  030E
3080  030F
3081  0310
3082  0311
3083  0312
3084  0313
3085  0314
3086  0315
3087  0316
3088  0317
3089  0318
3090  0319
3091  031A
3092  031B
3093  031C
3094  031D
3095  031E
3096  031F
3097  0320
3098  0321
3099  0322
3100  0323
3101  0324
3102  0325
3103  0326
3104  0327
3105  0328
3106  0329
3107  032A
3108  032B
3109  032C
3110  032D
3111  032E
3112  032F
3113  0330
3114  0331
3115  0332
3116  0333
3117  0334
3118  0335
3119  0336
3120  0337
3121  0338
3122  0339
3123  033A
3124  033B
3125  033C
3126  033D
3127  033E
3128  033F
3129  0340
3130  0341
3131  0342
3132  0343
3133  0344
3134  0345
3135  0346
3136  0347
3137  0348
3138  0349
3139  034A
3140  034B
3141  034C
3142  034D
3143  034E
3144  034F
3145  0350
3146  0351
3147  0352
3148  0353
3149  0354
3150  0355
3151  0356
3152  0357
3153  0358
3154  0359
3155  035A
3156  035B
3157  035C
3158  035D
3159  035E
3160  035F
3161  0360
3162  0361
3163  0362
3164  0363
3165  0364
3166  0365
3167  0366
3168  0367
3169  0368
3170  0369
3171  036A
3172  036B
3173  036C
3174  036D
3175  036E
3176  036F
3177  0370
3178  0371
3179  0372
3180  0373
3181  0374
3182  0375
3183  0376
3184  0377
3185  0378
3186  0379
3187  037A
3188  037B
3189  037C
3190  037D
3191  037E
3192  037F
3193  0380
3194  0381
3195  0382
3196  0383
3197  0384
3198  0385
3199  0386
3200  0387
3201  0388
3202  0389
3203  038A
3204  038B
3205  038C
3206  038D
3207  038E
3208  038F
3209  0390
3210  0391
3211  0392
3212  0393
3213  0394
3214  0395
3215  0396
3216  0397
3217  0398
3218  0399
3219  039A
3220  039B
3221  039C
3222  039D
3223  039E
3224  039F
3225  03A0
3226  03A1
3227  03A2
3228  03A3
3229  03A4
3230  03A5
3231  03A6
3232  03A7
3233  03A8
3234  03A9
3235  03AA
3236  03AB
3237  03AC
3238  03AD
3239  03AE
3240  03AF
3241  03B0
3242  03B1
3243  03B2
3244  03B3
3245  03B4
3246  03B5
3247  03B6
3248  03B7
3249  03B8
3250  03B9
3251  03BA
3252  03BB
3253  03BC
3254  03BD
3255  03BE
3256  03BF
3257  03C0
3258  03C1
3259  03C2
3260  03C3
3261  03C4
3262  03C5
3263  03C6
3264  03C7
3265  03C8
3266  03C9
3267  03CA
3268  03CB
3269  03CC
3270  03CD
3271  03CE
3272  03CF
3273  03D0
3274  03D1
3275  03D2
3276  03D3
3277  03D4
3278  03D5
3279  03D6
3280  03D7
3281  03D8
3282  03D9
3283  03DA
3284  03DB
3285  03DC
3286  03DD
3287  03DE
3288  03DF
3289  03E0
3290  03E1
3291  03E2
3292  03E3
3293  03E4
3294  03E5
3295  03E6
3296  03E7
3297  03E8
3298  03E9
3299  03EA
3300  03EB
3301  03EC
3302  03ED
3303  03EE
3304  03EF
3305  03F0
3306  03F1
3307  03F2
3308  03F3
3309  03F4
3310  03F5
3311  03F6
3312  03F7
3313  03F8
3314  03F9
3315  03FA
3316  03FB
3317  03FC
3318  03FD
3319  03FE
3320  03FF
3321  0400
3322  0401
3323  0402
3324  0403
3325  0404
3326  0405
3327  0406
3328  0407
3329  0408
3330  0409
3331  040A
3332  040B
3333  040C
3334  040D
3335  040E
3336  040F
3337  0410
3338  0411
3339  0412
3340  0413
3341  0414
3342  0415
3343  0416
3344  0417
3345  0418
3346  0419
3347  041A
3348  041B
3349  041C
3350  041D
3351  041E
3352  041F
3353  0420
3354  0421
3355  0422
3356  0423
3357  0424
3358  0425
3359  0426
3360  0427
3361  0428
3362  0429
3363  042A
3364  042B
3365  042C
3366  042D
3367  042E
3368  042F
3369  0430
3370  0431
3371  0432
3372  0433
3373  0434
3374  0435
3375  0436
3376  0437
3377  0438
3378  0439
3379  043A
3380  043B
3381  043C
3382  043D
3383  043E
3384  043F
3385  0440
3386  0441
3387  0442
3388  0443
3389  0444
3390  0445
3391  0446
3392  0447
3393  0448
3394  0449
3395  044A
3396  044B
3397  044C
3398  044D
3399  044E
3400  044F
3401  0450
3402  0451
3403  0452
3404  0453
3405  0454
3406  0455
3407  0456
3408  0457
3409  0458
3410  0459
3411  045A
3412  045B
3413  045C
3414  045D
3415  045E
3416  045F
3417  0460
3418  0461
3419  0462
3420  0463
3421  0464
3422  0465
3423  0466
3424  0467
3425  0468
3426  0469
3427  046A
3428  046B
3429  046C
3430  046D
3431  046E
3432  046F
3433  0470
3434  0471
3435  0472
3436  0473
3437  0474
3438  0475
003439  000117        
003440  000118        
003441  000119  // Global variables
003442  000120  var *hndl;
003443  000121  var glbDateTime[20];
003444  000122  var glbTemperature;
003445  000123  var glbHumidity;
003446  000124  var glbIsCelcius := 1;
003447  000125  var glbModeSleepOn := 0;
003448  000126  var glbFrequenceSaveData := 30; // In minutes
003449  000127  var glbBackgroundType := 0;
003450  000128  var glbStateDispaly := STATE_INIT;
file C:\Users\Corentin THOMASSET\Documents\Application\myFunctionsDisplay.fnc

003451  000019  #inherit "myFunctionsDisplay.fnc"   // Conatins all functions needed for display
003452  000019  #inherit "myFunctionsDisplay.fnc"   // Conatins all functions needed for display
003453  000001        
003454  000010  */
003455  000011        
003456  000012        
003457  000013  // This functions permit to draw digits using the pictures
003458  000014  func drawDigit(var x, var y, var digit, var image_size)
003459  000015        
003460  000016      // Some security checks
003461  000017      if(image_size != IMAGE_DIGIT_BIG && image_size != IMAGE_DIGIT_SMALL && image_size != IMAGE_DIGIT_XSMALL)
003462  000018          #IF EXISTS DEBUG_ON
003463  000019              print("Error function drawDigit : Wrong size of digit\n");
003464  000020          #ENDIF
003465  000021          return;
003466  000022      endif
003467  000023        
003468  000024      if(digit < 0 || digit > DIGIT_MAX)
003469  000025          #IF EXISTS DEBUG_ON
003470  000026              print("Error function drawDigit : Digit out of range : ", digit ,"\n");
003471  000027          #ENDIF
003472  000028          return;
003473  000029      endif
003474  000030        
003475  000031      // We chose the index of the tiled picture
003476  000032      img_SetWord(hndl, image_size, IMAGE_INDEX, digit);
003477  000033      // We chose is coordinates
003478  000034      img_SetPosition(hndl, image_size, x,y);
003479  000035      // And we display it
003480  000036      img_Show(hndl, image_size);
003481  000037  endfunc
003482  000038        
003483  000039  // This function draw the month and the day on the top right corner
003484  000040  func drawDate()
003485  000041      var month;
003486  000042        
003487  000043      month := glbDateTime[U_MONTH] + glbDateTime[D_MONTH]*10 - 1;
003488  000044        
003489  000045      if(month < 0)
003490  000046          month := 0;
003491  000047          print("Error: month == 0") ;
003492  000048      endif
003493  000049        
003494  000050      // We chose the index of our tiled picture of months
003495  000051      img_SetWord(hndl, IMAGE_MONTH, IMAGE_INDEX, month);
003496  000052      // We chose its coordinates
003497  000053      img_SetPosition(hndl, IMAGE_MONTH, 226,0);
003498  000054      // And we display it
003499  000055      img_Show(hndl, IMAGE_MONTH);
003500  000056        
003501  000057      // We display the day and we suppress the first digit if it's equal to zero (to have "5" instead of "05")
003502  000058      if(glbDateTime[7] > 0)
003503  000059          drawDigit(272,31,glbDateTime[U_DAY], IMAGE_DIGIT_SMALL);
003504  000060          drawDigit(259,31,glbDateTime[D_DAY], IMAGE_DIGIT_SMALL);
003505  000061      else
003506  000062          drawDigit(267,31,glbDateTime[U_DAY], IMAGE_DIGIT_SMALL);
003507  000063      endif
003508  000064  endfunc
003509  000065        
003510  000066  // This functions permit to draw the clock in the middle of the screen
003511  000067  func drawClock(var updateAll)
003512  000068        
003513  000069      // This function will draw our digits only if needed in order
003514  000070      // to prevent the clock from blinking unless we put "1" in argument
003515  000071        
003516  000072        
003517  000073      var x0 := 160;
003518  000074      var y0 := 120;
003519  000075      y0-=20;
003520  000076        
003521  000077      var offsetClip := 3;
003522  000078        
003523  000079      var usec;
003524  000080      usec := glbDateTime[U_SECONDES];
003525  000081      var dsec;
003526  000082      dsec := glbDateTime[D_SECONDES];
003527  000083      var umin;
003528  000084      umin := glbDateTime[U_MINUTES];
003529  000085      var dmin;
003530  000086      dmin := glbDateTime[D_MINUTES];
003531  000087      var uhour;
003532  000088      uhour := glbDateTime[U_HOUR];
003533  000089      var dhour;
003534  000090      dhour := glbDateTime[D_HOUR];
003535  000091        
003536  000092      var private oldusec := -1;
003537  000093      var private olddsec := -1;
003538  000094      var private oldumin := -1;
003539  000095      var private olddmin := -1;
003540  000096      var private olduhour := -1;
003541  000097      var private olddhour := -1;
003542  000098        
003543  000099      // We display all our digit if "1" has been passed in argument
003544  000100      if(1 == updateAll)
003545  000101          drawDigit(x0-77, y0, dhour, IMAGE_DIGIT_BIG);
003546  000102          drawDigit(x0-47, y0, uhour, IMAGE_DIGIT_BIG);
003547  000103          drawDigit(x0+7, y0, dmin, IMAGE_DIGIT_BIG);
003548  000104          drawDigit(x0+37, y0, umin, IMAGE_DIGIT_BIG);
003549  000105          drawDigit(x0-12, y0+60, dsec, IMAGE_DIGIT_SMALL);
003550  000106          drawDigit(x0+3, y0+60, usec, IMAGE_DIGIT_SMALL);
003551  000107          return;
003552  000108      endif
003553  000109        
003554  000110      // Hour tens
003555  000111      if(olddhour != dhour)
003556  000112          olddhour := dhour;
003557  000113        
003558  000114          myClipWindow(x0 - 77 + offsetClip, y0, 40-offsetClip, 40-offsetClip);
003559  000115          gfx_Clipping(ON);
003560  000116          img_Show(hndl, glbBackgroundType + 1);
003561  000117          drawDigit(x0-77, y0, dhour, IMAGE_DIGIT_BIG);
003562  000118          gfx_Clipping(OFF);
003563  000119      endif
003564  000120        
003565  000121      // Hour units
003566  000122      if(olduhour != uhour)
003567  000123          olduhour := uhour;
003568  000124        
003569  000125          myClipWindow(x0 - 47 + offsetClip, y0+offsetClip, 40-offsetClip, 40-offsetClip);
003570  000126          gfx_Clipping(ON);
003571  000127          img_Show(hndl, glbBackgroundType + 1);
003572  000128          drawDigit(x0-47, y0, uhour, IMAGE_DIGIT_BIG);
003573  000129          gfx_Clipping(OFF);
003574  000130      endif
003575  000131        
003576  000132      // The two dots
003577  000133      drawDigit(x0-20, y0, DIGIT_TWO_DOTS, IMAGE_DIGIT_BIG);
003578  000134        
003579  000135      // Minutes tens
003580  000136      if(olddmin != dmin)
003581  000137          olddmin := dmin;
003582  000138        
003583  000139          myClipWindow(x0 +7 + offsetClip, y0, 40-offsetClip, 40-offsetClip);
003584  000140          gfx_Clipping(ON);
003585  000141          img_Show(hndl, glbBackgroundType + 1);
003586  000142          drawDigit(x0+7, y0, dmin, IMAGE_DIGIT_BIG);
003587  000143          gfx_Clipping(OFF);
003588  000144      endif
003589  000145        
003590  000146      // Minutes units
003591  000147      if(oldumin != umin)
003592  000148          oldumin := umin;
003593  000149        
003594  000150          myClipWindow(x0 +37 + offsetClip, y0, 40-offsetClip, 40-offsetClip);
003595  000151          gfx_Clipping(ON);
003596  000152          img_Show(hndl, glbBackgroundType + 1);
003597  000153          drawDigit(x0+37, y0, umin, IMAGE_DIGIT_BIG);
003598  000154          gfx_Clipping(OFF);
003599  000155      endif
003600  000156        
003601  000157      // Secondes tens
003602  000158      if(olddsec != dsec)
003603  000159          olddsec := dsec;
003604  000160        
003605  000161          myClipWindow(x0-12, y0+60, 40-offsetClip, 40-offsetClip);
003606  000162          gfx_Clipping(ON);
003607  000163          img_Show(hndl, glbBackgroundType + 1);
003608  000164          drawDigit(x0-12, y0+60, dsec, IMAGE_DIGIT_SMALL);
003609  000165          gfx_Clipping(OFF);
003610  000166      endif
003611  000167        
003612  000168      // Secondes units
003613  000169      if(oldusec != usec)
003614  000170          oldusec := usec;
003615  000171        
003616  000172          myClipWindow(x0+3, y0+60, 40-offsetClip, 40-offsetClip);
003617  000173          gfx_Clipping(ON);
003618  000174          img_Show(hndl, glbBackgroundType + 1);
003619  000175          drawDigit(x0+3, y0+60, usec, IMAGE_DIGIT_SMALL);
003620  000176          gfx_Clipping(OFF);
003621  000177      endif
003622  000178  endfunc
003623  000179        
003624  000180  // A custom function to draw rectangles
003625  000181  func myRectangle(var x, var y, var w, var h, var color)
003626  000182      gfx_OutlineColour(WHITE) ;
003627  000183      gfx_LinePattern(LPFINE) ;
003628  000184      gfx_RectangleFilled(x, y, x+w, y+h, color) ;
003629  000185      gfx_OutlineColour(BLACK) ;
003630  000186      gfx_LinePattern(LPSOLID) ;
003631  000187  endfunc
003632  000188        
003633  000189  // This function draw the list for the historic
003634  000190  func drawList(var offset)
003635  000191      var linePerScreen := 5;
003636  000192      var charPerLine := 16;
003637  000193        
003638  000194      var digitOffset := 0;
003639  000195      var deltaX := 11;
003640  000196      var deltaY := 17;
003641  000197      var x := 15;
003642  000198      var y := 147;
003643  000199        
003644  000200      var datas;
003645  000201      var iBclLine, iBclChar;
003646  000202      var ptr;
003647  000203      var vars[80];
003648  000204      var n := 0;
003649  000205        
003650  000206      datas := readOnSD(offset, linePerScreen);
003651  000207        
003652  000208      ptr := str_Ptr(datas);
003653  000209        
003654  000210      while(str_GetC(&ptr, &vars[n++]) != 0);
003655  000211        
003656  000212      for(iBclLine := 0; iBclLine < linePerScreen; ++iBclLine)
003657  000213          digitOffset := 0;
003658  000214        
003659  000215          for(iBclChar := 0; iBclChar < 25; ++iBclChar)
003660  000216        
003661  000217              if((iBclChar == 2) || (iBclChar == 5) || (iBclChar == 11) || (iBclChar == 15) || (iBclChar == 18) || (iBclChar == 20) || (iBclChar == 24) || (iBclChar == 8) || (iBclChar == 14) || (iBclChar == 21))
003662  000218        
003663  000219                  switch(iBclChar)
003664  000220                      case 2 :
003665  000221                      case 5 :
003666  000222                          drawDigit(x+iBclChar*deltaX,y+deltaY*iBclLine,DIGIT_SLASH,IMAGE_DIGIT_SMALL);
003667  000223                          break;
003668  000224                      case 11 :
003669  000225                          x -= 2;
003670  000226                          drawDigit(x+iBclChar*deltaX,y+deltaY*iBclLine,DIGIT_TWO_DOTS,IMAGE_DIGIT_SMALL);
003671  000227                          x -= 2;
003672  000228                          break;
003673  000229                      case 15 :
003674  000230                          if(vars[charPerLine*iBclLine + iBclChar-digitOffset] == '1')
003675  000231                              drawDigit(x+iBclChar*deltaX,y+deltaY*iBclLine,DIGIT_MINUS,IMAGE_DIGIT_SMALL);
003676  000232                          endif
003677  000233        
003678  000234                          --digitOffset;
003679  000235        
003680  000236                          break;
003681  000237                      case 18 :
003682  000238                          x -= 2;
003683  000239                          drawDigit(x+iBclChar*deltaX,y+deltaY*iBclLine, DIGIT_COMA, IMAGE_DIGIT_SMALL);
003684  000240                          x -= 2;
003685  000241                          break;
003686  000242                      case 20 :
003687  000243                          var digitTemp;
003688  000244                          digitTemp := (glbIsCelcius == 1) ? DIGIT_CELCIUS : DIGIT_FAHRENHEIT;
003689  000245        
003690  000246                          drawDigit(x+iBclChar*deltaX,y+ deltaY*iBclLine,digitTemp , IMAGE_DIGIT_SMALL);
003691  000247                          break;
003692  000248                      case 24 :
003693  000249                          drawDigit(x+iBclChar*deltaX,y+deltaY*iBclLine, DIGIT_PERCENT, IMAGE_DIGIT_SMALL);
003694  000250                          break;
003695  000251                      endswitch
003696  000252                     ++digitOffset;
003697  000253              else
003698  000254                      drawDigit(x+iBclChar*deltaX,y+deltaY*iBclLine,vars[charPerLine * iBclLine + iBclChar-digitOffset]-'0',IMAGE_DIGIT_SMALL);
003699  000255              endif
003700  000256        
003701  000257          next
003702  000258          x+=8;
003703  000259      next
003704  000260        
003705  000261  endfunc
003706  000262        
003707  000263  // This function draw the graph for the historic
003708  000264  func drawGraph(var offset)
003709  000265        
003710  000266      // Customize the graph
003711  000267      var x0 := 40;                // Bottom left coordinates
003712  000268      var y0 := 130;               // Bottom left coordinates
003713  000269      var H := 85;                 // Height
003714  000270      var W := 240;                // Width
003715  000271      var nbGradYaxis := 5;        // Number of graduation on the y axis
003716  000272      var numberOfPoints := 5;     // The number of point to be displayed
003717  000273      // ... end of customization
003718  000274        
003719  000275      var points;
003720  000276      var max, min;
003721  000277      var stepGrad;
003722  000278      var grad;
003723  000279      var prevGrad := -1000;
003724  000280      var sign;
003725  000281      var iBcl := 0;
003726  000282      var y,x;
003727  000283      var yStep;
003728  000284      var yline := -5;
003729  000285        
003730  000286      // We get our temperature values
003731  000287      points := getTempInSD(offset, numberOfPoints);
003732  000288        
003733  000289      // We look for the greater and the lower one
003734  000290      max := getMax(points,numberOfPoints);
003735  000291      min := getMin(points,numberOfPoints);
003736  000292        
003737  000293      // We get our y scall
003738  000294      yStep := (H-10)*10/(max-min);
003739  000295        
003740  000296      // We draw the axis
003741  000297      if(min < 0 && max > 0)
003742  000298         yline := (yStep * (0 - min))/10;
003743  000299      endif
003744  000300        
003745  000301      gfx_Line(x0, y0+5, x0, y0-H-5, WHITE);
003746  000302      gfx_TriangleFilled(x0-3, y0-H-5, x0+3, y0-H-5, x0, y0-H-11, WHITE);
003747  000303        
003748  000304      gfx_Line(x0-5, y0 - 5 - yline, x0+W+5, y0 - 5 - yline, WHITE);
003749  000305      gfx_TriangleFilled(x0+W+5, y0 - 8 - yline, x0+W+5, y0 - 2 - yline, x0+W+11, y0 - 5 - yline, WHITE);
003750  000306        
003751  000307      // We display the curve
003752  000308        
003753  000309      gfx_MoveTo(x0+5+W/(numberOfPoints*2),y0-5);
003754  000310        
003755  000311      gfx_Set(PEN_SIZE, SOLID);
003756  000312        
003757  000313      for(iBcl := 0; iBcl < numberOfPoints; ++iBcl)
003758  000314        
003759  000315          x := x0+5+W/(numberOfPoints*2)+(W*iBcl)/numberOfPoints;
003760  000316        
003761  000317          y := (yStep * (points[iBcl] - min))/10;
003762  000318        
003763  000319          if(iBcl == 0)
003764  000320              gfx_MoveTo(x,y0-5-y);
003765  000321          else
003766  000322              gfx_LineTo(x,y0-5-y);
003767  000323          endif
003768  000324        
003769  000325          gfx_Bullet(2);
003770  000326      next
003771  000327        
003772  000328      // We display the graduations
003773  000329        
003774  000330      stepGrad := (max-min)*10/nbGradYaxis;
003775  000331        
003776  000332      for(iBcl := 0; iBcl <= nbGradYaxis; iBcl ++)
003777  000333          sign := 0;
003778  000334        
003779  000335          y := y0 - 5 - (yStep * (iBcl*stepGrad))/100;
003780  000336        
003781  000337          grad := (min+(iBcl*stepGrad)/10);
003782  000338        
003783  000339          if(grad != prevGrad)
003784  000340        
003785  000341              gfx_Line(x0-2,y,x0+2,y, WHITE);
003786  000342        
003787  000343        
003788  000344              if(grad < 0)
003789  000345                  grad *= -1;
003790  000346                  sign := 1;
003791  000347              endif
003792  000348        
003793  000349              drawDigit(x0-15,y-5,grad % 10,IMAGE_DIGIT_XSMALL);
003794  000350              drawDigit(x0-21,y-5,DIGIT_COMA,IMAGE_DIGIT_XSMALL);
003795  000351              drawDigit(x0-26,y-5,(grad/10)%10,IMAGE_DIGIT_XSMALL);
003796  000352        
003797  000353              if(grad/100 > 0)
003798  000354                  drawDigit(x0-31,y-5,(grad/100)%10,IMAGE_DIGIT_XSMALL);
003799  000355        
003800  000356                  if(1 == sign)
003801  000357                      drawDigit(x0-36,y-5,DIGIT_MINUS,IMAGE_DIGIT_XSMALL);
003802  000358                  endif
003803  000359              else
003804  000360                  if(1 == sign)
003805  000361                      drawDigit(x0-31,y-5,DIGIT_MINUS,IMAGE_DIGIT_XSMALL);
003806  000362                  endif
003807  000363              endif
003808  000364          endif
003809  000365          prevGrad := grad;
003810  000366      next
003811  000367      gfx_Set(PEN_SIZE, OUTLINE);
003812  000368        
003813  000369  endfunc
003814  000370        
003815  000371  // This function permits to draw the temperature in the middle of the screen
003816  000372  func drawTemp()
003817  000373      var temp;
003818  000374      temp := glbTemperature;
003819  000375        
003820  000376      var digitTemp;
003821  000377      var x;
003822  000378        
003823  000379      // We get the temperature and convert it if farenheit mode is set
003824  000380      // (to convert to farenheit : T(F) = T(C) x 9/5 + 32)
003825  000381      if(1 == glbIsCelcius)
003826  000382          digitTemp := DIGIT_CELCIUS;
003827  000383      else
003828  000384          temp := ((temp*9)/5 +320);
003829  000385          digitTemp := DIGIT_FAHRENHEIT;
003830  000386      endif
003831  000387        
003832  000388      x := 160 - nbDigit(temp)*15 - 28;  // '- 28' because of the offset of the coma and the minus digit
003833  000389        
003834  000390      if(temp < 0)
003835  000391          temp *= -1;
003836  000392          drawDigit(x, 100, DIGIT_MINUS, IMAGE_DIGIT_BIG);
003837  000393          x += 24;
003838  000394      endif
003839  000395        
003840  000396      if(temp > 100)
003841  000397          drawDigit(x, 100, temp / 100, IMAGE_DIGIT_BIG);
003842  000398          x += 30;
003843  000399      endif
003844  000400        
003845  000401      drawDigit(x, 100, (temp / 10) % 10, IMAGE_DIGIT_BIG);
003846  000402      x += 20;
003847  000403        
003848  000404      drawDigit(x, 100, DIGIT_COMA, IMAGE_DIGIT_BIG);
003849  000405      x += 20;
003850  000406        
003851  000407      drawDigit(x, 100, temp % 10, IMAGE_DIGIT_BIG);
003852  000408      x += 30;
003853  000409        
003854  000410      drawDigit(x, 100, digitTemp, IMAGE_DIGIT_BIG);
003855  000411        
003856  000412  endfunc
003857  000413        
003858  000414  // This function permits to draw the hygrometrie
003859  000415  func drawHygro()
003860  000416      var hygro;
003861  000417        
003862  000418      hygro := glbHumidity;
003863  000419        
003864  000420      // If supress the 0 in the left of our value if it's below 10 (in order to have "5" instead of "05")
003865  000421      if(hygro > 9)
003866  000422           drawDigit(140, 160, hygro / 10, IMAGE_DIGIT_SMALL);
003867  000423           drawDigit(151, 160, hygro % 10, IMAGE_DIGIT_SMALL);
003868  000424           drawDigit(166, 160, DIGIT_PERCENT, IMAGE_DIGIT_SMALL);
003869  000425      else
003870  000426           drawDigit(145, 160, hygro % 10, IMAGE_DIGIT_SMALL);
003871  000427           drawDigit(160, 160, DIGIT_PERCENT, IMAGE_DIGIT_SMALL);
003872  000428      endif
003873  000429  endfunc
003874  000430        
003875  000431  // This function draw the historic (graph + list)
003876  000432  func drawHistoric(var graphType, var dataOffset)
003877  000433        
003878  000434      if((graphType != 0) & (graphType != 1))
003879  000435          #IF EXISTS DEBUG_ON
003880  000436              print("drawHistoric : Wrong type of graph ", graphType ,"\n  1 : Temp\n  0 : Hygro\n");
003881  000437          #ENDIF
003882  000438          return;
003883  000439      endif
003884  000440        
003885  000441      drawList(dataOffset);
003886  000442      drawGraph(dataOffset);
003887  000443        
003888  000444  endfunc
003889  000445        
003890  000446  // This function draw the hamburger button that permit to go to the menu panel
003891  000447  func drawSettingButton()
003892  000448      var x0 := 10;
003893  000449      var y0 := 10;
003894  000450      var w := 25;
003895  000451      var deltaY := 7;
003896  000452        
003897  000453      gfx_RectangleFilled(x0, y0, x0+w, y0+1, WHITE);
003898  000454      gfx_RectangleFilled(x0, y0+deltaY, x0+w, y0+deltaY+1, WHITE);
003899  000455      gfx_RectangleFilled(x0, y0+deltaY*2, x0+w, y0+deltaY*2+1, WHITE);
003900  000456  endfunc
003901  000457        
file C:\Users\Corentin THOMASSET\Documents\Application\myFunctions.fnc

003902  000020  #inherit "myFunctions.fnc"          // Contains all others functions
003903  000020  #inherit "myFunctions.fnc"          // Contains all others functions
003904  000001        
003905  000010  */
003906  000011        
003907  000012        
003908  000013  // This functions permits to check if a plot (x, y) is in a rectangle (x, y, width, height)
003909  000014  func isInBox(var x, var y, var bx, var by, var bw, var bh)
003910  000015      return ((x > bx) && (x < bx + bw) && (y > by) && (y < by + bh));
003911  000016  endfunc
003912  000017        
003913  000018  // This function print the required error message or do nothing if error number is zero
003914  000019  func report(var n)
003915  000020      #IF EXISTS DEBUG_ON
003916  000021          var e;
003917  000022          if ( e := file_Error() )
003918  000023              print( "[",n,"] Error ", e, "=", [STR] FileErrors[e - 1], "\n" );
003919  000024          endif
003920  000025      #ELSE
003921  000026          return;
003922  000027      #ENDIF
003923  000028  endfunc
003924  000029        
003925  000030  // To initialize the environnement
003926  000031  func setUp()
003927  000032      // To be sure that the display is in landscape mode
003928  000033      gfx_ScreenMode(LANDSCAPE_R);
003929  000034      //gfx_Clipping(OFF);
003930  000035        
003931  000036      putstr("Mounting...\n");
003932  000037      // We try to mount the SD card
003933  000038      if (!(file_Mount()))
003934  000039          gfx_Cls();
003935  000040          putstr("Drive not mounted.\nPlease plug the uSD card.\n");
003936  000041        
003937  000042          // We wait till the card gets plug
003938  000043          while(!(file_Mount()))
003939  000044              pause(200);
003940  000045          wend
003941  000046      endif
003942  000047        
003943  000048      gfx_Cls();
003944  000049        
003945  000050        
003946  000051      var dat[20], gci[20];
003947  000052      to(dat); print(FILE_IMAGES, ".Dat");
003948  000053      to(gci); print(FILE_IMAGES, ".Gci");
003949  000054        
003950  000055      // Load the file containing all the pictures, and checking if it has been succefully loaded
003951  000056      hndl := file_LoadImageControl(str_Ptr(dat), str_Ptr(gci), 1);
003952  000057      if (!hndl)
003953  000058           print("Error can't get the image file : ", FILE_IMAGES, "\n");
003954  000059        
003955  000060           repeat forever
003956  000061      endif
003957  000062        
003958  000063      // We register our function that need a timer
003959  000064      sys_SetTimerEvent(TIMER1, updatingDate);
003960  000065      sys_SetTimerEvent(TIMER2, updatingTemp);
003961  000066      sys_SetTimerEvent(TIMER3, updatingToogle);
003962  000067      sys_SetTimerEvent(TIMER4, autoSaveData);
003963  000068      sys_SetTimerEvent(TIMER7, modeEco);
003964  000069        
003965  000070      // Activate the transparency
003966  000071      gfx_TransparentColour(TRANSPARENT_COLOR);
003967  000072      gfx_Transparency(ON);
003968  000073        
003969  000074      // To enable the touchability of the display
003970  000075      touch_Set(TOUCH_ENABLE);
003971  000076        
003972  000077      // Initializing the I2C
003973  000078      I2C_Open(I2C_SLOW);
003974  000079      pause(100);
003975  000080        
003976  000081      // To turn on the clock of the RTC
003977  000082      setUpRTC();
003978  000083        
003979  000084      // We call those functions in order to initialize our global variables with the good value
003980  000085      getTempI2C();
003981  000086      getHumidityI2C();
003982  000087      getDateTimeI2C();
003983  000088        
003984  000089      // We display the loading picture
003985  000090      img_Show(hndl, glbBackgroundType);
003986  000091      img_Show(hndl, IMAGE_LOADING);
003987  000092        
003988  000093      // We launch our timer that need to be launch
003989  000094      sys_SetTimer(TIMER2,1);
003990  000095      sys_SetTimer(TIMER4,6000);
003991  000096      sys_SetTimer(TIMER7,6000);
003992  000097  endfunc
003993  000098        
003994  000099   // To set down the environnement
003995  000100  func setDown()
003996  000101        
003997  000102      //Shutting down the I2C
003998  000103      I2C_Close();
003999  000104        
004000  000105      // We free the memory researved for the image handler
004001  000106      mem_Free(hndl);
004002  000107        
004003  000108      // Unmouting the SD
004004  000109      file_Unmount();
004005  000110  endfunc
004006  000111        
004007  000112  // A function to write in our data file in the SD card
004008  000113  func writeOnSD(var datas)
004009  000114      var dataFile;
004010  000115        
004011  000116      #IF EXISTS DEBUG_ON
004012  000117          print("Openning the file for writing\n");
004013  000118      #ENDIF
004014  000119      // We try to open our file. If the file has already been created we open it in "append" mode ("a"), if not, in "write" mode
004015  000120      if(dataFile := file_Open(FILE_DATA, (file_Exists(FILE_DATA)) ? 'a' : 'w'))
004016  000121        
004017  000122          #IF EXISTS DEBUG_ON
004018  000123              print("Writing data\n");
004019  000124          #ENDIF
004020  000125          file_Write(datas, str_Length(datas), dataFile);
004021  000126          report(2);
004022  000127        
004023  000128          #IF EXISTS DEBUG_ON
004024  000129              print("Closing the file\n");
004025  000130          #ENDIF
004026  000131          file_Close(dataFile);
004027  000132          report(3);
004028  000133      else
004029  000134          report(1);
004030  000135          #IF EXISTS DEBUG_ON
004031  000136              print("Can't open the file\n");
004032  000137          #ENDIF
004033  000138      endif
004034  000139        
004035  000140  endfunc
004036  000141        
004037  000142  // A function to read our data file in the SD card
004038  000143  func readAllOnSD()
004039  000144      var dataFile;
004040  000145      var buffer;
004041  000146      buffer := mem_Alloc(1000);
004042  000147        
004043  000148        
004044  000149      #IF EXISTS DEBUG_ON
004045  000150          print("Openning the file for reading\n");
004046  000151      #ENDIF
004047  000152      if(file_Exists(FILE_DATA))
004048  000153          // We try to open our file in "read" mode
004049  000154          if(dataFile := file_Open(FILE_DATA, 'r'))
004050  000155        
004051  000156              #IF EXISTS DEBUG_ON
004052  000157                  print("Reading data\n");
004053  000158              #ENDIF
004054  000159              file_Read(buffer,1000,dataFile);
004055  000160              //report(5); Show "ERROR 10 : Reached the end of file" till the size of the file is greater than the size of the buffer
004056  000161        
004057  000162              #IF EXISTS DEBUG_ON
004058  000163                  print("Closing the file\n");
004059  000164              #ENDIF
004060  000165              file_Close(dataFile);
004061  000166              //report(6); Show "ERROR 10 : Reached the end of file" till the size of the file is greater than the size of the buffer
004062  000167        
004063  000168              return buffer;
004064  000169          else
004065  000170              report(4);
004066  000171              #IF EXISTS DEBUG_ON
004067  000172                  print("Can't open the file\n");
004068  000173              #ENDIF
004069  000174              return -1;
004070  000175          endif
004071  000176      else
004072  000177          #IF EXISTS DEBUG_ON
004073  000178              print("Trying to open a file that doesn't exists\n");
004074  000179          #ENDIF
004075  000180          return -1;
004076  000181      endif
004077  000182  endfunc
004078  000183        
004079  000184  // A function to read our data file in the SD card
004080  000185  func readOnSD(var offset, var qqt)
004081  000186      var nbCharByData := 16;
004082  000187        
004083  000188      var dataFile;
004084  000189      var buffer;
004085  000190      buffer := mem_Alloc(nbCharByData * qqt + 2);
004086  000191        
004087  000192        
004088  000193      #IF EXISTS DEBUG_ON
004089  000194          print("Openning the file for reading\n");
004090  000195      #ENDIF
004091  000196      if(file_Exists(FILE_DATA))
004092  000197        
004093  000198          // We try to open our file in "read" mode
004094  000199          if(dataFile := file_Open(FILE_DATA, 'r'))
004095  000200        
004096  000201              // We choose from where to read
004097  000202              #IF EXISTS DEBUG_ON
004098  000203                  print("Setting the index.\n");
004099  000204              #ENDIF
004100  000205              if(file_Index(dataFile, 0, nbCharByData,offset))
004101  000206        
004102  000207                  // We read the amount of data we want
004103  000208                  #IF EXISTS DEBUG_ON
004104  000209                      print("Reading data\n");
004105  000210                  #ENDIF
004106  000211                  if(file_GetS(buffer, (nbCharByData * qqt)+1, dataFile))
004107  000212        
004108  000213                      // We close the file
004109  000214                      #IF EXISTS DEBUG_ON
004110  000215                          print("Closing the file\n");
004111  000216                      #ENDIF
004112  000217                      if(file_Close(dataFile))
004113  000218                          return buffer;
004114  000219                      else
004115  000220                          #IF EXISTS DEBUG_ON
004116  000221                              print("Can't close the file\n") ;
004117  000222                          #ENDIF
004118  000223                          report(5); // Show "ERROR 10 : Reached the end of file" till the size of the file is greater than the size of the buffer
004119  000224                      endif
004120  000225        
004121  000226                  else
004122  000227                      #IF EXISTS DEBUG_ON
004123  000228                          print("Can't read the file\n") ;
004124  000229                      #ENDIF
004125  000230                      report(4); // Show "ERROR 10 : Reached the end of file" till the size of the file is greater than the size of the buffer
004126  000231                  endif
004127  000232        
004128  000233              else
004129  000234                  #IF EXISTS DEBUG_ON
004130  000235                      print("Can't set the index.\n");
004131  000236                  #ENDIF
004132  000237                  report(3);
004133  000238              endif
004134  000239          else
004135  000240              #IF EXISTS DEBUG_ON
004136  000241                  print("Can't open the file\n");
004137  000242              #ENDIF
004138  000243              report(2);
004139  000244          endif
004140  000245      else
004141  000246          #IF EXISTS DEBUG_ON
004142  000247              print("Trying to open a file that doesn't exists\n");
004143  000248          #ENDIF
004144  000249          report(1);
004145  000250      endif
004146  000251        
004147  000252      return 0;
004148  000253  endfunc
004149  000254        
004150  000255  // A function for debug, it stop the execution with an infinite loop
004151  000256  func STOP()
004152  000257      repeat forever
004153  000258  endfunc
004154  000259        
004155  000260  // A recursive function to calcul a number x to the power of n (a classy way instead of using a basic for loop)
004156  000261  func myPow(var x, var n)
004157  000262      var m;
004158  000263        
004159  000264      if (n == 0)
004160  000265          return 1;
004161  000266      endif
004162  000267        
004163  000268      if (n % 2 == 0)
004164  000269          m := myPow(x, n / 2);
004165  000270          return m * m;
004166  000271      else
004167  000272          return x * myPow(x, n - 1);
004168  000273      endif
004169  000274  endfunc
004170  000275        
004171  000276  // This function looks for the temperature in the SD card
004172  000277  func getTempInSD(var offset, var qqt)
004173  000278      var buffer;
004174  000279      var vars[30];
004175  000280      var private ret[30];
004176  000281      var n := 0;
004177  000282      var ptr;
004178  000283      var iBcl := 0;
004179  000284        
004180  000285      for(iBcl := 0; iBcl < qqt; ++iBcl)
004181  000286        
004182  000287          buffer := readOnSD(iBcl + offset, 1);
004183  000288          ptr := str_Ptr(buffer);
004184  000289        
004185  000290          n := 0;
004186  000291          while(str_GetC(&ptr, &vars[n++]) != 0);
004187  000292        
004188  000293          ret[iBcl] := ((vars[11]-'0')*100 + (vars[12]-'0')*10 + (vars[13]-'0'))*((vars[10]=='0') ? 1 : -1);
004189  000294        
004190  000295      next
004191  000296        
004192  000297      return ret;
004193  000298  endfunc
004194  000299        
004195  000300  // This function returns the minimal value of an array
004196  000301  func getMin(var array,var length)
004197  000302      var min := 0;
004198  000303      var iBcl := 0;
004199  000304        
004200  000305      min := array[0];
004201  000306        
004202  000307        
004203  000308      for(iBcl := 0; iBcl < length; ++iBcl)
004204  000309          if(array[iBcl] < min)
004205  000310              min := array[iBcl];
004206  000311          endif
004207  000312      next
004208  000313        
004209  000314      return min;
004210  000315  endfunc
004211  000316        
004212  000317  // This function returns the maximal value of an array
004213  000318  func getMax(var array,var length)
004214  000319        
004215  000320      var max;
004216  000321      var iBcl := 0;
004217  000322        
004218  000323      max := array[0];
004219  000324        
004220  000325      for(iBcl := 0; iBcl < length; ++iBcl)
004221  000326          if(array[iBcl]>max)
004222  000327              max := array[iBcl];
004223  000328          endif
004224  000329      next
004225  000330        
004226  000331      return max;
004227  000332  endfunc
004228  000333        
004229  000334  // This function will look for the temperature on the sensor and store it into the global variable : glbTemperature
004230  000335  func getTempI2C()
004231  000336        
004232  000337      var temp := 0;
004233  000338      var ret := 0;
004234  000339        
004235  000340      // Getting data
004236  000341      I2C_Start();
004237  000342      I2C_Write(I2C_ADDRESS_CPT_TEMP + 1);
004238  000343        
004239  000344      // We don't need the 2 first bytes (humidity)
004240  000345      I2C_Read();
004241  000346      I2C_Ack();
004242  000347      I2C_Read();
004243  000348      I2C_Ack();
004244  000349        
004245  000350      temp := I2C_Read()<<6;
004246  000351      I2C_Ack();
004247  000352      temp |= I2C_Read()>>2;
004248  000353      I2C_Nack();
004249  000354        
004250  000355        
004251  000356      // Calcul of the temperature
004252  000357        
004253  000358      var val32[2];
004254  000359      var p;
004255  000360        
004256  000361      // Index 0 : LSB
004257  000362      umul_1616(val32, temp, 1650);
004258  000363        
004259  000364      ret := (val32[1] << 2) | (val32[0] >> 14);
004260  000365      ret -= 400;
004261  000366        
004262  000367      glbTemperature := ret;
004263  000368        
004264  000369  endfunc
004265  000370        
004266  000371  // This function will look for the humidity on the sensor and store it into the global variable : glbHumidity
004267  000372  func getHumidityI2C()
004268  000373      var temp := 0;
004269  000374      var ret := 0;
004270  000375        
004271  000376      // Getting data
004272  000377        
004273  000378      I2C_Start();
004274  000379      I2C_Write(I2C_ADDRESS_CPT_TEMP + 1);
004275  000380        
004276  000381        
004277  000382        
004278  000383      temp := (I2C_Read() & 63) << 8;
004279  000384      I2C_Ack();
004280  000385      temp |= I2C_Read();
004281  000386      I2C_Ack();
004282  000387        
004283  000388      // We don't need the 2 last bytes (temperature)
004284  000389      I2C_Read();
004285  000390      I2C_Ack();
004286  000391      I2C_Read();
004287  000392      I2C_Nack();
004288  000393        
004289  000394      // Calcul of the temperature
004290  000395        
004291  000396      var val32[2];
004292  000397      var p;
004293  000398        
004294  000399      // Index 0 : LSB
004295  000400      umul_1616(val32, temp, 100);
004296  000401        
004297  000402      ret := (val32[1] << 2) | (val32[0] >> 14);
004298  000403        
004299  000404      glbHumidity := ret;
004300  000405  endfunc
004301  000406        
004302  000407  // This function will look for time and date information in the RTC and store it into the global array : glbDateTime
004303  000408  func getDateTimeI2C()
004304  000409        
004305  000410      var lect := 0;
004306  000411        
004307  000412      // Secondes
004308  000413      lect := RTCRead(0);
004309  000414      glbDateTime[U_SECONDES] := (lect & 15);
004310  000415      glbDateTime[D_SECONDES] := (lect & 112) >> 4;
004311  000416        
004312  000417      // Minutes
004313  000418      lect := RTCRead(0x01);
004314  000419      glbDateTime[U_MINUTES] := (lect & 15);
004315  000420      glbDateTime[D_MINUTES] := (lect & 112) >> 4;
004316  000421        
004317  000422      // Hour
004318  000423      lect := RTCRead(0x02);
004319  000424      glbDateTime[U_HOUR] := (lect & 15);
004320  000425      glbDateTime[D_HOUR] := (lect & 48) >> 4;
004321  000426        
004322  000427        
004323  000428      // Day
004324  000429      lect := RTCRead(0x04);
004325  000430      glbDateTime[U_DAY] := (lect & 15);
004326  000431      glbDateTime[D_DAY] := (lect & 48) >> 4;
004327  000432        
004328  000433        
004329  000434      // Month
004330  000435      lect := RTCRead(0x05);
004331  000436      glbDateTime[U_MONTH] := (lect & 15);
004332  000437      glbDateTime[D_MONTH] := (lect & 16) >> 4;
004333  000438        
004334  000439      return;
004335  000440  endfunc
004336  000441        
004337  000442  // This function permits to setup the RTC module.
004338  000443  func setUpRTC()
004339  000444      var reg;
004340  000445        
004341  000446      // We switch on the bit that allow the couting
004342  000447      reg := RTCRead(0);
004343  000448      RTCWrite(0x, reg | 0x80);
004344  000449        
004345  000450        
004346  000451      //We switch on the bit that allow the RTC to memorize the time & date thanks to the 3V batterie
004347  000452      reg := RTCRead(0x03);
004348  000453      RTCWrite(0x03, reg | 0x08);
004349  000454  endfunc
004350  000455        
004351  000456  // This function is used for debug, it permits to print value in big
004352  000457  func bigprint(var text)
004353  000458      txt_Set(TEXT_WIDTH, 5);
004354  000459      txt_Set(TEXT_HEIGHT, 5);
004355  000460      print(text);
004356  000461      txt_Set(TEXT_WIDTH, 1);
004357  000462      txt_Set(TEXT_HEIGHT, 1);
004358  000463  endfunc
004359  000464        
004360  000465  // To make a clip window by width and heith
004361  000466  func myClipWindow(var x,var y,var w,var h)
004362  000467       gfx_ClipWindow(x,y, x+w, y+h);
004363  000468  endfunc
004364  000469        
004365  000470  // This function permits to know either a point is in a box or not
004366  000471  func isDotInBox(var x, var y, var bx, var by, var bw, var bh)
004367  000472      return ((x > bx) && (x < bx + bw) && (y > by) && (y < by + bh));
004368  000473  endfunc
004369  000474        
004370  000475  // This function returns 1 if a you touch in the specified box
004371  000476  // it works only one time in a loop (because when we get the touch status, it is reset)
004372  000477  func boxTouched(var xbox, var ybox, var wbox, var hbox)
004373  000478      var state;
004374  000479      var xtouched, ytouched;
004375  000480      state := getTouchStatus();
004376  000481        
004377  000482      if(state == TOUCH_PRESSED)
004378  000483          xtouched := touch_Get(TOUCH_GETX);
004379  000484          ytouched := touch_Get(TOUCH_GETY);
004380  000485          return isDotInBox(xtouched, ytouched, xbox, ybox, wbox, hbox);
004381  000486      endif
004382  000487        
004383  000488      return 0;
004384  000489  endfunc
004385  000490        
004386  000491  // This function gives the number of figures in a number (minus sign count for 1)
004387  000492  func nbDigit(var nombre)
004388  000493        
004389  000494      var ret := 0;
004390  000495        
004391  000496      if(nombre < 0)
004392  000497         nombre *= -1;
004393  000498         ++ret;
004394  000499      endif
004395  000500        
004396  000501      while(nombre > 0)
004397  000502          nombre /= 10;
004398  000503          ++ret;
004399  000504      wend
004400  000505        
004401  000506      return ret;
004402  000507  endfunc
004403  000508        
004404  000509  // This function uses the values stored in glbDateTime to save them in the RTC
004405  000510  func setDateTimeI2C()
004406  000511      var lect := 0;
004407  000512        
004408  000513      lect := RTCRead(0x1);
004409  000514      RTCWrite(0x1, writeInReg(lect, (glbDateTime[U_MINUTES] | (glbDateTime[D_MINUTES] << 4)), 0, 7));
004410  000515        
004411  000516      lect := RTCRead(0x2);
004412  000517      RTCWrite(0x2, writeInReg(lect, (glbDateTime[U_HOUR] | (glbDateTime[D_HOUR] << 4)), 0, 6));
004413  000518        
004414  000519      lect := RTCRead(0x4);
004415  000520      RTCWrite(0x4, writeInReg(lect, (glbDateTime[U_DAY] | (glbDateTime[D_DAY] << 4)), 0, 6));
004416  000521        
004417  000522      lect := RTCRead(0x5);
004418  000523      RTCWrite(0x5, writeInReg(lect, (glbDateTime[U_MONTH] | (glbDateTime[D_MONTH] << 4)), 0, 5));
004419  000524        
004420  000525  endfunc
004421  000526        
004422  000527  // This function write "value" in "reg" at the "offset"
004423  000528  func writeInReg(var reg, var value, var offset, var lenght)
004424  000538      */
004425  000539        
004426  000540      var mask := 0;
004427  000541      var iBcl := 0;
004428  000542        
004429  000543      // First we create our mask
004430  000544      // If we want to update from the bit 2 to the bit 4 our mask will be : mask = 00011100
004431  000545      for(iBcl := offset; iBcl < offset + lenght; ++iBcl)
004432  000546          mask += myPow(2,iBcl);
004433  000547      next
004434  000548        
004435  000549      // Then, with the mask, we put our bits at 0 in the byte
004436  000550      // Here we will obtain : reg = XXX000XX
004437  000551      reg &= ~mask;
004438  000552        
004439  000553      // Then we put those bits to the desired value
004440  000554      reg |= value << offset;
004441  000555      return reg;
004442  000556  endfunc
004443  000557        
004444  000558  // To read a specifeid register in the RTC
004445  000559  func RTCRead(var reg)
004446  000560      var ret;
004447  000561        
004448  000562      I2C_Start();
004449  000563      I2C_Write(I2C_ADDRESS_RTC);
004450  000564      I2C_Write(reg);
004451  000565      I2C_Restart();
004452  000566      I2C_Write(I2C_ADDRESS_RTC + 1);
004453  000567      ret := I2C_Read();
004454  000568      I2C_Nack();
004455  000569      I2C_Stop();
004456  000570        
004457  000571      return ret;
004458  000572  endfunc
004459  000573        
004460  000574  // To write a value in a specified register in the RTC
004461  000575  func RTCWrite(var reg, var value)
004462  000576      var ret;
004463  000577        
004464  000578      I2C_Start();
004465  000579      I2C_Write(I2C_ADDRESS_RTC);
004466  000580      I2C_Write(reg);
004467  000581      I2C_Write(value);
004468  000582      I2C_Ack();
004469  000583      I2C_Stop();
004470  000584        
004471  000585  endfunc
004472  000586        
004473  000587  // A function that manages the eco mode
004474  000588  func modeEco()
004475  000589      var secRemaining := 0;
004476  000590        
004477  000591      if(1 == glbModeSleepOn)
004478  000592          secRemaining := sys_Sleep(65535);   // Sleeps for
004479  000593        
004480  000594          if(secRemaining == 0)
004481  000595              sys_SetTimer(TIMER7,1);
004482  000596          else
004483  000597              sys_SetTimer(TIMER7,15000);
004484  000598          endif
004485  000599        
004486  000600          sys_EventsResume();
004487  000601      endif
004488  000602   endfunc
004489  000603        
004490  000604  // When called, this function save the date / time / temperature / humidity in the SD card
004491  000605  func saveDataInSD()
004492  000606        
004493  000607      //1502171240004012  -> 15/02/17 12h40 04,0C 12%
004494  000608        
004495  000609      var datas[20];
004496  000610      var p;
004497  000611        
004498  000612      p:= str_Ptr(datas);
004499  000613        
004500  000614      // We actualise the time / humidity & date /time
004501  000615      getTempI2C();
004502  000616      getHumidityI2C();
004503  000617      getDateTimeI2C();
004504  000618        
004505  000619      // We create our string containning all the data
004506  000620      str_PutByte(p+0, '0' + glbDateTime[D_DAY]);
004507  000621      str_PutByte(p+1, '0' + glbDateTime[U_DAY]);
004508  000622      str_PutByte(p+2, '0' + glbDateTime[D_MONTH]);
004509  000623      str_PutByte(p+3, '0' + glbDateTime[U_MONTH]);
004510  000624      str_PutByte(p+4, '0' + glbDateTime[D_YEAR]);
004511  000625      str_PutByte(p+5, '0' + glbDateTime[U_YEAR]);
004512  000626      str_PutByte(p+6, '0' + glbDateTime[D_HOUR]);
004513  000627      str_PutByte(p+7, '0' + glbDateTime[U_HOUR]);
004514  000628      str_PutByte(p+8, '0' + glbDateTime[D_MINUTES]);
004515  000629      str_PutByte(p+9, '0' + glbDateTime[U_MINUTES]);
004516  000630      str_PutByte(p+10, (glbTemperature < 0) ? '1' : '0');
004517  000631      str_PutByte(p+11, '0' + (glbTemperature/100));
004518  000632      str_PutByte(p+12, '0' + ((glbTemperature/10)%10));
004519  000633      str_PutByte(p+13, '0' + (glbTemperature%10));
004520  000634      str_PutByte(p+14, '0' + (glbHumidity/10));
004521  000635      str_PutByte(p+15, '0' + (glbHumidity%10));
004522  000636        
004523  000637      writeOnSD(p);
004524  000638        
004525  000639  endfunc
004526  000640        
004527  000641  // A function that manage the auto save in the SD card
004528  000642  func autoSaveData()
004529  000643          var private iCpt := 0;
004530  000644          iCpt++;
004531  000645        
004532  000646          // We don't save our data if the user is in the setting menu
004533  000647          if(iCpt == glbFrequenceSaveData && glbStateDispaly != STATE_SETTING)
004534  000648              iCpt := 0;
004535  000649        
004536  000650              saveDataInSD();
004537  000651          endif
004538  000652        
004539  000653     sys_SetTimer(TIMER2,60000);
004540  000654  endfunc
004541  000655        
004542  000656  // This returns the state of the touch register and postone the falling asleep of display if in eco mode and a touch event occured
004543  000657  func getTouchStatus()
004544  000658      var status;
004545  000659      status := touch_Get(TOUCH_STATUS);
004546  000660        
004547  000661      // If their is a touch event, we postone the enter in sleep mode
004548  000662      if((status == TOUCH_PRESSED || status == TOUCH_MOVING) && 1 == glbModeSleepOn)
004549  000663          sys_SetTimer(TIMER7,15000);
004550  000664      endif
004551  000665        
004552  000666      return status;
004553  000667  endfunc
004554  000668        
004555  000669        
file C:\Users\Corentin THOMASSET\Documents\Application\myStategraphs.fnc

004556  000021  #inherit "myStategraphs.fnc"        // Contains all the state state graphs
004557  000021  #inherit "myStategraphs.fnc"        // Contains all the state state graphs
004558  000001        
004559  000010  */
004560  000011        
004561  000012  // This function manage the global state of the weather station
004562  000013  func mainStateGraph()
004563  000014        
004564  000015      switch(glbStateDispaly)
004565  000016        
004566  000017          // In this state we make the set up and we display the logo of the weather station
004567  000018          case STATE_INIT:
004568  000019              setUp();
004569  000020              pause(2000);
004570  000021              // When init is finished, we go to the main screen
004571  000022              glbStateDispaly := STATE_MAIN_SCREEN;
004572  000023              break;
004573  000024        
004574  000025          // This state manage the main screen, the toogle between the the time & date and the temperature
004575  000026          case STATE_MAIN_SCREEN:
004576  000027              mainScreen();
004577  000028              break;
004578  000029        
004579  000030          // This state manage the menu that permit to go into the settings or view the historic
004580  000031          case STATE_MENU_SCREEN:
004581  000032              menuScreen();
004582  000033              break;
004583  000034        
004584  000035          // This state manage the setting screen
004585  000036          case STATE_SETTING:
004586  000037              settingScreen();
004587  000038              break;
004588  000039        
004589  000040          // This state manage the historic state
004590  000041          case STATE_HISTORIC:
004591  000042              historicScreen();
004592  000043              break;
004593  000044        
004594  000045      endswitch
004595  000046  endfunc
004596  000047        
file C:\Users\Corentin THOMASSET\Documents\Application\myMainScreen.fnc

004597  000022  #inherit "myMainScreen.fnc"         // Contains the function that manage the main screen
004598  000022  #inherit "myMainScreen.fnc"         // Contains the function that manage the main screen
004599  000001        
004600  000010  */
004601  000011        
004602  000012        
004603  000013  var glbUpdatingMainScreen := 1;
004604  000014  var glbUpdateFrequenceToogleMainScreen := 5000;
004605  000015        
004606  000016  // We periodic update the date till we are on the main screen
004607  000017  func updatingDate()
004608  000018      getDateTimeI2C();
004609  000019        
004610  000020      if(1 == glbUpdatingMainScreen)
004611  000021          sys_SetTimer(TIMER1,1000);
004612  000022      endif
004613  000023  endfunc
004614  000024        
004615  000025  // We update the temperature and the hygrometrie every 10 sec
004616  000026  func updatingTemp()
004617  000027      getTempI2C();
004618  000028      getHumidityI2C();
004619  000029        
004620  000030      // We change the background according to the temperature
004621  000031      //  TC < 8C : Background cold
004622  000032      //  8C < TC < 28C : Background normal
004623  000033      //  TC > 28C : Background warm
004624  000034        
004625  000035      if(glbTemperature < 80)
004626  000036          glbBackgroundType := IMAGE_BG_COLD;
004627  000037      else
004628  000038          if(glbTemperature > 280)
004629  000039              glbBackgroundType := IMAGE_BG_WARM;
004630  000040          else
004631  000041              glbBackgroundType := IMAGE_BG_NORMAL;
004632  000042          endif
004633  000043      endif
004634  000044        
004635  000045      sys_SetTimer(TIMER2,10000);
004636  000046  endfunc
004637  000047        
004638  000048  // This function toogle the display between temperature and time
004639  000049  func updatingToogle()
004640  000050      var private cpt := 0;
004641  000051      var nbIteration := 100;
004642  000052        
004643  000053      // We draw the loading bar at the bottom of the screen
004644  000054      gfx_Line(0, 239, cpt * 320/nbIteration, 239, WHITE);
004645  000055      gfx_Line(0, 238, cpt * 320/nbIteration, 238, WHITE);
004646  000056        
004647  000057      if(cpt++ >= nbIteration)
004648  000058          mainScreen.state := !mainScreen.state;
004649  000059          cpt := 0;
004650  000060        
004651  000061          gfx_ClipWindow(0, 238, 320, 240);
004652  000062          gfx_Clipping(ON);
004653  000063          img_Show(hndl, glbBackgroundType + 1);
004654  000064          gfx_Clipping(OFF);
004655  000065      endif
004656  000066        
004657  000067      if(1 == glbUpdatingMainScreen)
004658  000068          sys_SetTimer(TIMER3,glbUpdateFrequenceToogleMainScreen/nbIteration);
004659  000069      else
004660  000070          cpt := 0;
004661  000071        
004662  000072          gfx_ClipWindow(0, 238, 320, 240);
004663  000073          gfx_Clipping(ON);
004664  000074          img_Show(hndl, glbBackgroundType);
004665  000075          gfx_Clipping(OFF);
004666  000076      endif
004667  000077  endfunc
004668  000078        
004669  000079  // This function managed the main screen
004670  000080  func mainScreen()
004671  000081        
004672  000082      var private state := 0;
004673  000083      var oldState := -1;
004674  000084      var xtouched, ytouched;
004675  000085        
004676  000086      sys_SetTimer(TIMER1,1);
004677  000087      sys_SetTimer(TIMER3,1);
004678  000088        
004679  000089      glbUpdatingMainScreen := 1;
004680  000090        
004681  000091      img_Show(hndl, glbBackgroundType + 1);
004682  000092        
004683  000093      drawSettingButton();
004684  000094      drawDate();
004685  000095        
004686  000096      while(1 == glbUpdatingMainScreen)
004687  000097        
004688  000098          // If the state changed we clean the middle of the screen and we display either the time or the temperature/humidity
004689  000099          if(oldState != state)
004690  000100              oldState := state;
004691  000101        
004692  000102              myClipWindow(50, 60, 220, 140);
004693  000103              gfx_Clipping(ON);
004694  000104              img_Show(hndl, glbBackgroundType + 1);
004695  000105              gfx_Clipping(OFF);
004696  000106        
004697  000107              if(1 == state)
004698  000108                  drawClock(1);  // We display all the clock
004699  000109              endif
004700  000110          endif
004701  000111        
004702  000112          if(state == 1)
004703  000113              drawClock(0); // We display only the things that have changed
004704  000114          else
004705  000115              drawTemp();
004706  000116              drawHygro();
004707  000117          endif
004708  000118        
004709  000119          // We check if an interaction occured
004710  000120          if(getTouchStatus() == TOUCH_PRESSED)
004711  000121              // We get the X and Y coordinates of the touched point
004712  000122              xtouched := touch_Get(TOUCH_GETX);
004713  000123              ytouched := touch_Get(TOUCH_GETY);
004714  000124        
004715  000125              if(isDotInBox(xtouched, ytouched,0,0,45,34))  // Setting button
004716  000126                  // We stop all timer and go out of the while loop and update the states graph
004717  000127                  glbUpdatingMainScreen := 0;
004718  000128                  glbStateDispaly := STATE_MENU_SCREEN;
004719  000129              else
004720  000130                  if(isDotInBox(xtouched, ytouched,70,35,180,180))  // In the circle
004721  000131                      // We manually toogle the display and reset the timer fot toogleing
004722  000132                      state := !state;
004723  000133        
004724  000134                      updatingToogle.cpt := 0;
004725  000135        
004726  000136                  else
004727  000137                      // If the user touch the date and month at the top right corner we go directly in the setting to update the date & time
004728  000138                      if(isDotInBox(xtouched, ytouched, 226, 0, 94, 50))
004729  000139                          glbUpdatingMainScreen := 0;
004730  000140                          glbStateDispaly := STATE_SETTING;
004731  000141                          settingScreen.stateSetting := 1;
004732  000142                      endif
004733  000143                  endif
004734  000144              endif
004735  000145          endif
004736  000146      wend
004737  000147  endfunc
file C:\Users\Corentin THOMASSET\Documents\Application\myMenuScreen.fnc

004738  000023  #inherit "myMenuScreen.fnc"         // Contains the function that manage the menu screen
004739  000023  #inherit "myMenuScreen.fnc"         // Contains the function that manage the menu screen
004740  000001        
004741  000010  */
004742  000011        
004743  000012        
004744  000013  func menuScreen()
004745  000014      var loop := 1;
004746  000015      var xtouched, ytouched;
004747  000016        
004748  000017      img_Show(hndl, glbBackgroundType); // We display the background
004749  000018      img_Show(hndl, IMAGE_MENU_PANEL);  // We display the button "SETTINGS" & "HISTORIC"
004750  000019      img_Show(hndl, IMAGE_BACK);        // We dsiplay the back button (top left corner)
004751  000020        
004752  000021      while(1 == loop)
004753  000022        
004754  000023          // We check if an interaction occured
004755  000024          if(getTouchStatus() == TOUCH_PRESSED)
004756  000025              // We get the X and Y coordinates of the touched point
004757  000026              xtouched := touch_Get(TOUCH_GETX);
004758  000027              ytouched := touch_Get(TOUCH_GETY);
004759  000028        
004760  000029              if(isDotInBox(xtouched, ytouched,0,0,80,42))  // Back button
004761  000030                    glbStateDispaly := STATE_MAIN_SCREEN;   // We change the state of the display : we go back to the main screen ...
004762  000031                    loop := 0;                              // ... and we go out of the while loop
004763  000032              else
004764  000033                  if(isDotInBox(xtouched, ytouched,95,70,130,40))  // Setting button
004765  000034                      glbStateDispaly := STATE_SETTING;            // We change the state of the display : we go back to the setting screen ...
004766  000035                      loop := 0;                                   // ... and we go out of the while loop
004767  000036                  else
004768  000037                      if(isDotInBox(xtouched, ytouched,95,133,130,40))  // Historic button
004769  000038                         glbStateDispaly := STATE_HISTORIC;             // We change the state of the display : we go back to the historic screen ...
004770  000039                         loop := 0;                                     // ... and we go out of the while loop
004771  000040                      endif
004772  000041                  endif
004773  000042              endif
004774  000043          endif
004775  000044      wend
004776  000045  endfunc
file C:\Users\Corentin THOMASSET\Documents\Application\myHistoricScreen.fnc

004777  000024  #inherit "myHistoricScreen.fnc"     // Contains the function that manage the historic screen
004778  000024  #inherit "myHistoricScreen.fnc"     // Contains the function that manage the historic screen
004779  000001        
004780  000010  */
004781  000011        
004782  000012        
004783  000013  // This function manages the historic
004784  000014  func historicScreen()
004785  000015        
004786  000027      */
004787  000028        
004788  000029      var offset := 0;
004789  000030      var loop := 1;
004790  000031      var touchStatus;
004791  000032      var wasOnRight := 0;
004792  000033      var wasOnleft := 0;
004793  000034      var x,y;
004794  000035      var hasSlided := 0;
004795  000036        
004796  000037      // We dispaly the background
004797  000038      img_Show(hndl, glbBackgroundType);
004798  000039        
004799  000040      // We display the header of the historic pannel (back button + title)
004800  000041      img_Show(hndl, IMAGE_BACK_HISORIC);
004801  000042        
004802  000043      // We draw the historic
004803  000044      drawHistoric(0,0);
004804  000045        
004805  000046      while(1 == loop)
004806  000047          touchStatus := getTouchStatus();
004807  000048          x := touch_Get(TOUCH_GETX);
004808  000049          y := touch_Get(TOUCH_GETY);
004809  000050        
004810  000051          // We check if the user is pressing the screen
004811  000052          if(touchStatus == TOUCH_PRESSED)
004812  000053              if(isDotInBox(x, y,0,0,80,42))              // Back button
004813  000054                  glbStateDispaly := STATE_MENU_SCREEN;   // We change the state of the display : we go back to the menu screen
004814  000055                  loop := 0;                              // And we go out of the while loop
004815  000056              else
004816  000057                  if(isInBox(x,y,0, 0, 50, 240))    // Step 1.a : We check if he has pressed on the left of the display
004817  000058                      wasOnleft:=1;
004818  000059                  endif
004819  000060                  if(isInBox(x,y, 270, 0, 50, 240)) // Step 2.a : We check if he has pressed on the right of the display
004820  000061                      wasOnRight:=1;
004821  000062                  endif
004822  000063              endif
004823  000064          endif
004824  000065        
004825  000066          // We he release, we reset our variables
004826  000067          if(touchStatus == TOUCH_RELEASED)
004827  000068              wasOnRight:=0;
004828  000069              wasOnleft:=0;
004829  000070              hasSlided := 0;
004830  000071          endif
004831  000072        
004832  000073          if(touchStatus == TOUCH_MOVING || touchStatus == TOUCH_PRESSED)
004833  000074              // Step 1.b and 2.b (they are the same) : We check if he has been to the middle of the screen
004834  000075              if(isInBox(x,y, 100, 0, 120, 240) && (1 == wasOnleft || 1 == wasOnRight) && (0 == hasSlided))
004835  000076                  hasSlided := 1;
004836  000077        
004837  000078                  // If he can from the left we decrease our offset
004838  000079                  if(1 == wasOnleft)
004839  000080                      offset -= (offset == 0) ? 0 : 1;
004840  000081                  endif
004841  000082        
004842  000083                  // If he can from the right we increase our offset
004843  000084                  if(1 == wasOnRight)
004844  000085                      offset ++;
004845  000086                  endif
004846  000087        
004847  000088                  // Then we update only the historic (not the header on the top)
004848  000089                  myClipWindow(0, 26, 320, 214);
004849  000090                  gfx_Clipping(ON);
004850  000091                  img_Show(hndl, glbBackgroundType);
004851  000092                  drawHistoric(0,offset);
004852  000093                  gfx_Clipping(OFF);
004853  000094        
004854  000095              endif
004855  000096          endif
004856  000097      wend
004857  000098  endfunc
004858  000099        
file C:\Users\Corentin THOMASSET\Documents\Application\mySettingScreen.fnc

004859  000025  #inherit "mySettingScreen.fnc"      // Contains the function that manage the setting screen
004860  000025  #inherit "mySettingScreen.fnc"      // Contains the function that manage the setting screen
004861  000001        
004862  000010  */
004863  000011        
004864  000012        
004865  000013  // This function manage the setting state
004866  000014  func settingScreen()
004867  000015      var private stateSetting := 0;
004868  000016        
004869  000017      // We display the background
004870  000018      img_Show(hndl, glbBackgroundType);
004871  000019      //We put the image taht permit to toogle between the too setting pannels
004872  000020      img_SetPosition(hndl, IMAGE_BTN_TOOGLE, 115,215);
004873  000021        
004874  000022      // According to the state, we display either the pannel 0 (basic settings) or the pannel 1 (date / time adjustments)
004875  000023      switch(stateSetting)
004876  000024          case 0:
004877  000025              settingPannel0();
004878  000026              break;
004879  000027           case 1:
004880  000028              settingPannel1();
004881  000029              break;
004882  000030      endswitch
004883  000031        
004884  000032  endfunc
004885  000033        
004886  000034  // This function permit to adjust basic options
004887  000035  func settingPannel0()
004888  000036      var loop := 1;
004889  000037      var xtouched, ytouched;
004890  000038      var oldUnit := -1;
004891  000039      var oldEcoMode := -1;
004892  000040      var digit;
004893  000041        
004894  000042      // We display the back button
004895  000043      img_Show(hndl, IMAGE_BACK);
004896  000044      // We display the On/Off button that permit to activate or desactivate the eco mode
004897  000045      img_Show(hndl, IMAGE_ON_OFF);
004898  000046      // We display the picture that contain all the text of the setting pannel ("Eco mode :", "Units :", ...)
004899  000047      img_Show(hndl, IMAGE_SETTING_0);
004900  000048        
004901  000049      // We diaply only the rigth arrow of the button that permit to toogle between the two pannels
004902  000050      myClipWindow(160, 200, 80, 50);
004903  000051      gfx_Clipping(ON);
004904  000052      img_Show(hndl, IMAGE_BTN_TOOGLE );
004905  000053      gfx_Clipping(OFF);
004906  000054        
004907  000055      // We draw circles that permits to know in which pannel you are
004908  000056      gfx_CircleFilled(150, 222, 4, WHITE);
004909  000057      gfx_Circle(170, 222, 4, WHITE);
004910  000058        
004911  000059      while(1 == loop)
004912  000060        
004913  000061          // We draw the image that manage the unit (C or F) according to the current unit
004914  000062          // We draw it only if their is the need
004915  000063          if(oldUnit != glbIsCelcius)
004916  000064              oldUnit := glbIsCelcius;
004917  000065              img_SetWord(hndl, IMAGE_CEL_FAR, IMAGE_INDEX, glbIsCelcius);
004918  000066              myClipWindow(175, 90, 144, 36);
004919  000067              gfx_Clipping(ON);
004920  000068              img_Show(hndl, glbBackgroundType);
004921  000069              img_Show(hndl, IMAGE_CEL_FAR);
004922  000070              gfx_Clipping(OFF);
004923  000071          endif
004924  000072        
004925  000073          // We draw the image that manage the eco mode (on/off button)
004926  000074          // We draw it only if their is the need
004927  000075          if(oldEcoMode != glbModeSleepOn)
004928  000076              oldEcoMode := glbModeSleepOn;
004929  000077              img_SetWord(hndl, IMAGE_ON_OFF, IMAGE_INDEX, glbModeSleepOn);
004930  000078        
004931  000079              myClipWindow(175, 56, 74, 36);
004932  000080              gfx_Clipping(ON);
004933  000081              img_Show(hndl, glbBackgroundType);
004934  000082              img_Show(hndl, IMAGE_ON_OFF);
004935  000083              gfx_Clipping(OFF);
004936  000084          endif
004937  000085        
004938  000086          // We now draw the value of the actual update time between the two screen of the main view
004939  000087          digit := glbUpdateFrequenceToogleMainScreen / 1000;
004940  000088          if(digit > 9)
004941  000089              drawDigit(222, 127, (digit/10)%10,IMAGE_DIGIT_SMALL);
004942  000090              drawDigit(231, 127, digit%10,IMAGE_DIGIT_SMALL);
004943  000091          else
004944  000092              drawDigit(228, 127, digit%10,IMAGE_DIGIT_SMALL);
004945  000093          endif
004946  000094        
004947  000095          // Here we draw the frequence between two save in the SD card
004948  000096          if(glbFrequenceSaveData > 9)
004949  000097              drawDigit(222, 157, (glbFrequenceSaveData/10)%10,IMAGE_DIGIT_SMALL);
004950  000098              drawDigit(231, 157, glbFrequenceSaveData%10,IMAGE_DIGIT_SMALL);
004951  000099          else
004952  000100              drawDigit(228, 157, glbFrequenceSaveData%10,IMAGE_DIGIT_SMALL);
004953  000101          endif
004954  000102        
004955  000103        
004956  000104          // We check if an interaction occured
004957  000105          if(getTouchStatus() == TOUCH_PRESSED)
004958  000106              // We get the X and Y coordinates of the touched point
004959  000107              xtouched := touch_Get(TOUCH_GETX);
004960  000108              ytouched := touch_Get(TOUCH_GETY);
004961  000109        
004962  000110              if(isDotInBox(xtouched, ytouched,0,0,80,42))  // Back button
004963  000111                  glbStateDispaly := STATE_MENU_SCREEN;     // We change the state of the display : we go back to the menu screen ...
004964  000112                  loop := 0;                                // ... we go out of the while loop ...
004965  000113                  sys_SetTimer(TIMER7,10000);               // ... and we make that the eco mode will be take into account
004966  000114              else
004967  000115                  // For managing the unit, we check :
004968  000116                  // (Celcius_button_pressed && Actual_unit_is_farenheit) || (Farenheit_button_pressed && Actual_unit_is_celcuis)
004969  000117                  if((isDotInBox(xtouched, ytouched,175, 90, 70 ,36) && glbIsCelcius == 0) || (isDotInBox(xtouched, ytouched,245, 90, 70 ,36) && glbIsCelcius == 1))
004970  000118                      // If it's true, we toogle the unit
004971  000119                      glbIsCelcius := !glbIsCelcius;
004972  000120                  else
004973  000121                      // We check if the eco mode button has been touched
004974  000122                      if(isDotInBox(xtouched, ytouched,175, 56, 70 ,36))
004975  000123                          glbModeSleepOn := !glbModeSleepOn;
004976  000124                      else
004977  000125                          // We check we want to decrease the value of the frequence between the each panel of the main screen
004978  000126                          if(isDotInBox(xtouched, ytouched, 180, 150, 50, 30))
004979  000127                              glbUpdateFrequenceToogleMainScreen -= 1000;
004980  000128                              glbUpdateFrequenceToogleMainScreen := (glbUpdateFrequenceToogleMainScreen < 1000) ? 30000 : glbUpdateFrequenceToogleMainScreen;
004981  000129        
004982  000130                              // We update only the needed part
004983  000131                              myClipWindow(205, 150, 50, 30);
004984  000132                              gfx_Clipping(ON);
004985  000133                              img_Show(hndl, glbBackgroundType);
004986  000134                              gfx_Clipping(OFF);
004987  000135                          else
004988  000136                              // We check we want to increase the value of the frequence between the each panel of the main screen
004989  000137                              if(isDotInBox(xtouched, ytouched, 240, 150, 50, 30))
004990  000138                                  glbUpdateFrequenceToogleMainScreen += 1000;
004991  000139                                  glbUpdateFrequenceToogleMainScreen := (glbUpdateFrequenceToogleMainScreen > 30000) ? 1000 : glbUpdateFrequenceToogleMainScreen;
004992  000140        
004993  000141                                  // We update only the needed part
004994  000142                                  myClipWindow(205, 150, 50, 30);
004995  000143                                  gfx_Clipping(ON);
004996  000144                                  img_Show(hndl, glbBackgroundType);
004997  000145                                  gfx_Clipping(OFF);
004998  000146                              else
004999  000147                                  // We check we want to decrease the value between two save in the SD card
005000  000148                                  if(isDotInBox(xtouched, ytouched, 180, 120, 50, 30))
005001  000149                                      glbFrequenceSaveData -= 1;
005002  000150                                      glbFrequenceSaveData := (glbFrequenceSaveData < 5) ? 99 : glbFrequenceSaveData;
005003  000151        
005004  000152                                      // We update only the needed part
005005  000153                                      myClipWindow(205, 120, 50, 30);
005006  000154                                      gfx_Clipping(ON);
005007  000155                                      img_Show(hndl, glbBackgroundType);
005008  000156                                      gfx_Clipping(OFF);
005009  000157                                  else
005010  000158                                      // We check we want to increase the value between two save in the SD card
005011  000159                                      if(isDotInBox(xtouched, ytouched, 240, 120, 50, 30))
005012  000160                                          glbFrequenceSaveData += 1;
005013  000161                                          glbFrequenceSaveData := (glbFrequenceSaveData > 99) ? 5 : glbFrequenceSaveData;
005014  000162        
005015  000163                                          // We update only the needed part
005016  000164                                          myClipWindow(205, 120, 50, 30);
005017  000165                                          gfx_Clipping(ON);
005018  000166                                          img_Show(hndl, glbBackgroundType);
005019  000167                                          gfx_Clipping(OFF);
005020  000168                                      else
005021  000169                                          // The user pressed the bottom arrow to go to the pannel 1 (updating the time and date)
005022  000170                                          if(isDotInBox(xtouched, ytouched, 160, 190, 160, 50))
005023  000171                                               settingScreen.stateSetting := 1;
005024  000172                                               loop := 0; // We go out of the while loop
005025  000173                                          endif
005026  000174                                      endif
005027  000175                                  endif
005028  000176                              endif
005029  000177                          endif
005030  000178                      endif
005031  000179                  endif
005032  000180              endif
005033  000181          endif
005034  000182      wend
005035  000183  endfunc
005036  000184        
005037  000185  // This function permit to adjust the time and the dates
005038  000186  func settingPannel1()
005039  000187      var loop := 1;
005040  000188      var xtouched, ytouched;
005041  000189      var month;
005042  000190      var day;
005043  000191        
005044  000192      // We diaply the back button (go back to the menu pannel)
005045  000193      img_Show(hndl, IMAGE_BACK);
005046  000194      // We draw the template of this setting screen (many arrows)
005047  000195      img_Show(hndl, IMAGE_SETTING_1);
005048  000196        
005049  000197      // We diaply only the rigth arrow of the button that permit to toogle between the two pannels
005050  000198      myClipWindow(0, 200, 160, 50);
005051  000199      gfx_Clipping(ON);
005052  000200      img_Show(hndl, IMAGE_BTN_TOOGLE );
005053  000201      gfx_Clipping(OFF);
005054  000202        
005055  000203      // We draw circles that permits to know in which pannel you are
005056  000204      gfx_Circle(150, 222, 4, WHITE);
005057  000205      gfx_CircleFilled(170, 222, 4, WHITE);
005058  000206        
005059  000207      // We get the current value for the month and the day
005060  000208      month := glbDateTime[U_MONTH] + glbDateTime[D_MONTH]*10 - 1; // "-1" because we want our months to go from 0 to 11 (instead of 1 to 12)
005061  000209      day := glbDateTime[U_DAY] + glbDateTime[D_DAY]*10;
005062  000210        
005063  000211      while(1 == loop)
005064  000212          // Drawing the hour
005065  000213          drawDigit(80, 63, glbDateTime[D_HOUR], IMAGE_DIGIT_BIG);
005066  000214          drawDigit(110, 63, glbDateTime[U_HOUR], IMAGE_DIGIT_BIG);
005067  000215          drawDigit(170, 63, glbDateTime[D_MINUTES], IMAGE_DIGIT_BIG);
005068  000216          drawDigit(202, 63, glbDateTime[U_MINUTES], IMAGE_DIGIT_BIG);
005069  000217        
005070  000218          // Drawing the month
005071  000219          img_SetWord(hndl, IMAGE_MONTH, IMAGE_INDEX, month);
005072  000220          img_SetPosition(hndl, IMAGE_MONTH, 113,132);
005073  000221          img_Show(hndl, IMAGE_MONTH);
005074  000222        
005075  000223          // Drawing the day
005076  000224          if(day > 9) // To not display the 0 if the day is below 10 (to get "5" instead of "05")
005077  000225              drawDigit(145, 173, (day/10)%10,IMAGE_DIGIT_SMALL);
005078  000226              drawDigit(160, 173, day%10,IMAGE_DIGIT_SMALL);
005079  000227          else
005080  000228              drawDigit(153, 173, day%10,IMAGE_DIGIT_SMALL);
005081  000229          endif
005082  000230        
005083  000231          // We check if an interaction occured
005084  000232          if(getTouchStatus() == TOUCH_PRESSED)
005085  000233              // We get the X and Y coordinates of the touched point
005086  000234              xtouched := touch_Get(TOUCH_GETX);
005087  000235              ytouched := touch_Get(TOUCH_GETY);
005088  000236        
005089  000237              // We save data in the RTC when the back button is pressed
005090  000238              if(isDotInBox(xtouched, ytouched,0,0,80,42))  // Back button
005091  000239                  // We change the state of the display : we go back to the menu screen
005092  000240                  glbStateDispaly := STATE_MENU_SCREEN;
005093  000241                  // We go out of the while loop
005094  000242                  loop := 0;
005095  000243        
005096  000244                  // We get the value of the day
005097  000245                  glbDateTime[D_DAY] := day / 10;
005098  000246                  glbDateTime[U_DAY] := day % 10;
005099  000247        
005100  000248                  // We get the value of the month
005101  000249                  glbDateTime[D_MONTH] := (month+1) / 10;
005102  000250                  glbDateTime[U_MONTH] := (month+1) % 10;
005103  000251        
005104  000252                  // And we save those data in the RTC
005105  000253                  setDateTimeI2C();
005106  000254              else
005107  000255                  // Now we check if one arrow has been pressed
005108  000256        
005109  000257                  // Hour tens
005110  000258                  if(isDotInBox(xtouched, ytouched,86,25,28,50))  // Up D_HOUR
005111  000259                      glbDateTime[D_HOUR] ++;
005112  000260                      glbDateTime[D_HOUR] := (glbDateTime[D_HOUR] > 2)  ? 0 : glbDateTime[D_HOUR];
005113  000261        
005114  000262                      myClipWindow(80, 63, 40, 40);
005115  000263                      gfx_Clipping(ON);
005116  000264                      img_Show(hndl, glbBackgroundType);
005117  000265                      gfx_Clipping(OFF);
005118  000266                  endif
005119  000267                  if(isDotInBox(xtouched, ytouched,86,94,28,40))  // Down D_HOUR
005120  000268                      glbDateTime[D_HOUR] --;
005121  000269                      glbDateTime[D_HOUR] := (glbDateTime[D_HOUR] < 0)  ? 2 : glbDateTime[D_HOUR];
005122  000270        
005123  000271                      myClipWindow(80, 63, 40, 40);
005124  000272                      gfx_Clipping(ON);
005125  000273                      img_Show(hndl, glbBackgroundType);
005126  000274                      gfx_Clipping(OFF);
005127  000275                  endif
005128  000276        
005129  000277                  // Hour units
005130  000278                  if(isDotInBox(xtouched, ytouched,116,25,28,50))  // Up U_HOUR
005131  000279                      glbDateTime[U_HOUR] ++;
005132  000280                      glbDateTime[U_HOUR] := (glbDateTime[U_HOUR] > 9 || (glbDateTime[U_HOUR] > 3 && glbDateTime[D_HOUR] == 2))  ? 0 : glbDateTime[U_HOUR];
005133  000281        
005134  000282                      myClipWindow(110, 63, 40, 40);
005135  000283                      gfx_Clipping(ON);
005136  000284                      img_Show(hndl, glbBackgroundType);
005137  000285                      gfx_Clipping(OFF);
005138  000286                  endif
005139  000287                  if(isDotInBox(xtouched, ytouched,116,94,28,40))  // Down U_HOUR
005140  000288                      glbDateTime[U_HOUR] --;
005141  000289                      glbDateTime[U_HOUR] := (glbDateTime[U_HOUR] < 0)  ? ((glbDateTime[D_HOUR] == 2) ? 3 : 9) : glbDateTime[U_HOUR];
005142  000290        
005143  000291                      myClipWindow(110, 63, 40, 40);
005144  000292                      gfx_Clipping(ON);
005145  000293                      img_Show(hndl, glbBackgroundType);
005146  000294                      gfx_Clipping(OFF);
005147  000295                  endif
005148  000296        
005149  000297        
005150  000298                  // Minutes tens
005151  000299                  if(isDotInBox(xtouched, ytouched,175,25,28,50))  // Up D_MINUTES
005152  000300                      glbDateTime[D_MINUTES] ++;
005153  000301                      glbDateTime[D_MINUTES] := (glbDateTime[D_MINUTES] > 5)  ? 0 : glbDateTime[D_MINUTES];
005154  000302        
005155  000303                      myClipWindow(170, 63, 40, 40);
005156  000304                      gfx_Clipping(ON);
005157  000305                      img_Show(hndl, glbBackgroundType);
005158  000306                      gfx_Clipping(OFF);
005159  000307                  endif
005160  000308                  if(isDotInBox(xtouched, ytouched,175,94,28,40))  // Down D_MINUTES
005161  000309                      glbDateTime[D_MINUTES] --;
005162  000310                      glbDateTime[D_MINUTES] := (glbDateTime[D_MINUTES] < 0)  ? 5 : glbDateTime[D_MINUTES];
005163  000311        
005164  000312                      myClipWindow(170, 63, 40, 40);
005165  000313                      gfx_Clipping(ON);
005166  000314                      img_Show(hndl, glbBackgroundType);
005167  000315                      gfx_Clipping(OFF);
005168  000316                  endif
005169  000317        
005170  000318                  // Minutes units
005171  000319                  if(isDotInBox(xtouched, ytouched,205,25,28,50))  // Up U_MIN
005172  000320                      glbDateTime[U_MINUTES] ++;
005173  000321                      glbDateTime[U_MINUTES] := (glbDateTime[U_MINUTES] > 9)  ? 0 : glbDateTime[U_MINUTES];
005174  000322        
005175  000323                      myClipWindow(202, 63, 40, 40);
005176  000324                      gfx_Clipping(ON);
005177  000325                      img_Show(hndl, glbBackgroundType);
005178  000326                      gfx_Clipping(OFF);
005179  000327                  endif
005180  000328                  if(isDotInBox(xtouched, ytouched,205,94,28,40))  // Down U_MIN
005181  000329                      glbDateTime[U_MINUTES] --;
005182  000330                      glbDateTime[U_MINUTES] := (glbDateTime[U_MINUTES] < 0)  ? 9 : glbDateTime[U_MINUTES];
005183  000331        
005184  000332                      myClipWindow(202, 63, 40, 40);
005185  000333                      gfx_Clipping(ON);
005186  000334                      img_Show(hndl, glbBackgroundType);
005187  000335                      gfx_Clipping(OFF);
005188  000336                  endif
005189  000337        
005190  000338        
005191  000339                  // Month
005192  000340                  if(isDotInBox(xtouched, ytouched,76,136,50,28))  // Down U_MONTH
005193  000341                      month --;
005194  000342                      month := (month < 0)  ? 11 : month;
005195  000343        
005196  000344                      myClipWindow(110, 136, 105, 36);
005197  000345                      gfx_Clipping(ON);
005198  000346                      img_Show(hndl, glbBackgroundType);
005199  000347                      gfx_Clipping(OFF);
005200  000348                  endif
005201  000349                  if(isDotInBox(xtouched, ytouched,198,136,50,28))  // Up U_MONTH
005202  000350                      month ++;
005203  000351                      month := (month > 11)  ? 0 : month;
005204  000352        
005205  000353                      myClipWindow(110, 136, 105, 36);
005206  000354                      gfx_Clipping(ON);
005207  000355                      img_Show(hndl, glbBackgroundType);
005208  000356                      gfx_Clipping(OFF);
005209  000357                  endif
005210  000358        
005211  000359                  // Day
005212  000360                  if(isDotInBox(xtouched, ytouched,76,166,50,28))  // Down U_DAY
005213  000361                      day --;
005214  000362                      day := (day < 1)  ? ((month % 2 == 0) ? 31 : ((month == 1) ? 29 : 30)) : day;
005215  000363        
005216  000364                      myClipWindow(110, 166, 105, 36);
005217  000365                      gfx_Clipping(ON);
005218  000366                      img_Show(hndl, glbBackgroundType);
005219  000367                      gfx_Clipping(OFF);
005220  000368                  endif
005221  000369                  if(isDotInBox(xtouched, ytouched,198,166,50,28))  // Up U_DAY
005222  000370                      day ++;
005223  000371                      day := ((day > 31 && month % 2 ==0) || (day > 30 && month % 2 == 1) || (day > 29 && month == 1))  ? 0 : day;
005224  000372        
005225  000373                      myClipWindow(110, 166, 105, 36);
005226  000374                      gfx_Clipping(ON);
005227  000375                      img_Show(hndl, glbBackgroundType);
005228  000376                      gfx_Clipping(OFF);
005229  000377                  endif
005230  000378        
005231  000379                  // The user pressed the bottom arrow to go to the pannel 0 (basic settings)
005232  000380                  if(isDotInBox(xtouched, ytouched, 0, 190, 160, 50))
005233  000381                      settingScreen.stateSetting := 0;
005234  000382                      loop := 0; // We go out of the while loop
005235  000383                  endif
005236  000384              endif
005237  000385          endif
005238  000386      wend
005239  000387  endfunc
005240  000388        
005241  000026        
005242  000027  func main()
005243  000028        
005244  000029      // Infinite loop
005245  000030      repeat
005246  000031          mainStateGraph();
005247  000032      forever
005248  000033        
005249  000034  endfunc
Notice: local var 'ret' in func 'RTCWrite' is never used (line 576 file:myFunctions.fnc)
Notice: no execution path to func 'boxTouched'
Notice: no execution path to func 'bigprint'
Notice: local var 'p' in func 'getHumidityI2C' is never used (line 397 file:myFunctions.fnc)
Notice: local var 'p' in func 'getTempI2C' is never used (line 359 file:myFunctions.fnc)
Notice: variable 'array' is being indexed (line 323 file:myFunctionsDisplay.fnc)
Notice: variable 'array' is being indexed (line 326 file:myFunctionsDisplay.fnc)
Notice: variable 'array' is being indexed (line 327 file:myFunctionsDisplay.fnc)
Notice: variable 'array' is being indexed (line 305 file:myFunctionsDisplay.fnc)
Notice: variable 'array' is being indexed (line 309 file:myFunctionsDisplay.fnc)
Notice: variable 'array' is being indexed (line 310 file:myFunctionsDisplay.fnc)
Notice: no execution path to func 'STOP'
Notice: no execution path to func 'readAllOnSD'
Notice: no execution path to func 'setDown'
Notice: function argument 'n' in func 'report' is never used (line 19 file:myFunctions.fnc)
Notice: variable 'points' is being indexed (line 317 file:myFunctionsDisplay.fnc)
Notice: no execution path to func 'myRectangle'


Symbol Table:
name                             decimal         hex
_1F                                  -40  0xffffffd8 (PmmC func) args[0] r=0  (not used)
__MAXMEM                           14400  0x00003840 (const dword)  (usage 1)
__MAXPROG                          14400  0x00003840 (const dword)  (usage 1)
__PLATFORM                             1  0x00000001 (const dword)  (not used)
ABS                                  -13  0xfffffff3 (PmmC func) args[1] r=1  (not used)
ALICEBLUE                          63455  0x0000f7df (const dword)  (not used)
ALL                                65535  0x0000ffff (const dword)  (not used)
ANTIQUEWHITE                       65370  0x0000ff5a (const dword)  (not used)
APPEND                                 0  0x00000000 (const dword)  (not used)
AQUA                                2047  0x000007ff (const dword)  (not used)
AQUAMARINE                         32762  0x00007ffa (const dword)  (not used)
AUDIO_ENABLE                           7  0x00000007 (const dword)  (not used)
autoSaveData                        4838  0x000012e6 (User func) args[0] r=0  (usage 3)
autoSaveData.iCpt                    128  0x00000080 (mem) word (member of autoSaveData)  (usage 4)
AZURE                              63487  0x0000f7ff (const dword)  (not used)
BACKGROUND_COLOUR                     17  0x00000011 (const dword)  (not used)
BACKLITE                               6  0x00000006 (const dword)  (not used)
BAUD_110                               0  0x00000000 (const dword)  (not used)
BAUD_115200                           13  0x0000000d (const dword)  (not used)
BAUD_1200                              3  0x00000003 (const dword)  (not used)
BAUD_128000                           14  0x0000000e (const dword)  (not used)
BAUD_14400                             7  0x00000007 (const dword)  (not used)
BAUD_19200                             8  0x00000008 (const dword)  (not used)
BAUD_2400                              4  0x00000004 (const dword)  (not used)
BAUD_256000                           15  0x0000000f (const dword)  (not used)
BAUD_300                               1  0x00000001 (const dword)  (not used)
BAUD_300000                           16  0x00000010 (const dword)  (not used)
BAUD_31250                             9  0x00000009 (const dword)  (not used)
BAUD_375000                           17  0x00000011 (const dword)  (not used)
BAUD_38400                            10  0x0000000a (const dword)  (not used)
BAUD_4800                              5  0x00000005 (const dword)  (not used)
BAUD_500000                           18  0x00000012 (const dword)  (not used)
BAUD_56000                            11  0x0000000b (const dword)  (not used)
BAUD_57600                            12  0x0000000c (const dword)  (not used)
BAUD_600                               2  0x00000002 (const dword)  (not used)
BAUD_600000                           19  0x00000013 (const dword)  (not used)
BAUD_9600                              6  0x00000006 (const dword)  (not used)
BEIGE                              63419  0x0000f7bb (const dword)  (not used)
BEVEL_SHADOW                          29  0x0000001d (const dword)  (not used)
BEVEL_WIDTH                           28  0x0000001c (const dword)  (not used)
bigprint                          UNRESOLVED (User func) args[1] r=0  (not used)
BIN                                    2  0x00000002 (const dword)  (not used)
BIN1                                 258  0x00000102 (const dword)  (not used)
BIN10                               2562  0x00000a02 (const dword)  (not used)
BIN10Z                              6658  0x00001a02 (const dword)  (not used)
BIN10ZB                            10754  0x00002a02 (const dword)  (not used)
BIN11                               2818  0x00000b02 (const dword)  (not used)
BIN11Z                              6914  0x00001b02 (const dword)  (not used)
BIN11ZB                            11010  0x00002b02 (const dword)  (not used)
BIN12                               3074  0x00000c02 (const dword)  (not used)
BIN12Z                              7170  0x00001c02 (const dword)  (not used)
BIN12ZB                            11266  0x00002c02 (const dword)  (not used)
BIN13                               3330  0x00000d02 (const dword)  (not used)
BIN13Z                              7426  0x00001d02 (const dword)  (not used)
BIN13ZB                            11522  0x00002d02 (const dword)  (not used)
BIN14                               3586  0x00000e02 (const dword)  (not used)
BIN14Z                              7682  0x00001e02 (const dword)  (not used)
BIN14ZB                            11778  0x00002e02 (const dword)  (not used)
BIN15                               3842  0x00000f02 (const dword)  (not used)
BIN15Z                              7938  0x00001f02 (const dword)  (not used)
BIN15ZB                            12034  0x00002f02 (const dword)  (not used)
BIN16                                  2  0x00000002 (const dword)  (not used)
BIN16Z                              4098  0x00001002 (const dword)  (not used)
BIN16ZB                             8194  0x00002002 (const dword)  (not used)
BIN1Z                               4354  0x00001102 (const dword)  (not used)
BIN1ZB                              8450  0x00002102 (const dword)  (not used)
BIN2                                 514  0x00000202 (const dword)  (not used)
BIN2Z                               4610  0x00001202 (const dword)  (not used)
BIN2ZB                              8706  0x00002202 (const dword)  (not used)
BIN3                                 770  0x00000302 (const dword)  (not used)
BIN3Z                               4866  0x00001302 (const dword)  (not used)
BIN3ZB                              8962  0x00002302 (const dword)  (not used)
BIN4                                1026  0x00000402 (const dword)  (not used)
BIN4Z                               5122  0x00001402 (const dword)  (not used)
BIN4ZB                              9218  0x00002402 (const dword)  (not used)
BIN5                                1282  0x00000502 (const dword)  (not used)
BIN5Z                               5378  0x00001502 (const dword)  (not used)
BIN5ZB                              9474  0x00002502 (const dword)  (not used)
BIN6                                1538  0x00000602 (const dword)  (not used)
BIN6Z                               5634  0x00001602 (const dword)  (not used)
BIN6ZB                              9730  0x00002602 (const dword)  (not used)
BIN7                                1794  0x00000702 (const dword)  (not used)
BIN7Z                               5890  0x00001702 (const dword)  (not used)
BIN7ZB                              9986  0x00002702 (const dword)  (not used)
BIN8                                2050  0x00000802 (const dword)  (not used)
BIN8Z                               6146  0x00001802 (const dword)  (not used)
BIN8ZB                             10242  0x00002802 (const dword)  (not used)
BIN9                                2306  0x00000902 (const dword)  (not used)
BIN9Z                               6402  0x00001902 (const dword)  (not used)
BIN9ZB                             10498  0x00002902 (const dword)  (not used)
BINZ                                4098  0x00001002 (const dword)  (not used)
BINZB                               8194  0x00002002 (const dword)  (not used)
BISQUE                             65336  0x0000ff38 (const dword)  (not used)
BLACK                                  0  0x00000000 (const dword)  (usage 2)
BLANCHEDALMOND                     65369  0x0000ff59 (const dword)  (not used)
BLUE                                  31  0x0000001f (const dword)  (not used)
BLUEVIOLET                         35164  0x0000895c (const dword)  (not used)
BOLD                                  16  0x00000010 (const dword)  (not used)
BOTTOM_POS                             5  0x00000005 (const dword)  (not used)
boxTouched                        UNRESOLVED (User func) args[4] r=0  (not used)
BROWN                              41285  0x0000a145 (const dword)  (not used)
BURLYWOOD                          56784  0x0000ddd0 (const dword)  (not used)
BUS_0                                  8  0x00000008 (const dword)  (not used)
BUS_1                                  9  0x00000009 (const dword)  (not used)
BUS_2                                 10  0x0000000a (const dword)  (not used)
BUS_3                                 11  0x0000000b (const dword)  (not used)
BUS_4                                 12  0x0000000c (const dword)  (not used)
BUS_5                                 13  0x0000000d (const dword)  (not used)
BUS_6                                 14  0x0000000e (const dword)  (not used)
BUS_7                                 15  0x0000000f (const dword)  (not used)
bus_In                               -45  0xffffffd3 (PmmC func) args[0] r=1  (not used)
bus_Out                              -46  0xffffffd2 (PmmC func) args[1] r=0  (not used)
BUS_RD_PIN                             4  0x00000004 (const dword)  (not used)
bus_Read                             -49  0xffffffcf (PmmC func) args[0] r=1  (not used)
bus_Set                              -47  0xffffffd1 (PmmC func) args[1] r=0  (not used)
BUS_WR_PIN                             5  0x00000005 (const dword)  (not used)
bus_Write                            -48  0xffffffd0 (PmmC func) args[1] r=0  (not used)
BUTTON_DOWN                            0  0x00000000 (const dword)  (not used)
BUTTON_UP                              1  0x00000001 (const dword)  (not used)
ByteSwap                            -215  0xffffff29 (PmmC func) args[1] r=1  (not used)
C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg    2805  0x00000af5 (const ??? 0)  (not used)
CADETBLUE                          23796  0x00005cf4 (const dword)  (not used)
charheight                          -159  0xffffff61 (PmmC func) args[1] r=1  (not used)
CHARTREUSE                         32736  0x00007fe0 (const dword)  (not used)
charwidth                           -158  0xffffff62 (PmmC func) args[1] r=1  (not used)
CHOCOLATE                          54083  0x0000d343 (const dword)  (not used)
CHR                                  129  0x00000081 (const dword)  (not used)
CKMODE_0                               0  0x00000000 (const dword)  (not used)
CKMODE_1                               1  0x00000001 (const dword)  (not used)
CKMODE_2                               2  0x00000002 (const dword)  (not used)
CKMODE_3                               3  0x00000003 (const dword)  (not used)
CLIPPING                              19  0x00000013 (const dword)  (not used)
COLOUR16                               0  0x00000000 (const dword)  (not used)
COLOUR8                                1  0x00000001 (const dword)  (not used)
COLOUR_MODE                           27  0x0000001b (const dword)  (not used)
COLUMN_ADDRESS_END1                    5  0x00000005 (const dword)  (not used)
COLUMN_ADDRESS_END2                    4  0x00000004 (const dword)  (not used)
COLUMN_ADDRESS_START1                  3  0x00000003 (const dword)  (not used)
COLUMN_ADDRESS_START2                  2  0x00000002 (const dword)  (not used)
COM0                               63492  0x0000f804 (const dword)  (not used)
COM1                               63496  0x0000f808 (const dword)  (not used)
com1_Count                          -132  0xffffff7c (PmmC func) args[0] r=1  (not used)
com1_Error                          -134  0xffffff7a (PmmC func) args[0] r=1  (not used)
com1_Full                           -133  0xffffff7b (PmmC func) args[0] r=1  (not used)
com1_Init                           -130  0xffffff7e (PmmC func) args[3] r=0  (not used)
com1_Reset                          -131  0xffffff7d (PmmC func) args[0] r=0  (not used)
com1_Sync                           -135  0xffffff79 (PmmC func) args[0] r=1  (not used)
com1_TXbuffer                       -136  0xffffff78 (PmmC func) args[3] r=0  (not used)
com1_TXbufferHold                   -139  0xffffff75 (PmmC func) args[1] r=1  (not used)
com1_TXcount                        -137  0xffffff77 (PmmC func) args[0] r=1  (not used)
com1_TXemptyEvent                   -138  0xffffff76 (PmmC func) args[1] r=1  (not used)
com_Count                           -122  0xffffff86 (PmmC func) args[0] r=1  (not used)
com_Error                           -124  0xffffff84 (PmmC func) args[0] r=1  (not used)
com_Full                            -123  0xffffff85 (PmmC func) args[0] r=1  (not used)
com_Init                            -120  0xffffff88 (PmmC func) args[3] r=0  (not used)
com_Reset                           -121  0xffffff87 (PmmC func) args[0] r=0  (not used)
com_SetBaud                         -142  0xffffff72 (PmmC func) args[2] r=1  (not used)
com_Sync                            -125  0xffffff83 (PmmC func) args[0] r=1  (not used)
com_TXbuffer                        -126  0xffffff82 (PmmC func) args[3] r=0  (not used)
com_TXbufferHold                    -129  0xffffff7f (PmmC func) args[1] r=1  (not used)
com_TXcount                         -127  0xffffff81 (PmmC func) args[0] r=1  (not used)
com_TXemptyEvent                    -128  0xffffff80 (PmmC func) args[1] r=1  (not used)
CONTRAST                              25  0x00000019 (const dword)  (not used)
CORAL                              64490  0x0000fbea (const dword)  (not used)
CORNFLOWERBLUE                     25789  0x000064bd (const dword)  (not used)
CORNSILK                           65499  0x0000ffdb (const dword)  (not used)
COS                                  -18  0xffffffee (PmmC func) args[1] r=1  (not used)
cpt                               UNRESOLVED  (usage 13)
CRIMSON                            55463  0x0000d8a7 (const dword)  (not used)
CY                                  -285  0xfffffee3 (PmmC func) args[0] r=1  (not used)
CYAN                                2047  0x000007ff (const dword)  (not used)
CYCLE_CONTROL_1                       58  0x0000003a (const dword)  (not used)
CYCLE_CONTROL_2                       59  0x0000003b (const dword)  (not used)
CYCLE_CONTROL_3                       60  0x0000003c (const dword)  (not used)
CYCLE_CONTROL_4                       61  0x0000003d (const dword)  (not used)
CYCLE_CONTROL_5                       62  0x0000003e (const dword)  (not used)
CYCLE_CONTROL_6                       64  0x00000040 (const dword)  (not used)
D_DAY                                  7  0x00000007 (const dword)  (usage 18)
D_HOUR                                 5  0x00000005 (const dword)  (usage 45)
D_MINUTES                              3  0x00000003 (const dword)  (usage 39)
D_MONTH                                9  0x00000009 (const dword)  (usage 18)
D_SECONDES                             1  0x00000001 (const dword)  (usage 6)
D_YEAR                                11  0x0000000b (const dword)  (usage 3)
DARKBLUE                              17  0x00000011 (const dword)  (not used)
DARKCYAN                            1105  0x00000451 (const dword)  (not used)
DARKGOLDENROD                      48161  0x0000bc21 (const dword)  (not used)
DARKGRAY                           44373  0x0000ad55 (const dword)  (not used)
DARKGREEN                            800  0x00000320 (const dword)  (not used)
DARKKHAKI                          48557  0x0000bdad (const dword)  (not used)
DARKMAGENTA                        34833  0x00008811 (const dword)  (not used)
DARKOLIVEGREEN                     21317  0x00005345 (const dword)  (not used)
DARKORANGE                         64608  0x0000fc60 (const dword)  (not used)
DARKORCHID                         39321  0x00009999 (const dword)  (not used)
DARKRED                            34816  0x00008800 (const dword)  (not used)
DARKSALMON                         60591  0x0000ecaf (const dword)  (not used)
DARKSEAGREEN                       36337  0x00008df1 (const dword)  (not used)
DARKSLATEBLUE                      18929  0x000049f1 (const dword)  (not used)
DARKSLATEGRAY                      10857  0x00002a69 (const dword)  (not used)
DARKTURQUOISE                       1658  0x0000067a (const dword)  (not used)
DARKVIOLET                         36890  0x0000901a (const dword)  (not used)
DEC                                 1290  0x0000050a (const dword)  (not used)
DEC1                                 266  0x0000010a (const dword)  (not used)
DEC1Z                               4362  0x0000110a (const dword)  (not used)
DEC1ZB                              8458  0x0000210a (const dword)  (not used)
DEC2                                 522  0x0000020a (const dword)  (not used)
DEC2Z                               4618  0x0000120a (const dword)  (not used)
DEC2ZB                              8714  0x0000220a (const dword)  (not used)
DEC3                                 778  0x0000030a (const dword)  (not used)
DEC3Z                               4874  0x0000130a (const dword)  (not used)
DEC3ZB                              8970  0x0000230a (const dword)  (not used)
DEC4                                1034  0x0000040a (const dword)  (not used)
DEC4Z                               5130  0x0000140a (const dword)  (not used)
DEC4ZB                              9226  0x0000240a (const dword)  (not used)
DEC5                                1290  0x0000050a (const dword)  (not used)
DEC5Z                               5386  0x0000150a (const dword)  (not used)
DEC5ZB                              9482  0x0000250a (const dword)  (not used)
DECZ                                5386  0x0000150a (const dword)  (not used)
DECZB                               9482  0x0000250a (const dword)  (not used)
DEEPPINK                           63666  0x0000f8b2 (const dword)  (not used)
DEEPSKYBLUE                         1535  0x000005ff (const dword)  (not used)
DIGIT_CELCIUS                         11  0x0000000b (const dword)  (usage 6)
DIGIT_COMA                            16  0x00000010 (const dword)  (usage 9)
DIGIT_FAHRENHEIT                      12  0x0000000c (const dword)  (usage 6)
DIGIT_MAX                             16  0x00000010 (const dword)  (usage 3)
DIGIT_MINUS                           14  0x0000000e (const dword)  (usage 12)
DIGIT_PERCENT                         10  0x0000000a (const dword)  (usage 9)
DIGIT_SLASH                           15  0x0000000f (const dword)  (usage 3)
DIGIT_TWO_DOTS                        13  0x0000000d (const dword)  (usage 6)
DIMGRAY                            27469  0x00006b4d (const dword)  (not used)
DISABLE                                0  0x00000000 (const dword)  (not used)
DISK_BUF                              15  0x0000000f (const dword)  (not used)
DISK_DATA_HI                           7  0x00000007 (const dword)  (not used)
DISK_DATA_LO                           6  0x00000006 (const dword)  (not used)
DISK_FAT_HI                            3  0x00000003 (const dword)  (not used)
DISK_FAT_LO                            2  0x00000002 (const dword)  (not used)
DISK_FATCOPIES                        12  0x0000000c (const dword)  (not used)
DISK_FATSIZE                          11  0x0000000b (const dword)  (not used)
DISK_FIRST_SECT_HI                     1  0x00000001 (const dword)  (not used)
DISK_FIRST_SECT_LO                     0  0x00000000 (const dword)  (not used)
DISK_MAXCLUS_HI                        9  0x00000009 (const dword)  (not used)
DISK_MAXCLUS_LO                        8  0x00000008 (const dword)  (not used)
DISK_MAXROOT                          10  0x0000000a (const dword)  (not used)
DISK_ROOT_HI                           5  0x00000005 (const dword)  (not used)
DISK_ROOT_LO                           4  0x00000004 (const dword)  (not used)
DISK_SECT_PER_CLUS                    13  0x0000000d (const dword)  (not used)
DISK_TYPE                             14  0x0000000e (const dword)  (not used)
disp_Disconnect                     -293  0xfffffedb (PmmC func) args[0] r=0  (not used)
disp_Init                           -143  0xffffff71 (PmmC func) args[0] r=0  (not used)
disp_ReadWord                       -149  0xffffff6b (PmmC func) args[0] r=1  (not used)
disp_setGRAM                        -145  0xffffff6f (PmmC func) args[4] r=0  (not used)
disp_SetReg                         -144  0xffffff70 (PmmC func) args[2] r=0  (not used)
disp_Sync                           -284  0xfffffee4 (PmmC func) args[1] r=0  (not used)
disp_WrGRAM                         -146  0xffffff6e (PmmC func) args[1] r=0  (not used)
disp_WriteControl                   -147  0xffffff6d (PmmC func) args[1] r=0  (not used)
disp_WriteWord                      -148  0xffffff6c (PmmC func) args[1] r=0  (not used)
DISPLAY_CONTROL_1                     38  0x00000026 (const dword)  (not used)
DISPLAY_CONTROL_10                    54  0x00000036 (const dword)  (not used)
DISPLAY_CONTROL_14                    65  0x00000041 (const dword)  (not used)
DISPLAY_CONTROL_2                     39  0x00000027 (const dword)  (not used)
DISPLAY_CONTROL_3                     40  0x00000028 (const dword)  (not used)
DISPLAY_CONTROL_4                     41  0x00000029 (const dword)  (not used)
DISPLAY_CONTROL_5                     42  0x0000002a (const dword)  (not used)
DISPLAY_CONTROL_6                     44  0x0000002c (const dword)  (not used)
DISPLAY_CONTROL_7                     45  0x0000002d (const dword)  (not used)
DISPLAY_CONTROL_8                    144  0x00000090 (const dword)  (not used)
DISPLAY_CONTROL_9                     53  0x00000035 (const dword)  (not used)
DISPLAY_MODE_CONTROL                   1  0x00000001 (const dword)  (not used)
DODGERBLUE                          7327  0x00001c9f (const dword)  (not used)
DOWN                                   0  0x00000000 (const dword)  (not used)
drawClock                           9119  0x0000239f (User func) args[1] r=0  (usage 6)
drawClock.olddhour                    66  0x00000042 (mem) word (member of drawClock)  (usage 3)
drawClock.olddmin                     62  0x0000003e (mem) word (member of drawClock)  (usage 3)
drawClock.olddsec                     58  0x0000003a (mem) word (member of drawClock)  (usage 3)
drawClock.olduhour                    64  0x00000040 (mem) word (member of drawClock)  (usage 3)
drawClock.oldumin                     60  0x0000003c (mem) word (member of drawClock)  (usage 3)
drawClock.oldusec                     56  0x00000038 (mem) word (member of drawClock)  (usage 3)
drawDate                            9844  0x00002674 (User func) args[0] r=0  (usage 3)
drawDigit                           9979  0x000026fb (User func) args[4] r=0  (usage 159)
drawGraph                           7708  0x00001e1c (User func) args[1] r=0  (usage 3)
drawHistoric                        7346  0x00001cb2 (User func) args[2] r=0  (usage 6)
drawHygro                           7378  0x00001cd2 (User func) args[0] r=0  (usage 3)
drawList                            8508  0x0000213c (User func) args[1] r=0  (usage 3)
drawSettingButton                   7234  0x00001c42 (User func) args[0] r=0  (usage 3)
drawTemp                            7475  0x00001d33 (User func) args[0] r=0  (usage 3)
DSK                                63490  0x0000f802 (const dword)  (not used)
ENABLE                                 1  0x00000001 (const dword)  (not used)
EVE_SP                              -282  0xfffffee6 (PmmC func) args[0] r=1  (not used)
EVE_SSIZE                           -283  0xfffffee5 (PmmC func) args[0] r=1  (not used)
FE_CANNOT_INIT                        15  0x0000000f (const dword)  (not used)
FE_CANNOT_READ_MBR                    16  0x00000010 (const dword)  (not used)
FE_DIR_FULL                           12  0x0000000c (const dword)  (not used)
FE_DISK_FULL                          13  0x0000000d (const dword)  (not used)
FE_DISK_NOT_MNTD                       6  0x00000006 (const dword)  (not used)
FE_EOF                                10  0x0000000a (const dword)  (not used)
FE_FAT_EOF                             9  0x00000009 (const dword)  (not used)
FE_FILE_NOT_FOUND                      7  0x00000007 (const dword)  (not used)
FE_FILE_OVERWRITE                     14  0x0000000e (const dword)  (not used)
FE_FILE_TIMEOUT                       26  0x0000001a (const dword)  (not used)
FE_FIND_ERROR                         19  0x00000013 (const dword)  (not used)
FE_IDE_ERROR                           1  0x00000001 (const dword)  (not used)
FE_INVALID_BR                          5  0x00000005 (const dword)  (not used)
FE_INVALID_CLUSTER                    11  0x0000000b (const dword)  (not used)
FE_INVALID_FILE                        8  0x00000008 (const dword)  (not used)
FE_INVALID_FNAME                      20  0x00000014 (const dword)  (not used)
FE_INVALID_MBR                         4  0x00000004 (const dword)  (not used)
FE_INVALID_MEDIA                      21  0x00000015 (const dword)  (not used)
FE_INVALID_MODE                       18  0x00000012 (const dword)  (not used)
FE_MALLOC_FAILED                      17  0x00000011 (const dword)  (not used)
FE_NOT_PRESENT                         2  0x00000002 (const dword)  (not used)
FE_OK                                  0  0x00000000 (const dword)  (not used)
FE_PARTITION_TYPE                      3  0x00000003 (const dword)  (not used)
FE_SECTOR_READ_FAIL                   22  0x00000016 (const dword)  (not used)
FE_SECTOR_WRITE_FAIL                  23  0x00000017 (const dword)  (not used)
FECANNOTINIT                         434  0x000001b2FECANNOTINIT                         434  0x000001b2 (mem) byte[21] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FECANNOTINIT                      UNRESOLVED  (usage 2)
FECANNOTREADMBR                      455  0x000001c7FECANNOTREADMBR                      455  0x000001c7 (mem) byte[20] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FECANNOTREADMBR                   UNRESOLVED  (usage 2)
FEDIRFULL                            333  0x0000014dFEDIRFULL                            333  0x0000014d (mem) byte[29] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FEDIRFULL                         UNRESOLVED  (usage 2)
FEEOF                                278  0x00000116FEEOF                                278  0x00000116 (mem) byte[24] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FEEOF                             UNRESOLVED  (usage 2)
FEFATEOF                             247  0x000000f7FEFATEOF                             247  0x000000f7 (mem) byte[31] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FEFATEOF                          UNRESOLVED  (usage 2)
FEFILENOTFOUND                       201  0x000000c9FEFILENOTFOUND                       201  0x000000c9 (mem) byte[32] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FEFILENOTFOUND                    UNRESOLVED  (usage 2)
FEFILEOVERWRITE                      398  0x0000018eFEFILEOVERWRITE                      398  0x0000018e (mem) byte[36] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FEFILEOVERWRITE                   UNRESOLVED  (usage 2)
FEFINDERROR                          535  0x00000217FEFINDERROR                          535  0x00000217 (mem) byte[27] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FEFINDERROR                       UNRESOLVED  (usage 2)
FEIDEERROR                            47  0x0000002fFEIDEERROR                            47  0x0000002f (mem) byte[28] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FEIDEERROR                        UNRESOLVED  (usage 2)
FEINVALIDBR                          153  0x00000099FEINVALIDBR                          153  0x00000099 (mem) byte[30] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FEINVALIDBR                       UNRESOLVED  (usage 2)
FEINVALIDCLUSTER                     302  0x0000012eFEINVALIDCLUSTER                     302  0x0000012e (mem) byte[31] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FEINVALIDCLUSTER                  UNRESOLVED  (usage 2)
FEINVALIDFILE                        233  0x000000e9FEINVALIDFILE                        233  0x000000e9 (mem) byte[14] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FEINVALIDFILE                     UNRESOLVED  (usage 2)
FEINVALIDMBR                         124  0x0000007cFEINVALIDMBR                         124  0x0000007c (mem) byte[29] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FEINVALIDMBR                      UNRESOLVED  (usage 2)
FEINVALIDMODE                        517  0x00000205FEINVALIDMODE                        517  0x00000205 (mem) byte[18] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FEINVALIDMODE                     UNRESOLVED  (usage 2)
FEINVALIDNAME                        562  0x00000232FEINVALIDNAME                        562  0x00000232 (mem) byte[13] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FEINVALIDNAME                     UNRESOLVED  (usage 2)
FEMALLOCFAILED                       475  0x000001dbFEMALLOCFAILED                       475  0x000001db (mem) byte[42] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FEMALLOCFAILED                    UNRESOLVED  (usage 2)
FEMEDIAFULL                          362  0x0000016aFEMEDIAFULL                          362  0x0000016a (mem) byte[36] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FEMEDIAFULL                       UNRESOLVED  (usage 2)
FEMEDIANOTMNTD                       183  0x000000b7FEMEDIANOTMNTD                       183  0x000000b7 (mem) byte[18] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FEMEDIANOTMNTD                    UNRESOLVED  (usage 2)
FENOTPRESENT                          75  0x0000004bFENOTPRESENT                          75  0x0000004b (mem) byte[17] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FENOTPRESENT                      UNRESOLVED  (usage 2)
FEPARTITIONTYPE                       92  0x0000005cFEPARTITIONTYPE                       92  0x0000005c (mem) byte[32] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (usage 1)
FEPARTITIONTYPE                   UNRESOLVED  (usage 2)
FILE_ATTRIBUTES                       18  0x00000012 (const dword)  (not used)
FILE_BUFFER                           22  0x00000016 (const dword)  (not used)
file_Close                          -232  0xffffff18 (PmmC func) args[1] r=1  (usage 8)
file_Count                          -226  0xffffff1e (PmmC func) args[1] r=1  (not used)
FILE_CURR_CLUSTER                      1  0x00000001 (const dword)  (not used)
FILE_CURR_SECTOR                       2  0x00000002 (const dword)  (not used)
FILE_CURR_SECTOR_POS                   3  0x00000003 (const dword)  (not used)
FILE_CURR_SECTOR_TOP                   4  0x00000004 (const dword)  (not used)
FILE_DATA                            N/A         N/A (macro) "DATA.TXT"   (usage 6)
FILE_DATE                             10  0x0000000a (const dword)  (not used)
file_Dir                            -227  0xffffff1d (PmmC func) args[1] r=1  (not used)
FILE_DISK                             21  0x00000015 (const dword)  (not used)
FILE_ENTRY                            20  0x00000014 (const dword)  (not used)
file_Erase                          -247  0xffffff09 (PmmC func) args[1] r=1  (not used)
file_Error                          -225  0xffffff1f (PmmC func) args[0] r=1  (not used)
file_Exec                           -251  0xffffff05 (PmmC func) args[2] r=1  (not used)
file_Exists                         -230  0xffffff1a (PmmC func) args[1] r=1  (usage 8)
file_FindFirst                      -228  0xffffff1c (PmmC func) args[1] r=1  (not used)
file_FindNext                       -229  0xffffff1b (PmmC func) args[0] r=1  (not used)
FILE_FIRST_CLUSTER                     0  0x00000000 (const dword)  (not used)
file_GetC                           -242  0xffffff0e (PmmC func) args[1] r=1  (not used)
file_GetS                           -246  0xffffff0a (PmmC func) args[3] r=1  (usage 3)
file_GetW                           -244  0xffffff0c (PmmC func) args[1] r=1  (not used)
file_Image                          -239  0xffffff11 (PmmC func) args[3] r=1  (not used)
FILE_IMAGES                          N/A         N/A (macro) "design2"   (usage 3)
file_Index                          -235  0xffffff15 (PmmC func) args[4] r=1  (usage 3)
file_LoadFunction                   -249  0xffffff07 (PmmC func) args[1] r=1  (not used)
file_LoadImageControl               -252  0xffffff04 (PmmC func) args[3] r=1  (usage 3)
FILE_MODE                             17  0x00000011 (const dword)  (not used)
file_Mount                          -253  0xffffff03 (PmmC func) args[0] r=1  (usage 6)
FILE_NAME                             11  0x0000000b (const dword)  (not used)
file_Open                           -231  0xffffff19 (PmmC func) args[2] r=1  (usage 8)
FILE_PAGEFLAG                         19  0x00000013 (const dword)  (not used)
file_PlayWAV                        -255  0xffffff01 (PmmC func) args[1] r=1  (not used)
file_PutC                           -241  0xffffff0f (PmmC func) args[2] r=1  (not used)
file_PutS                           -245  0xffffff0b (PmmC func) args[2] r=1  (not used)
file_PutW                           -243  0xffffff0d (PmmC func) args[2] r=1  (not used)
file_Read                           -233  0xffffff17 (PmmC func) args[3] r=1  (usage 2)
file_Rewind                         -248  0xffffff08 (PmmC func) args[1] r=1  (not used)
file_Run                            -250  0xffffff06 (PmmC func) args[2] r=1  (not used)
file_ScreenCapture                  -240  0xffffff10 (PmmC func) args[5] r=1  (not used)
file_Seek                           -234  0xffffff16 (PmmC func) args[3] r=1  (not used)
FILE_SEEK_POS_HI                       6  0x00000006 (const dword)  (not used)
FILE_SEEK_POS_LO                       5  0x00000005 (const dword)  (not used)
file_Size                           -238  0xffffff12 (PmmC func) args[3] r=1  (not used)
FILE_SIZE_HI                           8  0x00000008 (const dword)  (not used)
FILE_SIZE_LO                           7  0x00000007 (const dword)  (not used)
file_Tell                           -236  0xffffff14 (PmmC func) args[3] r=1  (not used)
FILE_TIME                              9  0x00000009 (const dword)  (not used)
file_Unmount                        -254  0xffffff02 (PmmC func) args[0] r=0  (usage 2)
file_Write                          -237  0xffffff13 (PmmC func) args[3] r=1  (usage 3)
FileErrors                             7  0x00000007FileErrors                             7  0x00000007 (mem) word[20] (member of C:\Users\Corentin THOMASSET\Documents\Application\NoName2.4dg)  (not used)
FIREBRICK                          45316  0x0000b104 (const dword)  (not used)
flash_BlockErase                    -157  0xffffff63 (PmmC func) args[1] r=1  (not used)
flash_BulkErase                     -156  0xffffff64 (PmmC func) args[0] r=0  (not used)
flash_ID                            -155  0xffffff65 (PmmC func) args[0] r=1  (not used)
flash_SIG                           -154  0xffffff66 (PmmC func) args[0] r=1  (not used)
FLORALWHITE                        65502  0x0000ffde (const dword)  (not used)
FONT1                                  0  0x00000000 (const dword)  (not used)
FONT2                                  1  0x00000001 (const dword)  (not used)
FONT3                                  2  0x00000002 (const dword)  (not used)
FONT_ID                                2  0x00000002 (const dword)  (not used)
FONT_SIZE                              2  0x00000002 (const dword)  (not used)
FORESTGREEN                         9284  0x00002444 (const dword)  (not used)
FRAME_DELAY                           22  0x00000016 (const dword)  (not used)
FUCHSIA                            63519  0x0000f81f (const dword)  (not used)
GAINSBORO                          57083  0x0000defb (const dword)  (not used)
GAMMA_CONTROL_1                       70  0x00000046 (const dword)  (not used)
GAMMA_CONTROL_10                      79  0x0000004f (const dword)  (not used)
GAMMA_CONTROL_11                      80  0x00000050 (const dword)  (not used)
GAMMA_CONTROL_12                      81  0x00000051 (const dword)  (not used)
GAMMA_CONTROL_2                       71  0x00000047 (const dword)  (not used)
GAMMA_CONTROL_3                       72  0x00000048 (const dword)  (not used)
GAMMA_CONTROL_4                       73  0x00000049 (const dword)  (not used)
GAMMA_CONTROL_5                       74  0x0000004a (const dword)  (not used)
GAMMA_CONTROL_6                       75  0x0000004b (const dword)  (not used)
GAMMA_CONTROL_7                       76  0x0000004c (const dword)  (not used)
GAMMA_CONTROL_8                       77  0x0000004d (const dword)  (not used)
GAMMA_CONTROL_9                       78  0x0000004e (const dword)  (not used)
getDateTimeI2C                      5794  0x000016a2 (User func) args[0] r=0  (usage 9)
getHumidityI2C                      5961  0x00001749 (User func) args[0] r=0  (usage 9)
getMax                              6228  0x00001854 (User func) args[2] r=0  (usage 3)
getMin                              6299  0x0000189b (User func) args[2] r=0  (usage 3)
getTempI2C                          6089  0x000017c9 (User func) args[0] r=0  (usage 9)
getTempInSD                         6376  0x000018e8 (User func) args[2] r=0  (usage 3)
getTempInSD.ret                       68  0x00000044 (mem) word[30] (member of getTempInSD)  (usage 2)
getTouchStatus                      4784  0x000012b0 (User func) args[0] r=0  (usage 17)
GFX                                63489  0x0000f801 (const dword)  (not used)
gfx_332to565                         -85  0xffffffab (PmmC func) args[1] r=1  (not used)
gfx_BevelShadow                     -104  0xffffff98 (PmmC func) args[1] r=1  (not used)
gfx_BevelWidth                      -103  0xffffff99 (PmmC func) args[1] r=1  (not used)
gfx_BGcolour                         -92  0xffffffa4 (PmmC func) args[1] r=1  (not used)
GFX_BOTTOM                            51  0x00000033 (const dword)  (not used)
gfx_BoxTo                            -74  0xffffffb6 (PmmC func) args[2] r=0  (not used)
gfx_Bullet                           -71  0xffffffb9 (PmmC func) args[1] r=0  (usage 3)
gfx_Button                           -80  0xffffffb0 (PmmC func) args[9] r=0  (not used)
GFX_BUTTON_BACKGROUND                 64  0x00000040 (const dword)  (not used)
GFX_BUTTON_FOREGROUND                 63  0x0000003f (const dword)  (not used)
GFX_BUTTON_MODE                       65  0x00000041 (const dword)  (not used)
gfx_ChangeColour                     -76  0xffffffb4 (PmmC func) args[2] r=0  (not used)
gfx_Circle                           -61  0xffffffc3 (PmmC func) args[4] r=0  (usage 6)
gfx_CircleFilled                     -62  0xffffffc2 (PmmC func) args[4] r=0  (usage 6)
GFX_CLIP_BOTTOM                      114  0x00000072 (const dword)  (not used)
GFX_CLIP_BOTTOM_VAL                  110  0x0000006e (const dword)  (not used)
GFX_CLIP_LEFT                        111  0x0000006f (const dword)  (not used)
GFX_CLIP_LEFT_VAL                    107  0x0000006b (const dword)  (not used)
GFX_CLIP_RIGHT                       113  0x00000071 (const dword)  (not used)
GFX_CLIP_RIGHT_VAL                   109  0x0000006d (const dword)  (not used)
GFX_CLIP_TOP                         112  0x00000070 (const dword)  (not used)
GFX_CLIP_TOP_VAL                     108  0x0000006c (const dword)  (not used)
gfx_Clipping                         -94  0xffffffa2 (PmmC func) args[1] r=0  (usage 180)
gfx_ClipWindow                       -75  0xffffffb5 (PmmC func) args[4] r=0  (usage 9)
gfx_Cls                              -51  0xffffffcd (PmmC func) args[0] r=0  (usage 6)
gfx_ColourMode                      -102  0xffffff9a (PmmC func) args[1] r=1  (not used)
gfx_Contrast                        -100  0xffffff9c (PmmC func) args[1] r=1  (not used)
gfx_Dot                              -70  0xffffffba (PmmC func) args[0] r=0  (not used)
gfx_Ellipse                          -78  0xffffffb2 (PmmC func) args[5] r=0  (not used)
gfx_EllipseFilled                    -79  0xffffffb1 (PmmC func) args[5] r=0  (not used)
gfx_FrameDelay                       -97  0xffffff9f (PmmC func) args[1] r=1  (not used)
gfx_Get                              -90  0xffffffa6 (PmmC func) args[1] r=1  (not used)
gfx_GetPixel                         -64  0xffffffc0 (PmmC func) args[2] r=1  (not used)
GFX_HILIGHT_BACKGROUND                61  0x0000003d (const dword)  (not used)
GFX_HILIGHT_FOREGROUND                62  0x0000003e (const dword)  (not used)
GFX_HILITE_LINE                       58  0x0000003a (const dword)  (not used)
gfx_Hline                            -57  0xffffffc7 (PmmC func) args[4] r=1  (not used)
gfx_IncX                             -72  0xffffffb8 (PmmC func) args[0] r=1  (not used)
gfx_IncY                             -73  0xffffffb7 (PmmC func) args[0] r=1  (not used)
GFX_LAST_CHAR_HEIGHT                 120  0x00000078 (const dword)  (not used)
GFX_LAST_CHAR_WIDTH                  119  0x00000077 (const dword)  (not used)
GFX_LAST_SELECTION                    60  0x0000003c (const dword)  (not used)
GFX_LAST_STR_HEIGHT                  122  0x0000007a (const dword)  (not used)
GFX_LAST_STR_WIDTH                   121  0x00000079 (const dword)  (not used)
GFX_LEFT                              48  0x00000030 (const dword)  (not used)
GFX_LEFT_GUTTER_WIDTH                 68  0x00000044 (const dword)  (not used)
gfx_Line                             -56  0xffffffc8 (PmmC func) args[5] r=0  (usage 15)
GFX_LINE_COUNT                        59  0x0000003b (const dword)  (not used)
gfx_LinePattern                     -101  0xffffff9b (PmmC func) args[1] r=1  (usage 4)
gfx_LineRel                          -55  0xffffffc9 (PmmC func) args[2] r=0  (not used)
gfx_LineTo                           -54  0xffffffca (PmmC func) args[2] r=0  (usage 3)
gfx_MoveRel                          -53  0xffffffcb (PmmC func) args[2] r=0  (not used)
gfx_MoveTo                           -52  0xffffffcc (PmmC func) args[2] r=0  (usage 6)
gfx_ObjectColour                     -93  0xffffffa3 (PmmC func) args[1] r=1  (not used)
gfx_Orbit                            -67  0xffffffbd (PmmC func) args[2] r=0  (not used)
gfx_OrbitInit                        -66  0xffffffbe (PmmC func) args[2] r=0  (not used)
gfx_Origin                           -89  0xffffffa7 (PmmC func) args[2] r=0  (not used)
gfx_OutlineColour                    -99  0xffffff9d (PmmC func) args[1] r=1  (usage 4)
gfx_Panel                            -81  0xffffffaf (PmmC func) args[6] r=0  (not used)
gfx_PenSize                          -91  0xffffffa5 (PmmC func) args[1] r=1  (not used)
GFX_PIXEL_SHIFT                       70  0x00000046 (const dword)  (not used)
gfx_Polygon                          -69  0xffffffbb (PmmC func) args[4] r=0  (not used)
gfx_PolygonFilled                    -88  0xffffffa8 (PmmC func) args[4] r=0  (not used)
gfx_Polyline                         -68  0xffffffbc (PmmC func) args[4] r=0  (not used)
gfx_PutPixel                         -63  0xffffffc1 (PmmC func) args[3] r=0  (not used)
GFX_RECT_X1                           71  0x00000047 (const dword)  (not used)
GFX_RECT_X2                           73  0x00000049 (const dword)  (not used)
GFX_RECT_Y1                           72  0x00000048 (const dword)  (not used)
GFX_RECT_Y2                           74  0x0000004a (const dword)  (not used)
gfx_Rectangle                        -59  0xffffffc5 (PmmC func) args[5] r=0  (not used)
gfx_RectangleFilled                  -60  0xffffffc4 (PmmC func) args[5] r=0  (usage 11)
gfx_RGBto565                         -84  0xffffffac (PmmC func) args[3] r=1  (not used)
GFX_RIGHT                             50  0x00000032 (const dword)  (not used)
GFX_RIGHT_GUTTER_WIDTH                69  0x00000045 (const dword)  (not used)
gfx_ScreenCopyPaste                  -83  0xffffffad (PmmC func) args[6] r=0  (not used)
gfx_ScreenMode                       -98  0xffffff9e (PmmC func) args[1] r=1  (usage 3)
gfx_Selection                        -86  0xffffffaa (PmmC func) args[3] r=0  (not used)
gfx_Set                              -50  0xffffffce (PmmC func) args[2] r=0  (usage 6)
gfx_SetClipRegion                    -77  0xffffffb3 (PmmC func) args[0] r=0  (not used)
gfx_Slider                           -82  0xffffffae (PmmC func) args[8] r=1  (not used)
GFX_STATUSBAR_HEIGHT                  67  0x00000043 (const dword)  (not used)
GFX_THUMB_BORDER_DARK                 76  0x0000004c (const dword)  (not used)
GFX_THUMB_BORDER_LIGHT                77  0x0000004d (const dword)  (not used)
GFX_THUMB_PERCENT                     75  0x0000004b (const dword)  (not used)
GFX_TOOLBAR_HEIGHT                    66  0x00000042 (const dword)  (not used)
GFX_TOP                               49  0x00000031 (const dword)  (not used)
GFX_TOUCH_REGION_X1                  103  0x00000067 (const dword)  (not used)
GFX_TOUCH_REGION_X2                  105  0x00000069 (const dword)  (not used)
GFX_TOUCH_REGION_Y1                  104  0x00000068 (const dword)  (not used)
GFX_TOUCH_REGION_Y2                  106  0x0000006a (const dword)  (not used)
gfx_Transparency                     -96  0xffffffa0 (PmmC func) args[1] r=1  (usage 3)
gfx_TransparentColour                -95  0xffffffa1 (PmmC func) args[1] r=1  (usage 3)
gfx_Triangle                         -65  0xffffffbf (PmmC func) args[7] r=0  (not used)
gfx_TriangleFilled                   -87  0xffffffa9 (PmmC func) args[7] r=0  (usage 6)
gfx_Vline                            -58  0xffffffc6 (PmmC func) args[4] r=1  (not used)
GFX_X1                                52  0x00000034 (const dword)  (not used)
GFX_X2                                54  0x00000036 (const dword)  (not used)
GFX_X_ORG                             56  0x00000038 (const dword)  (not used)
GFX_XMAX                              46  0x0000002e (const dword)  (not used)
gfx_Xorigin                         -105  0xffffff97 (PmmC func) args[1] r=1  (not used)
GFX_Y1                                53  0x00000035 (const dword)  (not used)
GFX_Y2                                55  0x00000037 (const dword)  (not used)
GFX_Y_ORG                             57  0x00000039 (const dword)  (not used)
GFX_YMAX                              47  0x0000002f (const dword)  (not used)
gfx_Yorigin                         -106  0xffffff96 (PmmC func) args[1] r=1  (not used)
GHOSTWHITE                         65503  0x0000ffdf (const dword)  (not used)
glbBackgroundType                     52  0x00000034 (mem) word (global)  (usage 109)
glbDateTime                            2  0x00000002 (mem) word[20] (global)  (usage 261)
glbFrequenceSaveData                  50  0x00000032 (mem) word (global)  (usage 40)
glbHumidity                           44  0x0000002c (mem) word (global)  (usage 12)
glbIsCelcius                          46  0x0000002e (mem) word (global)  (usage 28)
glbModeSleepOn                        48  0x00000030 (mem) word (global)  (usage 22)
glbStateDispaly                       54  0x00000036 (mem) word (global)  (usage 34)
glbTemperature                        42  0x0000002a (mem) word (global)  (usage 24)
glbUpdateFrequenceToogleMainScreen     132  0x00000084 (mem) word (global)  (usage 31)
glbUpdatingMainScreen                130  0x00000082 (mem) word (global)  (usage 19)
GOLD                               65184  0x0000fea0 (const dword)  (not used)
GOLDENROD                          56612  0x0000dd24 (const dword)  (not used)
GRAM_PIXEL_COUNT_HI                  116  0x00000074 (const dword)  (not used)
GRAM_PIXEL_COUNT_LO                  115  0x00000073 (const dword)  (not used)
GRAY                               33808  0x00008410 (const dword)  (not used)
GREEN                               1024  0x00000400 (const dword)  (not used)
GREENYELLOW                        45029  0x0000afe5 (const dword)  (not used)
H                                    240  0x000000f0 (const dword)  (usage 1)
HEX                                 5136  0x00001410 (const dword)  (not used)
HEX1                                4368  0x00001110 (const dword)  (not used)
HEX1Z                                272  0x00000110 (const dword)  (not used)
HEX1ZB                              8464  0x00002110 (const dword)  (not used)
HEX2                                4624  0x00001210 (const dword)  (not used)
HEX2Z                                528  0x00000210 (const dword)  (not used)
HEX2ZB                              8720  0x00002210 (const dword)  (not used)
HEX3                                4880  0x00001310 (const dword)  (not used)
HEX3Z                                784  0x00000310 (const dword)  (not used)
HEX3ZB                              8976  0x00002310 (const dword)  (not used)
HEX4                                5136  0x00001410 (const dword)  (not used)
HEX4Z                               1040  0x00000410 (const dword)  (not used)
HEX4ZB                              9232  0x00002410 (const dword)  (not used)
HEXZ                                1040  0x00000410 (const dword)  (not used)
HEXZB                               9232  0x00002410 (const dword)  (not used)
HI                                     1  0x00000001 (const dword)  (not used)
HIbyte                              -214  0xffffff2a (PmmC func) args[1] r=1  (not used)
HIDE                                   2  0x00000002 (const dword)  (not used)
historicScreen                      3518  0x00000dbe (User func) args[0] r=0  (usage 3)
hndl                                   0  0x00000000 (mem) word (global)  (usage 182)
HONEYDEW                           63486  0x0000f7fe (const dword)  (not used)
HOTPINK                            64342  0x0000fb56 (const dword)  (not used)
I2C                                63520  0x0000f820 (const dword)  (not used)
I2C_Ack                             -169  0xffffff57 (PmmC func) args[0] r=0  (usage 21)
I2C_AckPoll                         -172  0xffffff54 (PmmC func) args[1] r=1  (not used)
I2C_AckStatus                       -171  0xffffff55 (PmmC func) args[0] r=0  (not used)
I2C_ADDRESS_CPT_TEMP                  78  0x0000004e (const dword)  (usage 6)
I2C_ADDRESS_RTC                      222  0x000000de (const dword)  (usage 9)
I2C_Close                           -163  0xffffff5d (PmmC func) args[0] r=0  (usage 2)
I2C_FAST                               2  0x00000002 (const dword)  (not used)
I2C_Getn                            -175  0xffffff51 (PmmC func) args[2] r=1  (not used)
I2C_Gets                            -174  0xffffff52 (PmmC func) args[2] r=1  (not used)
I2C_Idle                            -173  0xffffff53 (PmmC func) args[0] r=0  (not used)
I2C_MED                                1  0x00000001 (const dword)  (not used)
I2C_Nack                            -170  0xffffff56 (PmmC func) args[0] r=0  (usage 9)
I2C_Open                            -162  0xffffff5e (PmmC func) args[1] r=0  (usage 3)
I2C_Putn                            -177  0xffffff4f (PmmC func) args[2] r=1  (not used)
I2C_Puts                            -176  0xffffff50 (PmmC func) args[1] r=1  (not used)
I2C_Read                            -167  0xffffff59 (PmmC func) args[0] r=1  (usage 27)
I2C_Restart                         -166  0xffffff5a (PmmC func) args[0] r=1  (usage 3)
I2C_SLOW                               0  0x00000000 (const dword)  (usage 3)
I2C_Start                           -164  0xffffff5c (PmmC func) args[0] r=1  (usage 12)
I2C_Stop                            -165  0xffffff5b (PmmC func) args[0] r=1  (usage 6)
I2C_Write                           -168  0xffffff58 (PmmC func) args[1] r=1  (usage 24)
I_COLOUR16                            16  0x00000010 (const dword)  (not used)
I_DARKEN                           16384  0x00004000 (const dword)  (not used)
I_ENABLED                          32768  0x00008000 (const dword)  (not used)
I_LIGHTEN                           8192  0x00002000 (const dword)  (not used)
I_MOVIE                              128  0x00000080 (const dword)  (not used)
I_NOGROUP                             64  0x00000040 (const dword)  (not used)
I_STAYONTOP                          256  0x00000100 (const dword)  (not used)
I_TOPMOST                            512  0x00000200 (const dword)  (not used)
I_TOUCH_DISABLE                       32  0x00000020 (const dword)  (not used)
I_TOUCHED                           4096  0x00001000 (const dword)  (not used)
I_X_LOCK                            1024  0x00000400 (const dword)  (not used)
I_Y_LOCK                            2048  0x00000800 (const dword)  (not used)
iCpt                              UNRESOLVED  (usage 7)
IMAGE_BACK                            11  0x0000000b (const dword)  (usage 9)
IMAGE_BACK_HISORIC                    17  0x00000011 (const dword)  (usage 3)
IMAGE_BG_COLD                          2  0x00000002 (const dword)  (usage 3)
IMAGE_BG_COLD_CIRCLE                   3  0x00000003 (const dword)  (not used)
IMAGE_BG_NORMAL                        0  0x00000000 (const dword)  (usage 3)
IMAGE_BG_NORMAL_CIRCLE                 1  0x00000001 (const dword)  (not used)
IMAGE_BG_WARM                          4  0x00000004 (const dword)  (usage 3)
IMAGE_BG_WARM_CIRCLE                   5  0x00000005 (const dword)  (not used)
IMAGE_BTN_TOOGLE                      15  0x0000000f (const dword)  (usage 9)
IMAGE_CEL_FAR                         13  0x0000000d (const dword)  (usage 6)
IMAGE_CLUSTER                         10  0x0000000a (const dword)  (not used)
IMAGE_DELAY                            7  0x00000007 (const dword)  (not used)
IMAGE_DIGIT_BIG                        6  0x00000006 (const dword)  (usage 60)
IMAGE_DIGIT_SMALL                      7  0x00000007 (const dword)  (usage 87)
IMAGE_DIGIT_XSMALL                     8  0x00000008 (const dword)  (usage 21)
IMAGE_FLAGS                            6  0x00000006 (const dword)  (not used)
IMAGE_FRAMES                           8  0x00000008 (const dword)  (not used)
IMAGE_HEIGHT                           5  0x00000005 (const dword)  (not used)
IMAGE_HIWORD                           1  0x00000001 (const dword)  (not used)
IMAGE_INDEX                            9  0x00000009 (const dword)  (usage 15)
IMAGE_LOADING                         18  0x00000012 (const dword)  (usage 3)
IMAGE_LOWORD                           0  0x00000000 (const dword)  (not used)
IMAGE_MENU_PANEL                      10  0x0000000a (const dword)  (usage 3)
IMAGE_MONTH                            9  0x00000009 (const dword)  (usage 18)
IMAGE_ON_OFF                          12  0x0000000c (const dword)  (usage 9)
IMAGE_SECTOR                          11  0x0000000b (const dword)  (not used)
IMAGE_SETTING_0                       14  0x0000000e (const dword)  (usage 3)
IMAGE_SETTING_1                       16  0x00000010 (const dword)  (usage 3)
IMAGE_TAG                             12  0x0000000c (const dword)  (not used)
IMAGE_TAG2                            13  0x0000000d (const dword)  (not used)
IMAGE_WIDTH                            4  0x00000004 (const dword)  (not used)
IMAGE_XPOS                             2  0x00000002 (const dword)  (not used)
IMAGE_YPOS                             3  0x00000003 (const dword)  (not used)
img_ClearAttributes                 -187  0xffffff45 (PmmC func) args[3] r=1  (not used)
IMG_COUNT                              0  0x00000000 (const dword)  (not used)
IMG_CURRENT_FRAME                     89  0x00000059 (const dword)  (not used)
img_Darken                          -181  0xffffff4b (PmmC func) args[2] r=1  (not used)
IMG_DAT_FILENAME                       4  0x00000004 (const dword)  (not used)
img_Disable                         -180  0xffffff4c (PmmC func) args[2] r=1  (not used)
img_Enable                          -179  0xffffff4d (PmmC func) args[2] r=1  (not used)
IMG_ENTRYLEN                           1  0x00000001 (const dword)  (not used)
IMG_FLAGS                             85  0x00000055 (const dword)  (not used)
IMG_FRAME_COUNT                       86  0x00000056 (const dword)  (not used)
IMG_FRAME_DELAY                       84  0x00000054 (const dword)  (not used)
IMG_GCI_FILENAME                       3  0x00000003 (const dword)  (not used)
IMG_GCIFILE_HANDLE                     5  0x00000005 (const dword)  (not used)
img_GetWord                         -184  0xffffff48 (PmmC func) args[3] r=1  (not used)
IMG_HEIGHT                            83  0x00000053 (const dword)  (not used)
img_Lighten                         -182  0xffffff4a (PmmC func) args[2] r=1  (not used)
IMG_MODE                               2  0x00000002 (const dword)  (not used)
IMG_PIXEL_COUNT_HI                    88  0x00000058 (const dword)  (not used)
IMG_PIXEL_COUNT_LO                    87  0x00000057 (const dword)  (not used)
img_SetAttributes                   -186  0xffffff46 (PmmC func) args[3] r=1  (not used)
img_SetPosition                     -178  0xffffff4e (PmmC func) args[4] r=1  (usage 12)
img_SetWord                         -183  0xffffff49 (PmmC func) args[4] r=1  (usage 15)
img_Show                            -185  0xffffff47 (PmmC func) args[2] r=1  (usage 147)
img_Touched                         -188  0xffffff44 (PmmC func) args[2] r=1  (not used)
IMG_WIDTH                             82  0x00000052 (const dword)  (not used)
INDIANRED                          51947  0x0000caeb (const dword)  (not used)
INDIGO                             18448  0x00004810 (const dword)  (not used)
INPUT                                  1  0x00000001 (const dword)  (not used)
INVERSE                               64  0x00000040 (const dword)  (not used)
IO1_PIN                                1  0x00000001 (const dword)  (not used)
IO2_PIN                                2  0x00000002 (const dword)  (not used)
IO3_PIN                                3  0x00000003 (const dword)  (not used)
IO4_PIN                                4  0x00000004 (const dword)  (not used)
IO5_PIN                                5  0x00000005 (const dword)  (not used)
isalnum                             -207  0xffffff31 (PmmC func) args[1] r=1  (not used)
isalpha                             -206  0xffffff32 (PmmC func) args[1] r=1  (not used)
isdigit                             -202  0xffffff36 (PmmC func) args[1] r=1  (not used)
isDotInBox                          5682  0x00001632 (User func) args[6] r=0  (usage 92)
isInBox                             7192  0x00001c18 (User func) args[6] r=0  (usage 9)
islower                             -205  0xffffff33 (PmmC func) args[1] r=1  (not used)
isprint                             -208  0xffffff30 (PmmC func) args[1] r=1  (not used)
isspace                             -209  0xffffff2f (PmmC func) args[1] r=1  (not used)
isupper                             -204  0xffffff34 (PmmC func) args[1] r=1  (not used)
iswhite                             -210  0xffffff2e (PmmC func) args[1] r=1  (not used)
isxdigit                            -203  0xffffff35 (PmmC func) args[1] r=1  (not used)
ITALIC                                32  0x00000020 (const dword)  (not used)
iterator                            -198  0xffffff3a (PmmC func) args[1] r=0  (not used)
IVORY                              65534  0x0000fffe (const dword)  (not used)
KHAKI                              63281  0x0000f731 (const dword)  (not used)
LANDSCAPE                              0  0x00000000 (const dword)  (not used)
LANDSCAPE_R                            1  0x00000001 (const dword)  (usage 3)
LAVENDER                           59199  0x0000e73f (const dword)  (not used)
LAVENDERBLUSH                      65438  0x0000ff9e (const dword)  (not used)
LAWNGREEN                          32736  0x00007fe0 (const dword)  (not used)
LEFT_POS                               2  0x00000002 (const dword)  (not used)
LEMONCHIFFON                       65497  0x0000ffd9 (const dword)  (not used)
LIGHTBLUE                          44764  0x0000aedc (const dword)  (not used)
LIGHTCORAL                         62480  0x0000f410 (const dword)  (not used)
LIGHTCYAN                          59391  0x0000e7ff (const dword)  (not used)
LIGHTGOLD                          65498  0x0000ffda (const dword)  (not used)
LIGHTGREEN                         38770  0x00009772 (const dword)  (not used)
LIGHTGREY                          54938  0x0000d69a (const dword)  (not used)
LIGHTPINK                          64952  0x0000fdb8 (const dword)  (not used)
LIGHTSALMON                        64783  0x0000fd0f (const dword)  (not used)
LIGHTSEAGREEN                       9621  0x00002595 (const dword)  (not used)
LIGHTSKYBLUE                       34431  0x0000867f (const dword)  (not used)
LIGHTSLATEGRAY                     29779  0x00007453 (const dword)  (not used)
LIGHTSTEELBLUE                     46651  0x0000b63b (const dword)  (not used)
LIGHTYELLOW                        65532  0x0000fffc (const dword)  (not used)
LIME                                2016  0x000007e0 (const dword)  (not used)
LIMEGREEN                          13926  0x00003666 (const dword)  (not used)
LINE_PATTERN                          26  0x0000001a (const dword)  (not used)
LINEN                              65436  0x0000ff9c (const dword)  (not used)
LO                                     0  0x00000000 (const dword)  (not used)
LObyte                              -213  0xffffff2b (PmmC func) args[1] r=1  (not used)
LPFINE                            UNRESOLVED  (not used)
LPSOLID                           UNRESOLVED  (not used)
MAGENTA                            63519  0x0000f81f (const dword)  (not used)
main                                 863  0x0000035f (User func) args[0] r=0  (not used)
mainScreen                          4097  0x00001001 (User func) args[0] r=0  (usage 3)
mainScreen.state                     136  0x00000088 (mem) word (member of mainScreen)  (usage 12)
mainStateGraph                      4696  0x00001258 (User func) args[0] r=0  (usage 3)
MAROON                             32768  0x00008000 (const dword)  (not used)
MAX                                  -15  0xfffffff1 (PmmC func) args[2] r=1  (not used)
MDA                                63552  0x0000f840 (const dword)  (not used)
MEDIA_ADDRESS_HI                      91  0x0000005b (const dword)  (not used)
MEDIA_ADDRESS_LO                      90  0x0000005a (const dword)  (not used)
MEDIA_ADDRESS_MW                      92  0x0000005c (const dword)  (not used)
MEDIA_ADDRESS_UW                      93  0x0000005d (const dword)  (not used)
media_Flush                         -118  0xffffff8a (PmmC func) args[0] r=1  (not used)
media_Image                         -117  0xffffff8b (PmmC func) args[2] r=0  (not used)
media_Init                          -119  0xffffff89 (PmmC func) args[0] r=1  (not used)
media_RdSector                      -111  0xffffff91 (PmmC func) args[1] r=1  (not used)
media_ReadByte                      -113  0xffffff8f (PmmC func) args[0] r=1  (not used)
media_ReadWord                      -114  0xffffff8e (PmmC func) args[0] r=1  (not used)
MEDIA_SECTOR_COUNT                    94  0x0000005e (const dword)  (not used)
MEDIA_SECTOR_HI                      124  0x0000007c (const dword)  (not used)
MEDIA_SECTOR_LO                      123  0x0000007b (const dword)  (not used)
media_SetAdd                        -109  0xffffff93 (PmmC func) args[2] r=0  (not used)
media_SetSector                     -110  0xffffff92 (PmmC func) args[2] r=0  (not used)
media_Video                         -107  0xffffff95 (PmmC func) args[2] r=0  (not used)
media_VideoFrame                    -108  0xffffff94 (PmmC func) args[3] r=0  (not used)
media_WriteByte                     -115  0xffffff8d (PmmC func) args[1] r=1  (not used)
media_WriteWord                     -116  0xffffff8c (PmmC func) args[1] r=1  (not used)
media_WrSector                      -112  0xffffff90 (PmmC func) args[1] r=1  (not used)
MEDIUMAQUAMARINE                   26229  0x00006675 (const dword)  (not used)
MEDIUMBLUE                            25  0x00000019 (const dword)  (not used)
MEDIUMORCHID                       47802  0x0000baba (const dword)  (not used)
MEDIUMPURPLE                       37787  0x0000939b (const dword)  (not used)
MEDIUMSEAGREEN                     15758  0x00003d8e (const dword)  (not used)
MEDIUMSLATEBLUE                    31581  0x00007b5d (const dword)  (not used)
MEDIUMSPRINGGREEN                   2003  0x000007d3 (const dword)  (not used)
MEDIUMTURQUOISE                    20121  0x00004e99 (const dword)  (not used)
MEDIUMVIOLETRED                    49328  0x0000c0b0 (const dword)  (not used)
mem_Alloc                           -216  0xffffff28 (PmmC func) args[1] r=1  (usage 5)
mem_AllocV                          -217  0xffffff27 (PmmC func) args[1] r=1  (not used)
mem_AllocZ                          -218  0xffffff26 (PmmC func) args[1] r=1  (not used)
mem_Compare                         -224  0xffffff20 (PmmC func) args[3] r=1  (not used)
mem_Copy                            -223  0xffffff21 (PmmC func) args[3] r=1  (not used)
mem_Free                            -220  0xffffff24 (PmmC func) args[1] r=1  (usage 2)
mem_Heap                            -221  0xffffff23 (PmmC func) args[0] r=1  (not used)
mem_Realloc                         -219  0xffffff25 (PmmC func) args[2] r=1  (not used)
mem_Set                             -222  0xffffff22 (PmmC func) args[3] r=1  (not used)
MEMORY_ACCESS_CONTROL                 22  0x00000016 (const dword)  (not used)
menuScreen                          3914  0x00000f4a (User func) args[0] r=0  (usage 3)
MIDI                                   9  0x00000009 (const dword)  (not used)
MIDNIGHTBLUE                        6350  0x000018ce (const dword)  (not used)
MIN                                  -14  0xfffffff2 (PmmC func) args[2] r=1  (not used)
MINTCREAM                          63487  0x0000f7ff (const dword)  (not used)
MISTYROSE                          65340  0x0000ff3c (const dword)  (not used)
MOCCASIN                           65334  0x0000ff36 (const dword)  (not used)
modeEco                             5208  0x00001458 (User func) args[0] r=0  (usage 3)
myClipWindow                        5724  0x0000165c (User func) args[4] r=0  (usage 84)
myPow                               6525  0x0000197d (User func) args[2] r=0  (usage 9)
myRectangle                       UNRESOLVED (User func) args[5] r=0  (not used)
NAVAJOWHITE                        65269  0x0000fef5 (const dword)  (not used)
NAVY                                  16  0x00000010 (const dword)  (not used)
nbDigit                             5627  0x000015fb (User func) args[1] r=0  (usage 3)
NOTOUCH                                0  0x00000000 (const dword)  (not used)
OBJECT_COLOUR                         18  0x00000012 (const dword)  (not used)
OFF                                    0  0x00000000 (const dword)  (usage 90)
olddhour                          UNRESOLVED  (usage 4)
olddmin                           UNRESOLVED  (usage 4)
olddsec                           UNRESOLVED  (usage 4)
OLDLACE                            65468  0x0000ffbc (const dword)  (not used)
olduhour                          UNRESOLVED  (usage 4)
oldumin                           UNRESOLVED  (usage 4)
oldusec                           UNRESOLVED  (usage 4)
OLIVE                              33792  0x00008400 (const dword)  (not used)
OLIVEDRAB                          27748  0x00006c64 (const dword)  (not used)
ON                                     1  0x00000001 (const dword)  (usage 93)
OPAQUE                                 1  0x00000001 (const dword)  (not used)
ORANGE                             64800  0x0000fd20 (const dword)  (not used)
ORANGERED                          64032  0x0000fa20 (const dword)  (not used)
ORCHID                             56218  0x0000db9a (const dword)  (not used)
OSC_CONTROL_1                         25  0x00000019 (const dword)  (not used)
OSC_CONTROL_3                        147  0x00000093 (const dword)  (not used)
OUTLINE                                1  0x00000001 (const dword)  (usage 3)
OUTLINE_COLOUR                        24  0x00000018 (const dword)  (not used)
OUTPUT                                 0  0x00000000 (const dword)  (not used)
OVF                                  -21  0xffffffeb (PmmC func) args[0] r=1  (not used)
PALEGOLDENROD                      61269  0x0000ef55 (const dword)  (not used)
PALEGREEN                          40915  0x00009fd3 (const dword)  (not used)
PALETURQUOISE                      44925  0x0000af7d (const dword)  (not used)
PALEVIOLETRED                      56210  0x0000db92 (const dword)  (not used)
PANEL_HIDE                             2  0x00000002 (const dword)  (not used)
PANEL_RAISED                           1  0x00000001 (const dword)  (not used)
PANEL_SUNKEN                           0  0x00000000 (const dword)  (not used)
PAPAYAWHIP                         65402  0x0000ff7a (const dword)  (not used)
pause                                 -6  0xfffffffa (PmmC func) args[1] r=0  (usage 9)
PEACHPUFF                          65239  0x0000fed7 (const dword)  (not used)
peekW                                -11  0xfffffff5 (PmmC func) args[1] r=1  (not used)
PEN_SIZE                              16  0x00000010 (const dword)  (usage 6)
PERU                               52263  0x0000cc27 (const dword)  (not used)
PICASO                                 1  0x00000001 (const dword)  (usage 3)
PICASO_FUNCTIONS                       0  0x00000000 (const ??? 0)  (not used)
pin_HI                               -42  0xffffffd6 (PmmC func) args[1] r=1  (not used)
pin_LO                               -43  0xffffffd5 (PmmC func) args[1] r=1  (not used)
pin_Read                             -44  0xffffffd4 (PmmC func) args[1] r=1  (not used)
pin_Set                              -41  0xffffffd7 (PmmC func) args[2] r=1  (not used)
PINK                               65049  0x0000fe19 (const dword)  (not used)
PLUM                               56603  0x0000dd1b (const dword)  (not used)
pokeW                                -12  0xfffffff4 (PmmC func) args[2] r=0  (not used)
PORTRAIT                               2  0x00000002 (const dword)  (not used)
PORTRAIT_R                             3  0x00000003 (const dword)  (not used)
POWDERBLUE                         46876  0x0000b71c (const dword)  (not used)
POWER_CONTROL_1                       27  0x0000001b (const dword)  (not used)
POWER_CONTROL_2                       28  0x0000001c (const dword)  (not used)
POWER_CONTROL_3                       29  0x0000001d (const dword)  (not used)
POWER_CONTROL_4                       30  0x0000001e (const dword)  (not used)
POWER_CONTROL_5                       31  0x0000001f (const dword)  (not used)
POWER_CONTROL_6                       32  0x00000020 (const dword)  (not used)
PROGRESSBAR_HIDE                       2  0x00000002 (const dword)  (not used)
PROGRESSBAR_RAISED                 65535  0x0000ffff (const dword)  (not used)
PROGRESSBAR_SUNKEN                 65534  0x0000fffe (const dword)  (not used)
PURPLE                             32784  0x00008010 (const dword)  (not used)
putch                                 -2  0xfffffffe (PmmC func) args[1] r=0  (not used)
putnum                                -7  0xfffffff9 (PmmC func) args[2] r=1  (not used)
putstr                                -9  0xfffffff7 (PmmC func) args[1] r=1  (usage 6)
RAND                                 -19  0xffffffed (PmmC func) args[0] r=1  (not used)
RANDOM_HI                             33  0x00000021 (const dword)  (not used)
RANDOM_LO                             32  0x00000020 (const dword)  (not used)
READ_WRITE_DATA                       34  0x00000022 (const dword)  (not used)
readAllOnSD                       UNRESOLVED (User func) args[0] r=0  (not used)
readOnSD                            6588  0x000019bc (User func) args[2] r=0  (usage 6)
RED                                63488  0x0000f800 (const dword)  (not used)
report                              7191  0x00001c17 (User func) args[1] r=0  (usage 26)
reserved                            -294  0xfffffeda (PmmC func) args[0] r=0  (not used)
ret                               UNRESOLVED  (usage 9)
RGBINT_CONTROL_1                      56  0x00000038 (const dword)  (not used)
RIGHT_POS                              4  0x00000004 (const dword)  (not used)
ROSYBROWN                          48241  0x0000bc71 (const dword)  (not used)
ROW_ADDRESS_END1                       9  0x00000009 (const dword)  (not used)
ROW_ADDRESS_END2                       8  0x00000008 (const dword)  (not used)
ROW_ADDRESS_START1                     7  0x00000007 (const dword)  (not used)
ROW_ADDRESS_START2                     6  0x00000006 (const dword)  (not used)
ROYALBLUE                          17244  0x0000435c (const dword)  (not used)
RTCRead                             5316  0x000014c4 (User func) args[1] r=0  (usage 33)
RTCWrite                            5273  0x00001499 (User func) args[2] r=0  (usage 18)
RUNFLASH                             128  0x00000080 (const dword)  (usage 3)
RXMODE_0                               0  0x00000000 (const dword)  (not used)
RXMODE_1                               1  0x00000001 (const dword)  (not used)
SADDLEBROWN                        35362  0x00008a22 (const dword)  (not used)
SALMON                             64526  0x0000fc0e (const dword)  (not used)
SANDYBROWN                         62764  0x0000f52c (const dword)  (not used)
saveDataInSD                        4884  0x00001314 (User func) args[0] r=0  (usage 3)
SCREEN_MODE                           23  0x00000017 (const dword)  (not used)
SEAGREEN                           11338  0x00002c4a (const dword)  (not used)
SEASHELL                           65469  0x0000ffbd (const dword)  (not used)
SEED                                 -20  0xffffffec (PmmC func) args[1] r=0  (not used)
SELECT                                 3  0x00000003 (const dword)  (not used)
SELECT_MULTIPLE                        4  0x00000004 (const dword)  (not used)
serin                                 -1  0xffffffff (PmmC func) args[0] r=1  (not used)
serin1                              -140  0xffffff74 (PmmC func) args[0] r=1  (not used)
serout                                -3  0xfffffffd (PmmC func) args[1] r=0  (not used)
serout1                             -141  0xffffff73 (PmmC func) args[1] r=0  (not used)
setbaud                               -4  0xfffffffc (PmmC func) args[1] r=0  (not used)
setDateTimeI2C                      5468  0x0000155c (User func) args[0] r=0  (usage 3)
setDown                           UNRESOLVED (User func) args[0] r=0  (not used)
settingPannel0                      2434  0x00000982 (User func) args[0] r=0  (usage 3)
settingPannel1                       873  0x00000369 (User func) args[0] r=0  (usage 3)
settingScreen                       3448  0x00000d78 (User func) args[0] r=0  (usage 3)
settingScreen.stateSetting           138  0x0000008a (mem) word (member of settingScreen)  (usage 10)
setUp                               6830  0x00001aae (User func) args[0] r=0  (usage 3)
setUpRTC                            5745  0x00001671 (User func) args[0] r=0  (usage 3)
SIENNA                             41605  0x0000a285 (const dword)  (not used)
SILVER                             50712  0x0000c618 (const dword)  (not used)
SIN                                  -17  0xffffffef (PmmC func) args[1] r=1  (not used)
SKYBLUE                            34429  0x0000867d (const dword)  (not used)
SLATEBLUE                          27353  0x00006ad9 (const dword)  (not used)
SLATEGRAY                          29714  0x00007412 (const dword)  (not used)
SLIDER_HIDE                            2  0x00000002 (const dword)  (not used)
SLIDER_RAISED                          1  0x00000001 (const dword)  (not used)
SLIDER_SUNKEN                          0  0x00000000 (const dword)  (not used)
snd_BufSize                         -258  0xfffffefe (PmmC func) args[1] r=0  (not used)
snd_Continue                        -261  0xfffffefb (PmmC func) args[0] r=0  (not used)
snd_Pause                           -260  0xfffffefc (PmmC func) args[0] r=0  (not used)
snd_Pitch                           -257  0xfffffeff (PmmC func) args[1] r=1  (not used)
snd_Playing                         -262  0xfffffefa (PmmC func) args[0] r=1  (not used)
snd_Stop                            -259  0xfffffefd (PmmC func) args[0] r=0  (not used)
snd_Volume                          -256  0xffffff00 (PmmC func) args[1] r=0  (not used)
SNOW                               65503  0x0000ffdf (const dword)  (not used)
SOLID                                  0  0x00000000 (const dword)  (usage 3)
spi_Disable                         -153  0xffffff67 (PmmC func) args[0] r=0  (not used)
SPI_FAST                               0  0x00000000 (const dword)  (not used)
spi_Init                            -150  0xffffff6a (PmmC func) args[3] r=0  (not used)
SPI_MED                                1  0x00000001 (const dword)  (not used)
spi_Read                            -151  0xffffff69 (PmmC func) args[0] r=1  (not used)
SPI_SLOW                               2  0x00000002 (const dword)  (not used)
spi_Write                           -152  0xffffff68 (PmmC func) args[1] r=0  (not used)
SPRINGGREEN                         2031  0x000007ef (const dword)  (not used)
SQRT                                 -22  0xffffffea (PmmC func) args[1] r=1  (not used)
state                             UNRESOLVED  (usage 16)
STATE_HISTORIC                         4  0x00000004 (const dword)  (usage 6)
STATE_INIT                             0  0x00000000 (const dword)  (usage 6)
STATE_MAIN_SCREEN                      1  0x00000001 (const dword)  (usage 9)
STATE_MENU_SCREEN                      2  0x00000002 (const dword)  (usage 15)
STATE_SETTING                          3  0x00000003 (const dword)  (usage 12)
stateSetting                      UNRESOLVED  (usage 1)
STEELBLUE                          17430  0x00004416 (const dword)  (not used)
STOP                              UNRESOLVED (User func) args[0] r=0  (not used)
STR                                  128  0x00000080 (const dword)  (not used)
str_ByteMove                        -286  0xfffffee2 (PmmC func) args[3] r=1  (not used)
str_Cat                             -278  0xfffffeea (PmmC func) args[2] r=1  (not used)
str_CatN                            -279  0xfffffee9 (PmmC func) args[3] r=1  (not used)
str_Copy                            -287  0xfffffee1 (PmmC func) args[2] r=1  (not used)
str_CopyN                           -288  0xfffffee0 (PmmC func) args[3] r=1  (not used)
str_Find                            -274  0xfffffeee (PmmC func) args[2] r=1  (not used)
str_FindI                           -275  0xfffffeed (PmmC func) args[2] r=1  (not used)
str_GetByte                         -268  0xfffffef4 (PmmC func) args[1] r=1  (not used)
str_GetC                            -267  0xfffffef5 (PmmC func) args[2] r=1  (usage 6)
str_GetD                            -264  0xfffffef8 (PmmC func) args[2] r=1  (not used)
str_GetHexW                         -266  0xfffffef6 (PmmC func) args[2] r=1  (not used)
str_GetW                            -265  0xfffffef7 (PmmC func) args[2] r=1  (not used)
str_GetWord                         -269  0xfffffef3 (PmmC func) args[1] r=1  (not used)
str_Length                          -276  0xfffffeec (PmmC func) args[1] r=1  (usage 3)
str_Match                           -272  0xfffffef0 (PmmC func) args[2] r=1  (not used)
str_MatchI                          -273  0xfffffeef (PmmC func) args[2] r=1  (not used)
str_Printf                          -277  0xfffffeeb (PmmC func) args[2] r=1  (not used)
str_Ptr                             -263  0xfffffef9 (PmmC func) args[1] r=1  (usage 15)
str_PutByte                         -270  0xfffffef2 (PmmC func) args[2] r=0  (usage 48)
str_PutWord                         -271  0xfffffef1 (PmmC func) args[2] r=0  (not used)
strheight                           -161  0xffffff5f (PmmC func) args[0] r=1  (not used)
strlen                               -10  0xfffffff6 (PmmC func) args[1] r=1  (not used)
strwidth                            -160  0xffffff60 (PmmC func) args[1] r=1  (not used)
STYLE1                                 2  0x00000002 (const dword)  (not used)
STYLE2                                 3  0x00000003 (const dword)  (not used)
SWAP                                 -16  0xfffffff0 (PmmC func) args[2] r=0  (not used)
sys_DeepSleep                       -295  0xfffffed9 (PmmC func) args[1] r=1  (not used)
sys_EventQueue                      -194  0xffffff3e (PmmC func) args[0] r=1  (not used)
sys_EventsPostpone                  -195  0xffffff3d (PmmC func) args[0] r=0  (not used)
sys_EventsResume                    -196  0xffffff3c (PmmC func) args[0] r=0  (usage 3)
sys_GetTimer                        -192  0xffffff40 (PmmC func) args[1] r=1  (not used)
sys_SetTimer                        -191  0xffffff41 (PmmC func) args[2] r=0  (usage 39)
sys_SetTimerEvent                   -193  0xffffff3f (PmmC func) args[2] r=1  (usage 15)
sys_Sleep                           -197  0xffffff3b (PmmC func) args[1] r=1  (usage 3)
sys_StoreTouchCalibration           -280  0xfffffee8 (PmmC func) args[0] r=1  (not used)
sys_T                               -189  0xffffff43 (PmmC func) args[0] r=1  (not used)
sys_T_HI                            -190  0xffffff42 (PmmC func) args[0] r=1  (not used)
SYS_X_MAX                             44  0x0000002c (const dword)  (not used)
SYS_Y_MAX                             45  0x0000002d (const dword)  (not used)
SYSTEM_TIMER_HI                       35  0x00000023 (const dword)  (not used)
SYSTEM_TIMER_LO                       34  0x00000022 (const dword)  (not used)
TAN                                54705  0x0000d5b1 (const dword)  (not used)
TEAL                                1040  0x00000410 (const dword)  (not used)
TEXT                               63489  0x0000f801 (const dword)  (not used)
TEXT_ATTRIBUTES                       13  0x0000000d (const dword)  (not used)
TEXT_BACKGROUND                        1  0x00000001 (const dword)  (not used)
TEXT_BOLD                              9  0x00000009 (const dword)  (not used)
TEXT_COLOUR                            0  0x00000000 (const dword)  (not used)
TEXT_HEIGHT                            4  0x00000004 (const dword)  (usage 4)
TEXT_HIGHLIGHT                         1  0x00000001 (const dword)  (not used)
TEXT_INVERSE                          11  0x0000000b (const dword)  (not used)
TEXT_ITALIC                           10  0x0000000a (const dword)  (not used)
TEXT_MARGIN                           97  0x00000061 (const dword)  (not used)
TEXT_OPACITY                           8  0x00000008 (const dword)  (not used)
TEXT_PRINTDELAY                        7  0x00000007 (const dword)  (not used)
TEXT_UNDERLINED                       12  0x0000000c (const dword)  (not used)
TEXT_WIDTH                             3  0x00000003 (const dword)  (usage 4)
TEXT_WRAP                             14  0x0000000e (const dword)  (not used)
TEXT_XGAP                              5  0x00000005 (const dword)  (not used)
TEXT_XPOS                             95  0x0000005f (const dword)  (not used)
TEXT_YGAP                              6  0x00000006 (const dword)  (not used)
TEXT_YPOS                             96  0x00000060 (const dword)  (not used)
THISTLE                            56827  0x0000ddfb (const dword)  (not used)
TIMER0                                 0  0x00000000 (const dword)  (not used)
TIMER1                                 1  0x00000001 (const dword)  (usage 9)
TIMER2                                 2  0x00000002 (const dword)  (usage 12)
TIMER3                                 3  0x00000003 (const dword)  (usage 9)
TIMER4                                 4  0x00000004 (const dword)  (usage 6)
TIMER5                                 5  0x00000005 (const dword)  (not used)
TIMER6                                 6  0x00000006 (const dword)  (not used)
TIMER7                                 7  0x00000007 (const dword)  (usage 18)
TMR0                                  36  0x00000024 (const dword)  (not used)
TMR1                                  37  0x00000025 (const dword)  (not used)
TMR2                                  38  0x00000026 (const dword)  (not used)
TMR3                                  39  0x00000027 (const dword)  (not used)
TMR4                                  40  0x00000028 (const dword)  (not used)
TMR5                                  41  0x00000029 (const dword)  (not used)
TMR6                                  42  0x0000002a (const dword)  (not used)
TMR7                                  43  0x0000002b (const dword)  (not used)
to                                    -5  0xfffffffb (PmmC func) args[1] r=1  (usage 6)
tolower                             -212  0xffffff2c (PmmC func) args[1] r=1  (not used)
TOMATO                             64264  0x0000fb08 (const dword)  (not used)
TOP_POS                                3  0x00000003 (const dword)  (not used)
touch_DetectRegion                  -199  0xffffff39 (PmmC func) args[4] r=0  (not used)
TOUCH_DISABLE                          1  0x00000001 (const dword)  (not used)
TOUCH_ENABLE                           0  0x00000000 (const dword)  (usage 3)
touch_Get                           -201  0xffffff37 (PmmC func) args[1] r=1  (usage 37)
TOUCH_GETX                             1  0x00000001 (const dword)  (usage 17)
TOUCH_GETY                             2  0x00000002 (const dword)  (usage 17)
TOUCH_MOVING                           3  0x00000003 (const dword)  (usage 6)
TOUCH_PRESSED                          1  0x00000001 (const dword)  (usage 23)
TOUCH_RAW_X                          117  0x00000075 (const dword)  (not used)
TOUCH_RAW_Y                          118  0x00000076 (const dword)  (not used)
TOUCH_REGIONDEFAULT                    2  0x00000002 (const dword)  (not used)
TOUCH_RELEASED                         2  0x00000002 (const dword)  (usage 3)
touch_Set                           -200  0xffffff38 (PmmC func) args[1] r=0  (usage 3)
TOUCH_STATUS                           0  0x00000000 (const dword)  (usage 3)
TOUCH_XMAXCAL                         80  0x00000050 (const dword)  (not used)
TOUCH_XMINCAL                         78  0x0000004e (const dword)  (not used)
TOUCH_YMAXCAL                         81  0x00000051 (const dword)  (not used)
TOUCH_YMINCAL                         79  0x0000004f (const dword)  (not used)
toupper                             -211  0xffffff2d (PmmC func) args[1] r=1  (not used)
translate                             -8  0xfffffff8 (PmmC func) args[4] r=1  (not used)
TRANSPARENCY                          21  0x00000015 (const dword)  (not used)
TRANSPARENT                            0  0x00000000 (const dword)  (not used)
TRANSPARENT_COLOR                  61309  0x0000ef7d (const dword)  (usage 3)
TRANSPARENT_COLOUR                    20  0x00000014 (const dword)  (not used)
TURQUOISE                          18202  0x0000471a (const dword)  (not used)
txt_Attributes                       -38  0xffffffda (PmmC func) args[1] r=1  (not used)
txt_BGcolour                         -26  0xffffffe6 (PmmC func) args[1] r=1  (not used)
txt_Bold                             -34  0xffffffde (PmmC func) args[1] r=1  (not used)
txt_Delay                            -32  0xffffffe0 (PmmC func) args[1] r=1  (not used)
txt_FGcolour                         -25  0xffffffe7 (PmmC func) args[1] r=1  (not used)
TXT_FONT_HEIGHT                      102  0x00000066 (const dword)  (not used)
TXT_FONT_ID                           98  0x00000062 (const dword)  (not used)
TXT_FONT_MAX                          99  0x00000063 (const dword)  (not used)
TXT_FONT_OFFSET                      100  0x00000064 (const dword)  (not used)
TXT_FONT_WIDTH                       101  0x00000065 (const dword)  (not used)
txt_FontID                           -27  0xffffffe5 (PmmC func) args[1] r=1  (not used)
txt_Height                           -29  0xffffffe3 (PmmC func) args[1] r=1  (not used)
txt_Inverse                          -36  0xffffffdc (PmmC func) args[1] r=1  (not used)
txt_Italic                           -35  0xffffffdd (PmmC func) args[1] r=1  (not used)
txt_MoveCursor                       -23  0xffffffe9 (PmmC func) args[2] r=0  (not used)
txt_Opacity                          -33  0xffffffdf (PmmC func) args[1] r=1  (not used)
txt_Set                              -24  0xffffffe8 (PmmC func) args[2] r=0  (usage 8)
txt_Underline                        -37  0xffffffdb (PmmC func) args[1] r=1  (not used)
txt_Width                            -28  0xffffffe4 (PmmC func) args[1] r=1  (not used)
txt_Wrap                             -39  0xffffffd9 (PmmC func) args[1] r=1  (not used)
txt_Xgap                             -30  0xffffffe2 (PmmC func) args[1] r=1  (not used)
txt_Ygap                             -31  0xffffffe1 (PmmC func) args[1] r=1  (not used)
U_DAY                                  6  0x00000006 (const dword)  (usage 21)
U_HOUR                                 4  0x00000004 (const dword)  (usage 42)
U_MINUTES                              2  0x00000002 (const dword)  (usage 39)
U_MONTH                                8  0x00000008 (const dword)  (usage 18)
U_SECONDES                             0  0x00000000 (const dword)  (usage 6)
U_YEAR                                10  0x0000000a (const dword)  (usage 3)
uadd_3232                           -290  0xfffffede (PmmC func) args[3] r=1  (not used)
ucmp_3232                           -292  0xfffffedc (PmmC func) args[2] r=1  (not used)
UDEC                               17674  0x0000450a (const dword)  (not used)
UDEC1                              16650  0x0000410a (const dword)  (not used)
UDEC1Z                             20746  0x0000510a (const dword)  (not used)
UDEC1ZB                            24842  0x0000610a (const dword)  (not used)
UDEC2                              16906  0x0000420a (const dword)  (not used)
UDEC2Z                             21002  0x0000520a (const dword)  (not used)
UDEC2ZB                            25098  0x0000620a (const dword)  (not used)
UDEC3                              17162  0x0000430a (const dword)  (not used)
UDEC3Z                             21258  0x0000530a (const dword)  (not used)
UDEC3ZB                            25354  0x0000630a (const dword)  (not used)
UDEC4                              17418  0x0000440a (const dword)  (not used)
UDEC4Z                             21514  0x0000540a (const dword)  (not used)
UDEC4ZB                            25610  0x0000640a (const dword)  (not used)
UDEC5                              17674  0x0000450a (const dword)  (not used)
UDEC5Z                             21770  0x0000550a (const dword)  (not used)
UDEC5ZB                            25866  0x0000650a (const dword)  (not used)
UDECZ                              21770  0x0000550a (const dword)  (not used)
UDECZB                             25866  0x0000650a (const dword)  (not used)
ULCD_32PT_GFX                          0  0x00000000 (const ??? 0)  (not used)
umul_1616                           -289  0xfffffedf (PmmC func) args[3] r=1  (usage 6)
UNDERLINED                           128  0x00000080 (const dword)  (not used)
unicode_page                        -281  0xfffffee7 (PmmC func) args[3] r=1  (not used)
UP                                     1  0x00000001 (const dword)  (not used)
updatingDate                        4670  0x0000123e (User func) args[0] r=0  (usage 3)
updatingTemp                        4605  0x000011fd (User func) args[0] r=0  (usage 3)
updatingToogle                      4413  0x0000113d (User func) args[0] r=0  (usage 3)
updatingToogle.cpt                   134  0x00000086 (mem) word (member of updatingToogle)  (usage 9)
USER_INITIALIZED_DISPLAY              32  0x00000020 (const dword)  (not used)
usub_3232                           -291  0xfffffedd (PmmC func) args[3] r=1  (not used)
VCOM_CONTROL_1                        67  0x00000043 (const dword)  (not used)
VCOM_CONTROL_2                        68  0x00000044 (const dword)  (not used)
VCOM_CONTROL_3                        69  0x00000045 (const dword)  (not used)
VIOLET                             60445  0x0000ec1d (const dword)  (not used)
W                                    320  0x00000140 (const dword)  (usage 1)
WHEAT                              63222  0x0000f6f6 (const dword)  (not used)
WHITE                              65535  0x0000ffff (const dword)  (usage 44)
WHITESMOKE                         63422  0x0000f7be (const dword)  (not used)
writeInReg                          5379  0x00001503 (User func) args[4] r=0  (usage 12)
writeOnSD                           6745  0x00001a59 (User func) args[1] r=0  (usage 3)
X_MAX                                  0  0x00000000 (const dword)  (not used)
X_ORG                                  6  0x00000006 (const dword)  (not used)
X_ORIGIN                              30  0x0000001e (const dword)  (not used)
Y_MAX                                  1  0x00000001 (const dword)  (not used)
Y_ORG                                  7  0x00000007 (const dword)  (not used)
Y_ORIGIN                              31  0x0000001f (const dword)  (not used)
YELLOW                             65504  0x0000ffe0 (const dword)  (not used)
YELLOWGREEN                        40550  0x00009e66 (const dword)  (not used)
